# Access Control

How authentication, authorisation, and resource access scoping work together in the Mesh API.

## Key Concepts

Four concepts form the access control model of the Mesh API:

1. **Method Options** — protobuf annotations on each RPC method declaring its type, access level, roles, and verification requirements
2. **Executing Entity** — the User or API User performing the API call
3. **Executing Group** — the group context in which the call is executed
4. **Resource Ownership** — the `owner` and `owners` fields on every resource

## Authentication

All authorised API methods require two headers:

```
x-api-key: {api_key}
x-group: groups/{group_ulid}
```

- **`x-api-key`** — authenticates the executing entity (API User via API key, or User via access token)
- **`x-group`** — specifies the group context for the operation

Public methods (`METHOD_ACCESS_LEVEL_PUBLIC`) can be called without credentials. If credentials are provided on a public method they are validated but not required.

### Security Best Practices

- Store API keys in environment variables or secret managers — never in source control
- Rotate API keys regularly and deactivate unused API users promptly
- Use environment-specific group configurations rather than hardcoded group IDs

## Method Options

Every RPC method is annotated with method options that declare its authorisation requirements. There are four dimensions:

```protobuf
import "meshtrade/option/method_options/v1/method_options.proto";

service AccountService {
  rpc CreateAccount(CreateAccountRequest) returns (Account) {
    option (meshtrade.option.method_options.v1.method_options) = {
      type: METHOD_TYPE_WRITE
      access_level: METHOD_ACCESS_LEVEL_AUTHORISED
      roles: [
        ROLE_WALLET_ADMIN,
        ROLE_WALLET_ACCOUNT_ADMIN
      ]
      verification_status: VERIFICATION_STATUS_VERIFIED
    };
  }

  rpc GetAccount(GetAccountRequest) returns (Account) {
    option (meshtrade.option.method_options.v1.method_options) = {
      type: METHOD_TYPE_READ
      access_level: METHOD_ACCESS_LEVEL_AUTHORISED
      roles: [
        ROLE_WALLET_ADMIN,
        ROLE_WALLET_VIEWER,
        ROLE_WALLET_ACCOUNT_ADMIN,
        ROLE_WALLET_ACCOUNT_VIEWER
      ]
      verification_status: VERIFICATION_STATUS_VERIFIED
    };
  }
}
```

### Method Type

Defines whether the method is a read or write operation. This determines how resource access scoping is applied:

| Type | Description | Scoping Rule |
|------|-------------|--------------|
| `METHOD_TYPE_READ` | Safe, idempotent query | Resources where executing group is anywhere in the `owners` hierarchy |
| `METHOD_TYPE_WRITE` | State-changing mutation | Only resources directly owned by the executing group (`owner`) |

### Access Level

Determines whether credentials are required:

| Level | `x-api-key` | `x-group` | Description |
|-------|-------------|-----------|-------------|
| `METHOD_ACCESS_LEVEL_PUBLIC` | Optional | Ignored | Anonymous access allowed |
| `METHOD_ACCESS_LEVEL_AUTHORISED` | Required | Required | Credentials and group context required |

### Roles

The set of roles that grant access to the method. The executing entity needs **at least one** of these roles assigned in the ownership hierarchy of the executing group.

Roles are enum values following the naming convention `ROLE_{DOMAIN}_{SCOPE}_{LEVEL}`:

- **Domain** — business area (WALLET, TRADING, IAM, COMPLIANCE, STUDIO, REPORTING)
- **Scope** — optional specific resource type (ACCOUNT, USER, GROUP, API_USER)
- **Level** — ADMIN (read + write) or VIEWER (read only)

Admin roles at a domain level include all sub-domain admin and viewer roles. For example, `ROLE_IAM_ADMIN` includes `ROLE_IAM_GROUP_ADMIN`, `ROLE_IAM_USER_VIEWER`, etc.

### Verification Status (Optional)

When set to `VERIFICATION_STATUS_VERIFIED`, the method is only accessible if the compliance client associated with the executing user has been verified (KYC/KYB complete). If omitted, the method is accessible regardless of verification status.

This is used to gate sensitive operations like trading and wallet management behind completed compliance verification.

## Resource Ownership

Every resource has two ownership fields:

```protobuf
message Account {
  // Direct owner — the group that created/owns this resource
  string owner = 1;   // e.g. "groups/01ABC..."

  // Ownership hierarchy — full path from root to owner
  repeated string owners = 2;  // e.g. ["groups/ROOT...", "groups/BROKER...", "groups/01ABC..."]
}
```

### Groups and Hierarchy

Groups are the fundamental organisational unit. They form tree structures through ownership — each group has exactly one parent group (except the root). Every resource (users, accounts, orders, instruments) belongs to exactly one group.

```mermaid
graph TD
    Root["Root Group<br/>groups/ROOT"]
    BrokerA["Broker A<br/>groups/BROKER_A"]
    ClientX["Client X<br/>groups/CLIENT_X"]
    Account["Trading Account<br/>accounts/ACC_1<br/>owner: CLIENT_X"]

    Root --> BrokerA
    BrokerA --> ClientX
    ClientX --> Account

    style Root fill:#e1f5fe
    style BrokerA fill:#c8e6c9
    style ClientX fill:#fff3e0
    style Account fill:#fce4ec
```

### Read vs Write Access

**Read** (METHOD_TYPE_READ): the executing group can access resources owned by itself **or any descendant group**.

**Write** (METHOD_TYPE_WRITE): the executing group can only access resources it **directly owns**.

```mermaid
graph TD
    subgraph "Read Access — Broker A as executing group"
        RA_Broker["Broker A<br/>(executing group)"]
        RA_ClientX["Client X"]
        RA_ClientY["Client Y"]
        RA_Res1["Resource 1<br/>owner: Broker A<br/>&#10003; accessible"]
        RA_Res2["Resource 2<br/>owner: Client X<br/>&#10003; accessible"]
        RA_Res3["Resource 3<br/>owner: Client Y<br/>&#10003; accessible"]

        RA_Broker --> RA_ClientX
        RA_Broker --> RA_ClientY
        RA_Broker -.-> RA_Res1
        RA_ClientX -.-> RA_Res2
        RA_ClientY -.-> RA_Res3
    end

    style RA_Res1 fill:#c8e6c9
    style RA_Res2 fill:#c8e6c9
    style RA_Res3 fill:#c8e6c9
```

```mermaid
graph TD
    subgraph "Write Access — Broker A as executing group"
        WA_Broker["Broker A<br/>(executing group)"]
        WA_ClientX["Client X"]
        WA_ClientY["Client Y"]
        WA_Res1["Resource 1<br/>owner: Broker A<br/>&#10003; accessible"]
        WA_Res2["Resource 2<br/>owner: Client X<br/>&#10007; not accessible"]
        WA_Res3["Resource 3<br/>owner: Client Y<br/>&#10007; not accessible"]

        WA_Broker --> WA_ClientX
        WA_Broker --> WA_ClientY
        WA_Broker -.-> WA_Res1
        WA_ClientX -.-> WA_Res2
        WA_ClientY -.-> WA_Res3
    end

    style WA_Res1 fill:#c8e6c9
    style WA_Res2 fill:#ffcdd2
    style WA_Res3 fill:#ffcdd2
```

## Executing Entity

Both **Users** (human, via web/mobile) and **API Users** (programmatic, via API key) follow the same authorisation model. Each has a list of role strings indicating which roles they hold and in which group:

```
groups/{group_ulid}/roles/{role_enum}
```

For example, an API User with `groups/01ABC.../roles/3000000` has `ROLE_TRADING_ADMIN` in group `01ABC...`. When a method labelled with that role is called, the executing group must be that group or any group below it in the hierarchy.

## Clients and Legal Entities

Clients represent compliance-verified legal entities (natural person, company, fund, or trust) within the group hierarchy. Each client is owned by a group and defines the **role boundary** for users within that organisational structure.

The client's `roles` field determines which role types can be assigned to users in groups under that client. Role inheritance simplifies this:

- A domain **viewer** role (e.g. `ROLE_IAM_VIEWER`) automatically allows all sub-domain viewer roles
- A domain **admin** role (e.g. `ROLE_IAM_ADMIN`) automatically allows all sub-domain admin and viewer roles

```mermaid
graph TD
    subgraph "Legal Entity Boundaries"
        Broker["Broker Corporation<br/>groups/BROKER"]
        BrokerClient["Broker Client Entity<br/>Type: Company<br/>Status: Verified"]
        Fund["Investment Fund<br/>groups/FUND"]
        FundClient["Fund Client Entity<br/>Type: Fund<br/>Status: Verified"]
        Individual["Individual<br/>groups/INDIVIDUAL"]
        IndividualClient["Individual Client Entity<br/>Type: Natural Person<br/>Status: Verified"]
        RegUser["Portfolio Manager<br/>(Regular User)"]
        APIUser["Risk System<br/>(API User)"]

        Broker --> BrokerClient
        Broker --> Fund
        Fund --> FundClient
        Fund --> Individual
        Individual --> IndividualClient
        Fund --> RegUser
        Fund --> APIUser
    end

    style BrokerClient fill:#e1f5fe
    style FundClient fill:#f3e5f5
    style IndividualClient fill:#fff3e0
```

## End-to-End Authorisation Flow

The following sequence shows the complete lifecycle of an authorised API request:

```mermaid
sequenceDiagram
    participant Client as API Client
    participant Gateway as API Gateway
    participant Auth as Auth Service
    participant Service as Resource Service
    participant DB as Database

    Client->>Gateway: Request + x-api-key + x-group

    Gateway->>Auth: Validate credentials

    Note over Auth: 1. Look up method options<br/>(type, access_level, roles, verification_status)
    Note over Auth: 2. Fetch executing group
    Note over Auth: 3. Identify executing entity<br/>(User via JWT or API User via key hash)
    Note over Auth: 4. Check entity has required role<br/>in executing group's ownership hierarchy
    Note over Auth: 5. Check verification status<br/>(if required by method)

    Auth->>Gateway: Authorisation passed + signed context

    Gateway->>Service: Forward with execution context

    Note over Service: Validate signed context

    Service->>DB: Query with ownership scoping
    Note over DB: READ: filter by owners contains group<br/>WRITE: filter by owner equals group

    DB->>Service: Filtered results
    Service->>Gateway: Response
    Gateway->>Client: Response
```

**The five checks performed by the auth service:**

1. **Method lookup** — retrieve method options (type, access level, roles, verification status) from the global method registry
2. **Group resolution** — fetch the executing group specified in `x-group`
3. **Entity identification** — authenticate the executing entity via JWT (User) or API key hash (API User)
4. **Role check** — verify the entity has at least one of the method's required roles, assigned in any group in the executing group's ownership hierarchy
5. **Verification check** — if the method requires `VERIFICATION_STATUS_VERIFIED`, confirm the entity's associated compliance client is verified

## Example Scenario

A brokerage platform with a broker, a corporate client, and an individual client:

```mermaid
graph TD
    subgraph "Brokerage Platform"
        Broker["Broker Corp<br/>groups/BROKER"]
        Corp["Corporate Client<br/>groups/CORP_CLIENT"]
        Individual["Individual Trader<br/>groups/INDIVIDUAL"]

        CorpManager["Portfolio Manager<br/>(Regular User)<br/>Roles: TRADING_ADMIN"]
        CorpBot["Risk Monitor<br/>(API User)<br/>Roles: TRADING_VIEWER"]
        IndTrader["John Smith<br/>(Regular User)<br/>Roles: TRADING_ADMIN"]

        CorpAccount["Corporate Account<br/>owner: CORP_CLIENT"]
        IndAccount["Personal Account<br/>owner: INDIVIDUAL"]
        Order1["Buy Order<br/>owner: CORP_CLIENT"]

        Broker --> Corp
        Broker --> Individual
        Corp --> CorpManager
        Corp --> CorpBot
        Individual --> IndTrader
        Corp --> CorpAccount
        Individual --> IndAccount
        Corp --> Order1
    end
```

**Access scenarios:**

| Who | Method | Can access | Cannot access | Why |
|-----|--------|-----------|--------------|-----|
| Broker Admin | ListAccounts (READ) | Corporate Account, Personal Account | — | Descendant group resources visible on READ |
| Portfolio Manager | CreateOrder (WRITE) | Create in CORP_CLIENT | Create in INDIVIDUAL | WRITE limited to direct owner group |
| Risk Monitor (API) | GetAccount (READ) | Corporate Account | Personal Account | READ scoped to own group + descendants only |
| John Smith | CreateOrder (WRITE) | Create in INDIVIDUAL | Create in CORP_CLIENT | WRITE limited to direct owner group |

Both regular users and API users follow identical authorisation rules — the only difference is the authentication method (credentials vs API key).

## Related Documentation

- **[Service Structure](../architecture/service-structure)** — how Mesh APIs are organised and common method patterns
- **[SDK Configuration](../architecture/sdk-configuration)** — configuring SDK clients for authentication and connectivity
- **[API Reference](/docs/api-reference/)** — complete API documentation for all services
