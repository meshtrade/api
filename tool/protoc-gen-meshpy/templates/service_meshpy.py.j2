# Code generated by protoc-gen-meshpy. DO NOT EDIT.
# source: {{ proto_file.name }}

"""
{{ service_name }} gRPC service wrapper with authentication, timeouts, and resource management.

This module provides a high-level gRPC service for the {{ service_name }} service that combines
the service interface with resource management capabilities, providing authentication,
timeouts, and proper connection handling.
"""

from datetime import timedelta

import grpc

from meshtrade.common import (
    DEFAULT_GRPC_PORT,
    DEFAULT_GRPC_URL,
    GRPCClient,
    create_auth_metadata,
)
{% if package_name == "meshtrade.iam.api_user.v1" -%}
from .api_credentials import find_credentials
{% else -%}
from meshtrade.iam.api_user.v1.api_credentials import find_credentials
{% endif %}

{% for type_name, module in external_types.items() -%}
from .{{ module }} import {{ type_name }}
{% endfor -%}
from .service_options_meshpy import ServiceOptions
{% if service_types -%}
from .{{ proto_base }}_pb2 import (
{% for type in service_types | sort -%}
    {{ type }},
{% endfor -%}
)
{% endif -%}
from .{{ proto_base }}_pb2_grpc import {{ service_name }}Stub


class {{ service_name }}Interface(GRPCClient):
    """Interface combining {{ service_name }} functionality with gRPC service resource management.

    This interface defines the contract for gRPC services that implement the {{ service_name }}
    while also providing proper resource cleanup capabilities.
    """

    pass


class {{ service_name }}({{ service_name }}Interface):
    """{{ service_name }} gRPC service with authentication, timeouts, and resource management.

    This service provides a complete implementation of the {{ service_name }} with proper authentication, timeout handling, and automatic resource cleanup.

    Full Service documentation: https://meshtrade.github.io/api/docs/api-reference/{{ doc_url_path }}

    Basic service usage with default SDK Configuration:
    ```python
    service = {{ service_name }}()

    with service:   # `with` ensures proper clean up of underlying connection after use
        response = service.get_api_user(request)
    ```
        
    With default configuration API credentials are searched for using the standard discovery hierarchy:
    
    1. MESH_API_CREDENTIALS environment variable
    2. Default credential file location:
    
    - Linux:   `$XDG_CONFIG_HOME/mesh/credentials.json` or fallback to `$HOME/.config/mesh/credentials.json`
    - macOS:   `$HOME/Library/Application Support/mesh/credentials.json`
    - Windows: `C:\\Users\\<user>\\AppData\\Roaming\\mesh\\credentials.json`
    
    For more information on authentication: https://meshtrade.github.io/api/docs/architecture/authentication

    The service may also be configured with custom options:
    ```python
    from .service_options_meshpy import ServiceOptions
    from datetime import timedelta

    options = ServiceOptions(
        url="api.staging.example.com",
        port=443,
        api_key="your-api-key",
        group="groups/your-group-id",
        timeout=timedelta(seconds=60)
    )

    service = {{ service_name }}(options)

    with service: # `with` ensures proper clean up of underlying connection after use
        response = service.get_api_user(request)
    ```

    For more information on service configuration: https://meshtrade.github.io/api/docs/architecture/sdk-configuration
    """

    def __init__(self, options: ServiceOptions | None = None):
        """Construct and initialize the {{ service_name }} service.

        Full Service documentation: https://meshtrade.github.io/api/docs/api-reference/{{ doc_url_path }}

        Args:
            options: Optional ServiceOptions for configuring the service.
                    If None, service is constructed with default configuration.
                    With default configuration API credentials are searched for using the standard discovery hierarchy:
                    
                    1. MESH_API_CREDENTIALS environment variable
                    2. Default credential file location:
                    
                    - Linux:   `$XDG_CONFIG_HOME/mesh/credentials.json` or fallback to `$HOME/.config/mesh/credentials.json`
                    - macOS:   `$HOME/Library/Application Support/mesh/credentials.json`
                    - Windows: `C:\\Users\\<user>\\AppData\\Roaming\\mesh\\credentials.json`      

                    For more information on authentication: https://meshtrade.github.io/api/docs/architecture/authentication

                    For more information on service configuration: https://meshtrade.github.io/api/docs/architecture/sdk-configuration            

        Example:
        ```python
        # construct with default configuration
        service = {{ service_name }}()

        # construct with custom configuration
        options = ServiceOptions(
            url="api.example.com",
            api_key="your-key",
            group="groups/your-group"
        )
        service = {{ service_name }}(options)
        ```
        """
        if options is None:
            options = ServiceOptions()

        # Store configuration
        self._options = options

        # Initialize gRPC service components
        self._channel: grpc.Channel | None = None
        self._stub: {{ service_name }}Stub | None = None

        # Load credentials from options or environment
        if options.api_key:
            self._api_key = options.api_key
            self._group = options.group
        else:
            # Try to load using credential discovery hierarchy (environment variable or default file)
            creds = find_credentials()
            self._api_key = creds.api_key if creds else None
            self._group = creds.group if creds else None

        # Build target URL
        url = options.url or DEFAULT_GRPC_URL
        port = options.port or DEFAULT_GRPC_PORT
        self._target = f"{url}:{port}"

    def __enter__(self):
        """Enter the runtime context for the gRPC service."""
        self._ensure_connected()
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        """Exit the runtime context and cleanup resources."""
        self.close()

    def _ensure_connected(self):
        """Ensure the gRPC channel and stub are properly initialized."""
        if self._channel is not None:
            return

        # Create appropriate credentials based on TLS setting
        if self._options.tls:
            credentials = grpc.ssl_channel_credentials()
            self._channel = grpc.secure_channel(self._target, credentials)
        else:
            self._channel = grpc.insecure_channel(self._target)

        # Create the stub
        self._stub = {{ service_name }}Stub(self._channel)

    def close(self):
        """Close the gRPC channel and cleanup resources."""
        if self._channel is not None:
            self._channel.close()
            self._channel = None
            self._stub = None

    def _call_with_auth(self, method_name: str, request, timeout: timedelta | None = None):
        """Make an authenticated gRPC call with proper error handling.

        Args:
            method_name: The name of the gRPC stub method to call
            request: The request message
            timeout: Optional timeout override

        Returns:
            The response message

        Raises:
            grpc.RpcError: If the gRPC call fails
            ValueError: If authentication credentials are missing
        """
        self._ensure_connected()

        if not self._api_key or not self._group:
            raise ValueError(
                "API key and group are required for authentication. "
                "Provide them via ServiceOptions or set MESH_API_CREDENTIALS environment variable."
            )

        if self._stub is None:
            raise RuntimeError("gRPC stub not initialized. Call _ensure_connected() first.")

        # Get the method from the stub
        method = getattr(self._stub, method_name)

        # Create authentication metadata
        metadata = create_auth_metadata(self._api_key, self._group)

        # Use provided timeout or default from options
        call_timeout = timeout or self._options.timeout
        timeout_seconds = call_timeout.total_seconds() if call_timeout else None

        # Make the authenticated call
        return method(request, metadata=metadata, timeout=timeout_seconds)

    def group(self) -> str:
        """Get the group resource name used by this service.
        
        Returns:
            The group resource name in format groups/{group_id}
            
        Raises:
            ValueError: If no group is configured
        """
        if not self._group:
            raise ValueError(
                "Group not configured. Provide via ServiceOptions or set MESH_API_CREDENTIALS environment variable."
            )
        return self._group

    {% for method in methods %}
    def {{ method.snake_name }}(self, request: {{ method.input_type.split('.')[-1] }}, timeout: timedelta | None = None) -> {{ method.output_type.split('.')[-1] }}:
        """{{ method.name }} method.

        Args:
            request: The {{ method.name }} request message
            timeout: Optional timeout override for this call

        Returns:
            The {{ method.name }} response message

        Raises:
            grpc.RpcError: If the gRPC call fails
            ValueError: If authentication credentials are missing
        """
        return self._call_with_auth("{{ method.name }}", request, timeout)

    {% endfor %}

# Create aliases to match expected exports
{{ service_name }}GRPCClient = {{ service_name }}
{{ service_name }}GRPCClientInterface = {{ service_name }}Interface
