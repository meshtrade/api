# Code generated by protoc-gen-meshpy. DO NOT EDIT.
# source: {{ proto_file.name }}

"""
gRPC client implementation for {{ service_name }}Service.

This module provides a concrete implementation of the {{ service_name }}Service
gRPC client with authentication, timeout, and error handling capabilities.
"""

from datetime import timedelta
from typing import Optional, Iterator, Union
import contextlib

import grpc
import opentelemetry.trace as trace

# TODO: Import proper protobuf message types when we have protobuf parsing
# from .{{ proto_file.name | replace('.proto', '_pb2') }} import *
# from .{{ proto_file.name | replace('.proto', '_pb2_grpc') }} import {{ service_name }}ServiceStub

from .service_meshpy import {{ service_name }}Service
from .service_grpc_client_options_meshpy import ClientOption


class {{ service_name }}GRPCClient({{ service_name }}Service):
    """
    gRPC client for {{ service_name }}Service.
    
    This client provides methods for interacting with the {{ service_name }}Service
    over gRPC with support for authentication, timeouts, retries, and distributed tracing.
    """

    def __init__(
        self,
        target: str,
        *options: ClientOption
    ):
        """
        Initialize the {{ service_name }}Service gRPC client.
        
        Args:
            target: The gRPC server address (e.g., "localhost:9090")
            *options: Variable number of ClientOption functions for configuration
        
        Example:
            ```python
            from .service_grpc_client_options_meshpy import with_tls, with_timeout
            from datetime import timedelta
            
            client = {{ service_name }}GRPCClient(
                "api.example.com:443",
                with_tls("/path/to/ca.crt"),
                with_timeout(timedelta(seconds=30))
            )
            ```
        """
        self._target = target
        self._channel: Optional[grpc.Channel] = None
        self._stub: Optional[object] = None  # TODO: Proper typing when we have protobuf parsing
        
        # Default configuration
        self._timeout: Optional[timedelta] = None
        self._headers: dict = {}
        self._tracer: Optional[trace.Tracer] = None
        
        # Apply configuration options
        for option in options:
            option(self)

    def __enter__(self):
        """Context manager entry."""
        self._ensure_connected()
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        """Context manager exit."""
        self.close()

    def _ensure_connected(self):
        """Ensure the gRPC channel and stub are initialized."""
        if self._channel is None:
            # TODO: Implement actual gRPC channel creation with proper configuration
            self._channel = grpc.insecure_channel(self._target)
            # TODO: Create proper stub when we have protobuf parsing
            # self._stub = {{ service_name }}ServiceStub(self._channel)

    def close(self):
        """Close the gRPC channel and cleanup resources."""
        if self._channel is not None:
            self._channel.close()
            self._channel = None
            self._stub = None

    def _call_with_context(self, method_name: str, request, timeout: Optional[timedelta] = None):
        """
        Make a gRPC call with proper context, tracing, and error handling.
        
        Args:
            method_name: Name of the gRPC method being called
            request: The protobuf request message
            timeout: Optional timeout for this specific call
        
        Returns:
            The protobuf response message
        """
        self._ensure_connected()
        
        # Use provided timeout or default
        call_timeout = timeout or self._timeout
        timeout_seconds = call_timeout.total_seconds() if call_timeout else None
        
        # TODO: Implement actual gRPC call with tracing and error handling
        # This is a placeholder implementation
        raise NotImplementedError(f"Method {method_name} not yet implemented")

    # TODO: Generate actual method implementations when we have protobuf parsing
    {% for method in service.method %}
    def {{ method.name | lower }}(self, request, timeout: Optional[timedelta] = None):
        """
        {{ method.name }} - TODO: Add proper documentation and typing.
        
        Args:
            request: The {{ method.name }} request message
            timeout: Optional timeout for this call
        
        Returns:
            The {{ method.name }} response message
        """
        return self._call_with_context("{{ method.name }}", request, timeout)

    {% endfor %}
