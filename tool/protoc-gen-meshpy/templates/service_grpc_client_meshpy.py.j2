# Code generated by protoc-gen-meshpy. DO NOT EDIT.
# source: {{ proto_file.name }}

"""
gRPC client implementation for {{ service_name }}.

This module provides a concrete implementation of the {{ service_name }}
gRPC client with authentication, timeout, and error handling capabilities.
"""

from datetime import timedelta
from typing import Optional, Iterator, Union
import contextlib

import grpc

from .{{ proto_base }}_pb2_grpc import {{ service_name }}Stub
from .service_meshpy import {{ service_name }}
from .service_grpc_client_options_meshpy import ClientOption


class {{ service_name }}GRPCClient({{ service_name }}):
    """
    gRPC client for {{ service_name }}.
    
    This client provides methods for interacting with the {{ service_name }}
    over gRPC with support for authentication, timeouts, and retries.
    """

    def __init__(
        self,
        target: str,
        *options: ClientOption
    ):
        """
        Initialize the {{ service_name }} gRPC client.
        
        Args:
            target: The gRPC server address (e.g., "localhost:9090")
            *options: Variable number of ClientOption functions for configuration
        
        Example:
            ```python
            from .service_grpc_client_options_meshpy import with_tls, with_timeout
            from datetime import timedelta
            
            client = {{ service_name }}GRPCClient(
                "api.example.com:443",
                with_tls("/path/to/ca.crt"),
                with_timeout(timedelta(seconds=30))
            )
            ```
        """
        self._target = target
        self._channel: Optional[grpc.Channel] = None
        self._stub: Optional[{{ service_name }}Stub] = None
        
        # Default configuration
        self._timeout: Optional[timedelta] = None
        self._headers: dict = {}
        
        # Apply configuration options
        for option in options:
            option(self)

    def __enter__(self):
        """Context manager entry."""
        self._ensure_connected()
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        """Context manager exit."""
        self.close()

    def _ensure_connected(self):
        """Ensure the gRPC channel and stub are initialized."""
        if self._channel is None:
            # TODO: Implement actual gRPC channel creation with proper configuration
            self._channel = grpc.insecure_channel(self._target)
            self._stub = {{ service_name }}Stub(self._channel)

    def close(self):
        """Close the gRPC channel and cleanup resources."""
        if self._channel is not None:
            self._channel.close()
            self._channel = None
            self._stub = None

    def _call_with_context(self, method_name: str, request, timeout: Optional[timedelta] = None):
        """
        Make a gRPC call with proper context, tracing, and error handling.
        
        Args:
            method_name: Name of the gRPC method being called
            request: The protobuf request message
            timeout: Optional timeout for this specific call
        
        Returns:
            The protobuf response message
        """
        self._ensure_connected()
        
        # Use provided timeout or default
        call_timeout = timeout or self._timeout
        timeout_seconds = call_timeout.total_seconds() if call_timeout else None
        
        # TODO: Implement actual gRPC call with error handling
        # This is a placeholder implementation
        raise NotImplementedError(f"Method {method_name} not yet implemented")

    {% for method in methods %}
    def {{ method.snake_name }}(self, request: {{ method.input_type.split('.')[-1] }}, timeout: Optional[timedelta] = None) -> {{ method.output_type.split('.')[-1] }}:
        """
        {{ method.name }} method.
        
        Args:
            request: The {{ method.name }} request message
            timeout: Optional timeout for this call
        
        Returns:
            The {{ method.name }} response message
        """
        return self._call_with_context("{{ method.name }}", request, timeout)

    {% endfor %}
