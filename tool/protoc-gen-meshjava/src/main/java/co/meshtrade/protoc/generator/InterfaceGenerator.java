package co.meshtrade.protoc.generator;

import com.squareup.javapoet.*;
import co.meshtrade.protoc.model.MethodModel;
import co.meshtrade.protoc.model.ServiceModel;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javax.lang.model.element.Modifier;
import java.time.Duration;
import java.util.Set;
import java.util.HashSet;

/**
 * Generates Java service interfaces from protobuf service definitions.
 * 
 * <p>This generator creates clean, well-documented Java interfaces that define
 * the contract for gRPC service clients. The generated interfaces extend
 * AutoCloseable to ensure proper resource cleanup and provide type-safe
 * method signatures matching the protobuf service definition.
 */
public class InterfaceGenerator {
    private static final Logger logger = LoggerFactory.getLogger(InterfaceGenerator.class);
    
    /**
     * Generates a Java service interface from a service model.
     * 
     * @param serviceModel the service model containing all necessary information
     * @return the generated Java source code as a string
     * @throws RuntimeException if code generation fails
     */
    public String generate(ServiceModel serviceModel) {
        logger.debug("Generating interface for service: {}", serviceModel.getServiceName());
        
        try {
            // Collect all required imports
            Set<String> requiredImports = new HashSet<>();
            for (MethodModel method : serviceModel.getMethods()) {
                if (method.isUnary()) {
                    requiredImports.add(method.getInputTypeQualifiedName());
                    requiredImports.add(method.getOutputTypeQualifiedName());
                }
            }
            
            // Create the interface
            TypeSpec.Builder interfaceBuilder = TypeSpec.interfaceBuilder(serviceModel.getServiceName())
                .addModifiers(Modifier.PUBLIC)
                .addSuperinterface(AutoCloseable.class)
                .addJavadoc(generateInterfaceJavadoc(serviceModel));
            
            // Add methods to the interface
            for (MethodModel method : serviceModel.getMethods()) {
                if (method.isUnary()) {
                    interfaceBuilder.addMethod(generateUnaryMethod(method));
                } else {
                    logger.warn("Skipping streaming method {} - not yet supported", method.getMethodName());
                }
            }
            
            // Add service provider name constant (matching Go generator pattern)
            interfaceBuilder.addField(generateServiceProviderNameConstant(serviceModel));
            
            // Build the complete Java file
            JavaFile javaFile = JavaFile.builder(serviceModel.getJavaPackage(), interfaceBuilder.build())
                .addFileComment("Generated by protoc-gen-meshjava. DO NOT EDIT.")
                .addFileComment("source: $L", serviceModel.getProtoFileName())
                .build();
            
            // Add manual imports for protobuf classes
            String javaFileString = javaFile.toString();
            StringBuilder imports = new StringBuilder();
            for (String importClass : requiredImports) {
                imports.append("import ").append(importClass).append(";\n");
            }
            
            // Insert imports after package declaration
            String packageLine = "package " + serviceModel.getJavaPackage() + ";";
            javaFileString = javaFileString.replace(packageLine, packageLine + "\n\n" + imports.toString());
            
            return javaFileString;
            
        } catch (Exception e) {
            String errorMsg = String.format("Failed to generate interface for service %s", 
                serviceModel.getServiceName());
            logger.error(errorMsg, e);
            throw new RuntimeException(errorMsg, e);
        }
    }
    
    /**
     * Generates JavaDoc for the service interface.
     * 
     * @param serviceModel the service model
     * @return the JavaDoc code block
     */
    private CodeBlock generateInterfaceJavadoc(ServiceModel serviceModel) {
        return CodeBlock.builder()
            .add("$L interface for the $L service.\n", serviceModel.getServiceName(), serviceModel.getServiceName())
            .add("\n")
            .add("<p>This interface defines the contract for accessing $L operations\n", serviceModel.getServiceName())
            .add("through the Meshtrade API. All implementations provide type-safe access\n")
            .add("to gRPC methods with proper authentication, timeout handling, and\n")
            .add("resource management.\n")
            .add("\n")
            .add("<p>The interface extends {@link AutoCloseable} to ensure proper cleanup\n")
            .add("of underlying connections. Always use try-with-resources or manually\n")
            .add("call {@link #close()} when done with the service.\n")
            .add("\n")
            .add("<h2>Example Usage</h2>\n")
            .add("<pre>{@code\n")
            .add("try ($L client = new $LClient()) {\n", serviceModel.getServiceName(), serviceModel.getServiceName())
            .add("    // Use the client\n")
            .add("    $L request = $L.newBuilder().build();\n", 
                serviceModel.getMethods().isEmpty() ? "SomeRequest" : serviceModel.getMethods().get(0).getInputTypeName(),
                serviceModel.getMethods().isEmpty() ? "SomeRequest" : serviceModel.getMethods().get(0).getInputTypeName())
            .add("    $L response = client.$L(request);\n", 
                serviceModel.getMethods().isEmpty() ? "SomeResponse" : serviceModel.getMethods().get(0).getOutputTypeName(),
                serviceModel.getMethods().isEmpty() ? "someMethod" : serviceModel.getMethods().get(0).getJavaMethodName())
            .add("}\n")
            .add("}</pre>\n")
            .add("\n")
            .add("@see <a href=\"$L\">Service Documentation</a>\n", serviceModel.getDocumentationUrl())
            .add("@see $LClient\n", serviceModel.getServiceName())
            .build();
    }
    
    /**
     * Generates a method specification for a unary gRPC method.
     * 
     * @param method the method model
     * @return the method specification
     */
    private MethodSpec generateUnaryMethod(MethodModel method) {
        // Create parameter for request
        ParameterSpec requestParam = ParameterSpec.builder(
            ClassName.bestGuess(method.getInputTypeName()), "request")
            .build();
        
        // Create parameter for optional timeout
        ParameterSpec timeoutParam = ParameterSpec.builder(
            ParameterizedTypeName.get(ClassName.get("java.util", "Optional"), 
                                    ClassName.get(Duration.class)), "timeout")
            .addAnnotation(AnnotationSpec.builder(ClassName.get("javax.annotation", "Nullable")).build())
            .build();
        
        // Create return type
        TypeName returnType = ClassName.bestGuess(method.getOutputTypeName());
        
        // Build the method
        return MethodSpec.methodBuilder(method.getJavaMethodName())
            .addModifiers(Modifier.PUBLIC, Modifier.ABSTRACT)
            .addParameter(requestParam)
            .addParameter(timeoutParam)
            .returns(returnType)
            .addJavadoc(generateMethodJavadoc(method))
            .build();
    }
    
    /**
     * Generates JavaDoc for a service method.
     * 
     * @param method the method model
     * @return the JavaDoc code block
     */
    private CodeBlock generateMethodJavadoc(MethodModel method) {
        return CodeBlock.builder()
            .add("$L\n", method.getDescription())
            .add("\n")
            .add("@param request the $L request message\n", method.getInputTypeName())
            .add("@param timeout optional timeout override for this call (null for default)\n")
            .add("@return the $L response\n", method.getOutputTypeName())
            .add("@throws io.grpc.StatusRuntimeException if the gRPC call fails\n")
            .add("@throws IllegalArgumentException if the request is invalid\n")
            .build();
    }
    
    /**
     * Generates the service provider name constant field.
     * 
     * <p>This constant follows the same pattern as the Go generator:
     * {@code {proto_package_with_dashes}-{ServiceName}}
     * 
     * @param serviceModel the service model
     * @return the field specification for the service provider name constant
     */
    private FieldSpec generateServiceProviderNameConstant(ServiceModel serviceModel) {
        // Convert proto package to service provider name pattern
        // e.g., "meshtrade.compliance.client.v1" -> "meshtrade-compliance-client-v1-ClientService"
        String serviceProviderName = serviceModel.getProtoPackage()
            .replace('.', '-') + "-" + serviceModel.getServiceName();
        
        String constantName = serviceModel.getServiceName().toUpperCase() + "_SERVICE_PROVIDER_NAME";
        
        return FieldSpec.builder(String.class, constantName, 
                Modifier.PUBLIC, Modifier.STATIC, Modifier.FINAL)
            .initializer("$S", serviceProviderName)
            .addJavadoc(CodeBlock.builder()
                .add("Service provider name constant for dependency injection and service discovery.\n")
                .add("\n")
                .add("<p>This constant can be used to identify this service in dependency injection\n")
                .add("frameworks, service registries, and monitoring systems.\n")
                .add("\n")
                .add("<p>Value: {@value}\n")
                .build())
            .build();
    }
}