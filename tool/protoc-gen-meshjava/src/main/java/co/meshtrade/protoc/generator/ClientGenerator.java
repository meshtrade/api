package co.meshtrade.protoc.generator;

import com.squareup.javapoet.*;
import co.meshtrade.protoc.model.MethodModel;
import co.meshtrade.protoc.model.ServiceModel;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javax.lang.model.element.Modifier;
import java.time.Duration;
import java.util.Optional;
import java.util.Set;
import java.util.HashSet;

/**
 * Generates Java gRPC client implementations from protobuf service definitions.
 * 
 * <p>This generator creates client classes that extend BaseGRPCClient and implement
 * the corresponding service interface. The generated clients provide complete
 * gRPC functionality including authentication, timeouts, retry logic, and
 * proper resource management.
 */
public class ClientGenerator {
    private static final Logger logger = LoggerFactory.getLogger(ClientGenerator.class);
    
    // Common class names used in generated code
    private static final ClassName BASE_GRPC_CLIENT = ClassName.get("co.meshtrade.api.grpc", "BaseGRPCClient");
    private static final ClassName SERVICE_OPTIONS = ClassName.get("co.meshtrade.api.config", "ServiceOptions");
    private static final ClassName DURATION = ClassName.get(Duration.class);
    private static final ClassName OPTIONAL = ClassName.get(Optional.class);
    
    /**
     * Generates a Java gRPC client implementation from a service model.
     * 
     * @param serviceModel the service model containing all necessary information
     * @return the generated Java source code as a string
     * @throws RuntimeException if code generation fails
     */
    public String generate(ServiceModel serviceModel) {
        logger.debug("Generating client for service: {}", serviceModel.getServiceName());
        
        try {
            // Collect all required imports
            Set<String> requiredImports = new HashSet<>();
            for (MethodModel method : serviceModel.getMethods()) {
                if (method.isUnary() || method.isServerSideStreaming()) {
                    requiredImports.add(method.getInputTypeQualifiedName());
                    requiredImports.add(method.getOutputTypeQualifiedName());
                }
            }
            
            // Determine the gRPC stub class name
            ClassName stubClass = ClassName.bestGuess(serviceModel.getGrpcStubClassName());
            ClassName serviceInterface = ClassName.get(serviceModel.getJavaPackage(), serviceModel.getServiceName() + "Interface");
            
            // Create the client class
            TypeSpec.Builder clientBuilder = TypeSpec.classBuilder(serviceModel.getClientClassName())
                .addModifiers(Modifier.PUBLIC, Modifier.FINAL)
                .superclass(ParameterizedTypeName.get(BASE_GRPC_CLIENT, stubClass))
                .addSuperinterface(serviceInterface)
                .addJavadoc(generateClientJavadoc(serviceModel));
            
            // Add interface compliance check (matching Go generator pattern)
            clientBuilder.addField(generateInterfaceComplianceField(serviceInterface, serviceModel.getClientClassName()));
            
            // Add constructors
            clientBuilder.addMethod(generateDefaultConstructor(serviceModel));
            clientBuilder.addMethod(generateOptionsConstructor(serviceModel));
            
            // Add method implementations
            for (MethodModel method : serviceModel.getMethods()) {
                if (method.isServerSideStreaming()) {
                    clientBuilder.addMethod(generateServerStreamingMethodImplementation(method));
                } else if (method.isUnary()) {
                    clientBuilder.addMethod(generateUnaryMethodImplementation(method));
                } else {
                    logger.warn("Skipping client/bidirectional streaming method {} - not yet supported", method.getMethodName());
                }
            }

            // Add withGroup method implementation (matching Go generator pattern)
            clientBuilder.addMethod(generateWithGroupMethodImplementation(serviceModel));

            // Build the complete Java file
            JavaFile javaFile = JavaFile.builder(serviceModel.getJavaPackage(), clientBuilder.build())
                .addFileComment("Generated by protoc-gen-meshjava. DO NOT EDIT.")
                .addFileComment("source: $L", serviceModel.getProtoFileName())
                .build();
            
            // Add manual imports for protobuf classes
            String javaFileString = javaFile.toString();
            StringBuilder imports = new StringBuilder();
            for (String importClass : requiredImports) {
                imports.append("import ").append(importClass).append(";\n");
            }
            
            // Insert imports after package declaration
            String packageLine = "package " + serviceModel.getJavaPackage() + ";";
            javaFileString = javaFileString.replace(packageLine, packageLine + "\n\n" + imports.toString());
            
            return javaFileString;
            
        } catch (Exception e) {
            String errorMsg = String.format("Failed to generate client for service %s", 
                serviceModel.getServiceName());
            logger.error(errorMsg, e);
            throw new RuntimeException(errorMsg, e);
        }
    }
    
    /**
     * Generates comprehensive JavaDoc for the client class matching Go generator quality.
     * 
     * @param serviceModel the service model
     * @return the JavaDoc code block
     */
    private CodeBlock generateClientJavadoc(ServiceModel serviceModel) {
        return CodeBlock.builder()
            .add("$L gRPC client with authentication, timeouts, and resource management.\n", 
                serviceModel.getServiceName())
            .add("\n")
            .add("<p>This client provides type-safe access to $L operations through the Meshtrade API.\n", serviceModel.getServiceName())
            .add("It extends {@link co.meshtrade.api.grpc.BaseGRPCClient} for consistent authentication,\n")
            .add("timeout handling, and automatic resource cleanup across all\n")
            .add("Meshtrade services.\n")
            .add("\n")
            .add("<p>Full Service documentation: <a href=\"$L\">$L API Reference</a>\n", 
                serviceModel.getDocumentationUrl(), serviceModel.getServiceName())
            .add("\n")
            .add("<h2>Quick Start</h2>\n")
            .add("<pre>{@code\n")
            .add("// Default configuration with credential auto-discovery\n")
            .add("try ($L client = new $L()) {\n", serviceModel.getClientClassName(), serviceModel.getClientClassName())
            .add("    $L request = $L.newBuilder()\n", 
                serviceModel.getMethods().isEmpty() ? "SomeRequest" : serviceModel.getMethods().get(0).getInputTypeName(),
                serviceModel.getMethods().isEmpty() ? "SomeRequest" : serviceModel.getMethods().get(0).getInputTypeName())
            .add("        .build();\n")
            .add("    $L response = client.$L(request, Optional.empty());\n", 
                serviceModel.getMethods().isEmpty() ? "SomeResponse" : serviceModel.getMethods().get(0).getOutputTypeName(),
                serviceModel.getMethods().isEmpty() ? "someMethod" : serviceModel.getMethods().get(0).getJavaMethodName())
            .add("    // Process response...\n")
            .add("} // Automatic cleanup\n")
            .add("}</pre>\n")
            .add("\n")
            .add("<h2>Authentication</h2>\n")
            .add("<p>The client uses automatic credential discovery with the following hierarchy:\n")
            .add("<ol>\n")
            .add("<li><strong>MESH_API_CREDENTIALS environment variable</strong></li>\n")
            .add("<li><strong>Platform-specific credential files</strong>:\n")
            .add("    <ul>\n")
            .add("    <li>Linux: {@code $$XDG_CONFIG_HOME/mesh/credentials.json} or {@code ~/.config/mesh/credentials.json}</li>\n")
            .add("    <li>macOS: {@code ~/Library/Application Support/mesh/credentials.json}</li>\n")
            .add("    <li>Windows: {@code %APPDATA%\\\\mesh\\\\credentials.json}</li>\n")
            .add("    </ul>\n")
            .add("</li>\n")
            .add("</ol>\n")
            .add("\n")
            .add("<p>For more information: <a href=\"https://meshtrade.github.io/api/docs/architecture/authentication\">Authentication Guide</a>\n")
            .add("\n")
            .add("<h2>Configuration</h2>\n")
            .add("<p>The client supports extensive configuration through {@link ServiceOptions}:\n")
            .add("<pre>{@code\n")
            .add("ServiceOptions options = ServiceOptions.builder()\n")
            .add("    .url(\"api.staging.meshtrade.co:443\")    // Custom API endpoint\n")
            .add("    .apiKey(\"your-api-key\")                // Direct API key\n")
            .add("    .group(\"groups/your-group-id\")         // Group context\n")
            .add("    .timeout(Duration.ofSeconds(30))        // Default timeout\n")
            .add("    .retryPolicy(RetryPolicy.exponential()) // Retry configuration\n")
            .add("    .build();\n")
            .add("\n")
            .add("try ($L client = new $L(options)) {\n", 
                serviceModel.getClientClassName(), serviceModel.getClientClassName())
            .add("    // Use configured client\n")
            .add("}\n")
            .add("}</pre>\n")
            .add("\n")
            .add("<p>For detailed configuration options: <a href=\"https://meshtrade.github.io/api/docs/architecture/sdk-configuration\">SDK Configuration Guide</a>\n")
            .add("\n")
            .add("<h2>Error Handling</h2>\n")
            .add("<p>All methods throw {@link io.grpc.StatusRuntimeException} for gRPC errors.\n")
            .add("The client provides automatic retry logic for transient failures:\n")
            .add("<pre>{@code\n")
            .add("try {\n")
            .add("    $L response = client.$L(request, Optional.empty());\n", 
                serviceModel.getMethods().isEmpty() ? "SomeResponse" : serviceModel.getMethods().get(0).getOutputTypeName(),
                serviceModel.getMethods().isEmpty() ? "someMethod" : serviceModel.getMethods().get(0).getJavaMethodName())
            .add("} catch (StatusRuntimeException e) {\n")
            .add("    switch (e.getStatus().getCode()) {\n")
            .add("        case UNAUTHENTICATED:\n")
            .add("            // Handle authentication errors\n")
            .add("            break;\n")
            .add("        case PERMISSION_DENIED:\n")
            .add("            // Handle authorization errors\n")
            .add("            break;\n")
            .add("        case UNAVAILABLE:\n")
            .add("            // Handle service unavailable (automatic retry may have failed)\n")
            .add("            break;\n")
            .add("        default:\n")
            .add("            // Handle other errors\n")
            .add("    }\n")
            .add("}\n")
            .add("}</pre>\n")
            .add("\n")
            .add("<h2>Thread Safety</h2>\n")
            .add("<p>This client is <strong>thread-safe</strong> and can be shared across multiple threads.\n")
            .add("However, it's recommended to use a single instance per application to benefit from\n")
            .add("connection pooling and optimal resource utilization.\n")
            .add("\n")
            .add("<h2>Resource Management</h2>\n")
            .add("<p>The client implements {@link AutoCloseable} and should be used with try-with-resources\n")
            .add("or manually closed to ensure proper cleanup of underlying gRPC channels:\n")
            .add("<pre>{@code\n")
            .add("// Recommended: try-with-resources\n")
            .add("try ($L client = new $L()) {\n", serviceModel.getClientClassName(), serviceModel.getClientClassName())
            .add("    // Use client\n")
            .add("}\n")
            .add("\n")
            .add("// Alternative: manual cleanup\n")
            .add("$L client = new $L();\n", serviceModel.getClientClassName(), serviceModel.getClientClassName())
            .add("try {\n")
            .add("    // Use client\n")
            .add("} finally {\n")
            .add("    client.close();\n")
            .add("}\n")
            .add("}</pre>\n")
            .add("\n")
            .add("@see $L\n", serviceModel.getServiceName())
            .add("@see co.meshtrade.api.grpc.BaseGRPCClient\n")
            .add("@see co.meshtrade.api.config.ServiceOptions\n")
            .add("@see <a href=\"$L\">Service Documentation</a>\n", serviceModel.getDocumentationUrl())
            .build();
    }
    
    /**
     * Generates the interface compliance check field.
     */
    private FieldSpec generateInterfaceComplianceField(ClassName serviceInterface, String clientClassName) {
        return FieldSpec.builder(serviceInterface, "_INTERFACE_COMPLIANCE_CHECK", 
                Modifier.PRIVATE, Modifier.STATIC, Modifier.FINAL)
            .initializer("($T) null", serviceInterface)
            .addJavadoc("Compile-time check that $L implements the $L interface.", 
                clientClassName, serviceInterface.simpleName())
            .build();
    }
    
    /**
     * Generates the default constructor with enhanced documentation.
     * 
     * @param serviceModel the service model
     * @return the constructor method spec
     */
    private MethodSpec generateDefaultConstructor(ServiceModel serviceModel) {
        return MethodSpec.constructorBuilder()
            .addModifiers(Modifier.PUBLIC)
            .addStatement("this($T.builder().build())", SERVICE_OPTIONS)
            .addJavadoc(CodeBlock.builder()
                .add("Creates and initializes the $L service.\n", serviceModel.getServiceName())
                .add("The service uses the common BaseGRPCClient for all functionality including\n")
                .add("connection management, authentication, and timeouts.\n")
                .add("\n")
                .add("Full Service documentation: $L\n", serviceModel.getDocumentationUrl())
                .add("\n")
                .add("With default configuration API credentials are searched for using the standard discovery hierarchy:\n")
                .add("\n")
                .add("1. MESH_API_CREDENTIALS environment variable\n")
                .add("\n")
                .add("2. Default credential file location:\n")
                .add("\n")
                .add("   - Linux:   $$XDG_CONFIG_HOME/mesh/credentials.json or fallback to $$HOME/.config/mesh/credentials.json\n")
                .add("   - macOS:   $$HOME/Library/Application Support/mesh/credentials.json\n")
                .add("   - Windows: C:\\\\Users\\\\<user>\\\\AppData\\\\Roaming\\\\mesh\\\\credentials.json\n")
                .add("\n")
                .add("For more information on authentication: <a href=\"https://meshtrade.github.io/api/docs/architecture/authentication\">Authentication Guide</a>\n")
                .add("\n")
                .add("For more information on service configuration: <a href=\"https://meshtrade.github.io/api/docs/architecture/sdk-configuration\">SDK Configuration Guide</a>\n")
                .add("\n")
                .add("<p><strong>Example:</strong>\n")
                .add("<pre>{@code\n")
                .add("// Create with default configuration\n")
                .add("$L service = new $L();\n", serviceModel.getServiceName() + "Interface", serviceModel.getServiceName())
                .add("try {\n")
                .add("    // Use the service\n")
                .add("    SomeResponse response = service.someMethod(request, Optional.empty());\n")
                .add("} finally {\n")
                .add("    service.close();\n")
                .add("}\n")
                .add("\n")
                .add("// Or use try-with-resources (recommended)\n")
                .add("try ($L service = new $L()) {\n", serviceModel.getServiceName() + "Interface", serviceModel.getServiceName())
                .add("    // Use the service\n")
                .add("    SomeResponse response = service.someMethod(request, Optional.empty());\n")
                .add("} // Automatic cleanup\n")
                .add("}</pre>\n")
                .add("\n")
                .add("@throws IllegalArgumentException if credentials cannot be discovered or are invalid\n")
                .add("@throws RuntimeException if the gRPC client cannot be initialized\n")
                .build())
            .build();
    }
    
    /**
     * Generates the constructor that takes ServiceOptions.
     * 
     * @param serviceModel the service model
     * @return the constructor method spec
     */
    private MethodSpec generateOptionsConstructor(ServiceModel serviceModel) {
        return MethodSpec.constructorBuilder()
            .addModifiers(Modifier.PUBLIC)
            .addParameter(SERVICE_OPTIONS, "options")
            .addStatement("super($S, $L, options)", 
                serviceModel.getServiceName(), serviceModel.getGrpcStubFactoryMethodRef())
            .addJavadoc(CodeBlock.builder()
                .add("Creates a new $L with custom configuration.\n", serviceModel.getClientClassName())
                .add("\n")
                .add("@param options the service configuration options\n")
                .add("@throws IllegalArgumentException if options are invalid\n")
                .add("@throws RuntimeException if the gRPC client cannot be initialized\n")
                .build())
            .build();
    }
    
    /**
     * Generates a method implementation for a unary gRPC method.
     * 
     * @param method the method model
     * @return the method specification
     */
    private MethodSpec generateUnaryMethodImplementation(MethodModel method) {
        // Create parameter types
        TypeName requestType = ClassName.bestGuess(method.getInputTypeName());
        TypeName responseType = ClassName.bestGuess(method.getOutputTypeName());
        ParameterizedTypeName optionalTimeout = ParameterizedTypeName.get(OPTIONAL, DURATION);
        
        return MethodSpec.methodBuilder(method.getJavaMethodName())
            .addModifiers(Modifier.PUBLIC)
            .addAnnotation(Override.class)
            .addParameter(requestType, "request")
            .addParameter(optionalTimeout, "timeout")
            .returns(responseType)
            .addStatement("return execute($S, request, timeout.orElse(null), " +
                         "(stub, req) -> stub.$L(req))", 
                         method.getMethodName(), method.getJavaMethodName())
            .addJavadoc(generateMethodImplementationJavadoc(method))
            .build();
    }
    
    /**
     * Generates JavaDoc for a method implementation.
     *
     * @param method the method model
     * @return the JavaDoc code block
     */
    private CodeBlock generateMethodImplementationJavadoc(MethodModel method) {
        return CodeBlock.builder()
            .add("{@inheritDoc}\n")
            .add("\n")
            .add("<p>This implementation uses the BaseGRPCClient infrastructure for\n")
            .add("authentication, timeout handling, and retry logic.\n")
            .build();
    }

    /**
     * Generates a method implementation for a server-side streaming gRPC method.
     *
     * @param method the method model
     * @return the method specification
     */
    private MethodSpec generateServerStreamingMethodImplementation(MethodModel method) {
        // Create parameter types
        TypeName requestType = ClassName.bestGuess(method.getInputTypeName());
        TypeName responseType = ClassName.bestGuess(method.getOutputTypeName());
        ParameterizedTypeName optionalTimeout = ParameterizedTypeName.get(OPTIONAL, DURATION);

        // Return Iterator<ResponseType> for server-side streaming
        ParameterizedTypeName returnType = ParameterizedTypeName.get(
            ClassName.get(java.util.Iterator.class),
            responseType
        );

        return MethodSpec.methodBuilder(method.getJavaMethodName())
            .addModifiers(Modifier.PUBLIC)
            .addAnnotation(Override.class)
            .addParameter(requestType, "request")
            .addParameter(optionalTimeout, "timeout")
            .returns(returnType)
            .addStatement("return executeStream($S, request, timeout.orElse(null), (stub, req) -> stub.$L(req))",
                         method.getJavaMethodName(), method.getJavaMethodName())
            .addJavadoc(generateStreamingMethodJavadoc(method))
            .build();
    }

    /**
     * Generates JavaDoc for a server-side streaming method implementation.
     *
     * @param method the method model
     * @return the JavaDoc code block
     */
    private CodeBlock generateStreamingMethodJavadoc(MethodModel method) {
        return CodeBlock.builder()
            .add("{@inheritDoc}\n")
            .add("\n")
            .add("<p>This is a server-side streaming method that returns an iterator of responses.\n")
            .add("The iterator should be fully consumed or the connection may leak resources.\n")
            .add("\n")
            .add("<p>Example usage:\n")
            .add("<pre>{@code\n")
            .add("Iterator<$L> stream = client.$L(request, Optional.empty());\n",
                method.getOutputTypeName(), method.getJavaMethodName())
            .add("while (stream.hasNext()) {\n")
            .add("    $L response = stream.next();\n", method.getOutputTypeName())
            .add("    // Process response\n")
            .add("}\n")
            .add("}</pre>\n")
            .build();
    }

    /**
     * Generates the withGroup method implementation for the client class.
     *
     * <p>This method creates a new client instance with the same configuration
     * but a different group context, matching the Go generator pattern.
     *
     * @param serviceModel the service model
     * @return the method specification for withGroup implementation
     */
    private MethodSpec generateWithGroupMethodImplementation(ServiceModel serviceModel) {
        ClassName interfaceType = ClassName.get(serviceModel.getJavaPackage(),
                                                serviceModel.getServiceName() + "Interface");

        return MethodSpec.methodBuilder("withGroup")
            .addModifiers(Modifier.PUBLIC)
            .addAnnotation(Override.class)
            .addParameter(String.class, "group")
            .returns(interfaceType)
            .addStatement("$T newOptions = super.createOptionsWithGroup(group)", SERVICE_OPTIONS)
            .addStatement("return new $L(newOptions)", serviceModel.getClientClassName())
            .addJavadoc(CodeBlock.builder()
                .add("{@inheritDoc}\n")
                .add("\n")
                .add("<p>Example usage:\n")
                .add("<pre>{@code\n")
                .add("// Create initial client with default group from credentials\n")
                .add("$L service = new $L();\n",
                    serviceModel.getServiceName() + "Interface", serviceModel.getClientClassName())
                .add("try {\n")
                .add("    // Use original client for operations in default group\n")
                .add("    // ...\n")
                .add("    \n")
                .add("    // Switch to different group context for operations in another group\n")
                .add("    $L altService = service.withGroup(\"groups/01ARZ3NDEKTSV4RRFFQ69G5FAV\");\n",
                    serviceModel.getServiceName() + "Interface")
                .add("    try {\n")
                .add("        // Use alternative group client for operations in that group\n")
                .add("        // ...\n")
                .add("    } finally {\n")
                .add("        altService.close();\n")
                .add("    }\n")
                .add("} finally {\n")
                .add("    service.close();\n")
                .add("}\n")
                .add("}</pre>\n")
                .build())
            .build();
    }
}