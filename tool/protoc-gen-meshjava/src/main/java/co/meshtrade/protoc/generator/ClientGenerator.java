package co.meshtrade.protoc.generator;

import com.squareup.javapoet.*;
import co.meshtrade.protoc.model.MethodModel;
import co.meshtrade.protoc.model.ServiceModel;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javax.lang.model.element.Modifier;
import java.time.Duration;
import java.util.Optional;
import java.util.Set;
import java.util.HashSet;

/**
 * Generates Java gRPC client implementations from protobuf service definitions.
 * 
 * <p>This generator creates client classes that extend BaseGRPCClient and implement
 * the corresponding service interface. The generated clients provide complete
 * gRPC functionality including authentication, timeouts, retry logic, and
 * proper resource management.
 */
public class ClientGenerator {
    private static final Logger logger = LoggerFactory.getLogger(ClientGenerator.class);
    
    // Common class names used in generated code
    private static final ClassName BASE_GRPC_CLIENT = ClassName.get("co.meshtrade.api.grpc", "BaseGRPCClient");
    private static final ClassName SERVICE_OPTIONS = ClassName.get("co.meshtrade.api.config", "ServiceOptions");
    private static final ClassName DURATION = ClassName.get(Duration.class);
    private static final ClassName OPTIONAL = ClassName.get(Optional.class);
    
    /**
     * Generates a Java gRPC client implementation from a service model.
     * 
     * @param serviceModel the service model containing all necessary information
     * @return the generated Java source code as a string
     * @throws RuntimeException if code generation fails
     */
    public String generate(ServiceModel serviceModel) {
        logger.debug("Generating client for service: {}", serviceModel.getServiceName());
        
        try {
            // Collect all required imports
            Set<String> requiredImports = new HashSet<>();
            for (MethodModel method : serviceModel.getMethods()) {
                if (method.isUnary()) {
                    requiredImports.add(method.getInputTypeQualifiedName());
                    requiredImports.add(method.getOutputTypeQualifiedName());
                }
            }
            
            // Determine the gRPC stub class name
            ClassName stubClass = ClassName.bestGuess(serviceModel.getGrpcStubClassName());
            ClassName serviceInterface = ClassName.get(serviceModel.getJavaPackage(), serviceModel.getServiceName());
            
            // Create the client class
            TypeSpec.Builder clientBuilder = TypeSpec.classBuilder(serviceModel.getClientClassName())
                .addModifiers(Modifier.PUBLIC, Modifier.FINAL)
                .superclass(ParameterizedTypeName.get(BASE_GRPC_CLIENT, stubClass))
                .addSuperinterface(serviceInterface)
                .addJavadoc(generateClientJavadoc(serviceModel));
            
            // Add constructors
            clientBuilder.addMethod(generateDefaultConstructor(serviceModel));
            clientBuilder.addMethod(generateOptionsConstructor(serviceModel));
            
            // Add method implementations
            for (MethodModel method : serviceModel.getMethods()) {
                if (method.isUnary()) {
                    clientBuilder.addMethod(generateUnaryMethodImplementation(method));
                } else {
                    logger.warn("Skipping streaming method {} - not yet supported", method.getMethodName());
                }
            }
            
            // Build the complete Java file
            JavaFile javaFile = JavaFile.builder(serviceModel.getJavaPackage(), clientBuilder.build())
                .addFileComment("Generated by protoc-gen-meshjava. DO NOT EDIT.")
                .addFileComment("source: $L", serviceModel.getProtoFileName())
                .build();
            
            // Add manual imports for protobuf classes
            String javaFileString = javaFile.toString();
            StringBuilder imports = new StringBuilder();
            for (String importClass : requiredImports) {
                imports.append("import ").append(importClass).append(";\n");
            }
            
            // Insert imports after package declaration
            String packageLine = "package " + serviceModel.getJavaPackage() + ";";
            javaFileString = javaFileString.replace(packageLine, packageLine + "\n\n" + imports.toString());
            
            return javaFileString;
            
        } catch (Exception e) {
            String errorMsg = String.format("Failed to generate client for service %s", 
                serviceModel.getServiceName());
            logger.error(errorMsg, e);
            throw new RuntimeException(errorMsg, e);
        }
    }
    
    /**
     * Generates JavaDoc for the client class.
     * 
     * @param serviceModel the service model
     * @return the JavaDoc code block
     */
    private CodeBlock generateClientJavadoc(ServiceModel serviceModel) {
        return CodeBlock.builder()
            .add("$L gRPC client with authentication, timeouts, and resource management.\n", 
                serviceModel.getServiceName())
            .add("\n")
            .add("<p>This client provides a complete implementation of the $L service with proper\n", 
                serviceModel.getServiceName())
            .add("authentication, timeout handling, and automatic resource cleanup. It extends\n")
            .add("{@link co.meshtrade.api.grpc.BaseGRPCClient} for common gRPC functionality.\n")
            .add("\n")
            .add("<h2>Authentication</h2>\n")
            .add("<p>The client uses automatic credential discovery with the following hierarchy:\n")
            .add("<ol>\n")
            .add("<li>MESH_API_CREDENTIALS environment variable</li>\n")
            .add("<li>Platform-specific credential files:\n")
            .add("    <ul>\n")
            .add("    <li>Linux: {@code ~/.config/mesh/credentials.json}</li>\n")
            .add("    <li>macOS: {@code ~/Library/Application Support/mesh/credentials.json}</li>\n")
            .add("    <li>Windows: {@code %APPDATA%\\mesh\\credentials.json}</li>\n")
            .add("    </ul>\n")
            .add("</li>\n")
            .add("</ol>\n")
            .add("\n")
            .add("<h2>Example Usage</h2>\n")
            .add("<pre>{@code\n")
            .add("// Using default configuration (auto-discovers credentials)\n")
            .add("try ($L client = new $L()) {\n", serviceModel.getClientClassName(), serviceModel.getClientClassName())
            .add("    $L request = $L.newBuilder()\n", 
                serviceModel.getMethods().isEmpty() ? "SomeRequest" : serviceModel.getMethods().get(0).getInputTypeName(),
                serviceModel.getMethods().isEmpty() ? "SomeRequest" : serviceModel.getMethods().get(0).getInputTypeName())
            .add("        .build();\n")
            .add("    $L response = client.$L(request, Optional.empty());\n", 
                serviceModel.getMethods().isEmpty() ? "SomeResponse" : serviceModel.getMethods().get(0).getOutputTypeName(),
                serviceModel.getMethods().isEmpty() ? "someMethod" : serviceModel.getMethods().get(0).getJavaMethodName())
            .add("}\n")
            .add("\n")
            .add("// Using custom configuration\n")
            .add("ServiceOptions options = ServiceOptions.builder()\n")
            .add("    .url(\"api.staging.mesh.dev\")\n")
            .add("    .apiKey(\"your-api-key\")\n")
            .add("    .group(\"groups/your-group-id\")\n")
            .add("    .build();\n")
            .add("\n")
            .add("try ($L client = new $L(options)) {\n", 
                serviceModel.getClientClassName(), serviceModel.getClientClassName())
            .add("    // Use configured client\n")
            .add("}\n")
            .add("}</pre>\n")
            .add("\n")
            .add("@see <a href=\"$L\">Service Documentation</a>\n", serviceModel.getDocumentationUrl())
            .add("@see $L\n", serviceModel.getServiceName())
            .add("@see co.meshtrade.api.grpc.BaseGRPCClient\n")
            .build();
    }
    
    /**
     * Generates the default constructor (no arguments).
     * 
     * @param serviceModel the service model
     * @return the constructor method spec
     */
    private MethodSpec generateDefaultConstructor(ServiceModel serviceModel) {
        return MethodSpec.constructorBuilder()
            .addModifiers(Modifier.PUBLIC)
            .addStatement("this($T.builder().build())", SERVICE_OPTIONS)
            .addJavadoc(CodeBlock.builder()
                .add("Creates a new $L with default configuration.\n", serviceModel.getClientClassName())
                .add("\n")
                .add("<p>Uses automatic credential discovery and default connection settings.\n")
                .add("API credentials are discovered using the standard hierarchy.\n")
                .add("\n")
                .add("@throws IllegalArgumentException if credentials cannot be discovered\n")
                .add("@throws RuntimeException if the gRPC client cannot be initialized\n")
                .build())
            .build();
    }
    
    /**
     * Generates the constructor that takes ServiceOptions.
     * 
     * @param serviceModel the service model
     * @return the constructor method spec
     */
    private MethodSpec generateOptionsConstructor(ServiceModel serviceModel) {
        return MethodSpec.constructorBuilder()
            .addModifiers(Modifier.PUBLIC)
            .addParameter(SERVICE_OPTIONS, "options")
            .addStatement("super($S, $L::new, options)", 
                serviceModel.getServiceName(), serviceModel.getGrpcStubClassName())
            .addJavadoc(CodeBlock.builder()
                .add("Creates a new $L with custom configuration.\n", serviceModel.getClientClassName())
                .add("\n")
                .add("@param options the service configuration options\n")
                .add("@throws IllegalArgumentException if options are invalid\n")
                .add("@throws RuntimeException if the gRPC client cannot be initialized\n")
                .build())
            .build();
    }
    
    /**
     * Generates a method implementation for a unary gRPC method.
     * 
     * @param method the method model
     * @return the method specification
     */
    private MethodSpec generateUnaryMethodImplementation(MethodModel method) {
        // Create parameter types
        TypeName requestType = ClassName.bestGuess(method.getInputTypeName());
        TypeName responseType = ClassName.bestGuess(method.getOutputTypeName());
        ParameterizedTypeName optionalTimeout = ParameterizedTypeName.get(OPTIONAL, DURATION);
        
        return MethodSpec.methodBuilder(method.getJavaMethodName())
            .addModifiers(Modifier.PUBLIC)
            .addAnnotation(Override.class)
            .addParameter(requestType, "request")
            .addParameter(optionalTimeout, "timeout")
            .returns(responseType)
            .addStatement("return execute($S, request, timeout.orElse(null), " +
                         "(stub, req) -> stub.$L(req))", 
                         method.getMethodName(), method.getJavaMethodName())
            .addJavadoc(generateMethodImplementationJavadoc(method))
            .build();
    }
    
    /**
     * Generates JavaDoc for a method implementation.
     * 
     * @param method the method model
     * @return the JavaDoc code block
     */
    private CodeBlock generateMethodImplementationJavadoc(MethodModel method) {
        return CodeBlock.builder()
            .add("{@inheritDoc}\n")
            .add("\n")
            .add("<p>This implementation uses the BaseGRPCClient infrastructure for\n")
            .add("authentication, timeout handling, and retry logic.\n")
            .build();
    }
}