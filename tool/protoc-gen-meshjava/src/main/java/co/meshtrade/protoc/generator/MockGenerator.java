package co.meshtrade.protoc.generator;

import com.squareup.javapoet.*;
import co.meshtrade.protoc.model.MethodModel;
import co.meshtrade.protoc.model.ServiceModel;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javax.lang.model.element.Modifier;
import java.util.Set;
import java.util.HashSet;
import java.util.concurrent.locks.ReentrantLock;
import java.util.function.BiFunction;

/**
 * Generates Java mock implementations from protobuf service definitions.
 * 
 * <p>This generator creates thread-safe mock classes that implement the service
 * interface and provide test-friendly functionality including method invocation
 * tracking, customizable behavior via function suppliers, and integration with
 * testing frameworks.
 * 
 * <p>The generated mocks are designed for unit testing and provide:
 * <ul>
 * <li>Thread-safe invocation counting</li>
 * <li>Customizable method behavior via function interfaces</li>
 * <li>Automatic interface compliance checking</li>
 * <li>Integration with JUnit and other testing frameworks</li>
 * </ul>
 */
public class MockGenerator {
    private static final Logger logger = LoggerFactory.getLogger(MockGenerator.class);
    
    // Common class names used in generated code
    private static final ClassName REENTRANT_LOCK = ClassName.get(ReentrantLock.class);
    private static final ClassName BI_FUNCTION = ClassName.get(BiFunction.class);
    
    /**
     * Generates a Java mock implementation from a service model.
     * 
     * @param serviceModel the service model containing all necessary information
     * @return the generated Java source code as a string
     * @throws RuntimeException if code generation fails
     */
    public String generate(ServiceModel serviceModel) {
        logger.debug("Generating mock for service: {}", serviceModel.getServiceName());
        
        try {
            // Collect all required imports
            Set<String> requiredImports = new HashSet<>();
            for (MethodModel method : serviceModel.getMethods()) {
                if (method.isUnary()) {
                    requiredImports.add(method.getInputTypeQualifiedName());
                    requiredImports.add(method.getOutputTypeQualifiedName());
                }
            }
            
            ClassName serviceInterface = ClassName.get(serviceModel.getJavaPackage(), serviceModel.getServiceName());
            String mockClassName = "Mock" + serviceModel.getServiceName();
            
            // Create the mock class
            TypeSpec.Builder mockBuilder = TypeSpec.classBuilder(mockClassName)
                .addModifiers(Modifier.PUBLIC, Modifier.FINAL)
                .addSuperinterface(serviceInterface)
                .addJavadoc(generateMockJavadoc(serviceModel, mockClassName));
            
            // Add static interface compliance check
            mockBuilder.addField(generateInterfaceComplianceField(serviceInterface, mockClassName));
            
            // Add lock field for thread safety
            mockBuilder.addField(FieldSpec.builder(REENTRANT_LOCK, "lock", Modifier.PRIVATE, Modifier.FINAL)
                .initializer("new $T()", REENTRANT_LOCK)
                .addJavadoc("Lock for thread-safe access to invocation counters and function fields.")
                .build());
            
            // Add method function fields and counters
            for (MethodModel method : serviceModel.getMethods()) {
                if (method.isUnary()) {
                    mockBuilder.addField(generateMethodFunctionField(method));
                    mockBuilder.addField(generateInvocationCounterField(method));
                }
            }
            
            // Add constructor
            mockBuilder.addMethod(generateConstructor(mockClassName));
            
            // Add method implementations
            for (MethodModel method : serviceModel.getMethods()) {
                if (method.isUnary()) {
                    mockBuilder.addMethod(generateMockMethodImplementation(method, mockClassName));
                } else {
                    logger.warn("Skipping streaming method {} - not yet supported in mocks", method.getMethodName());
                }
            }
            
            // Add utility methods
            mockBuilder.addMethod(generateGetInvocationCountMethod(serviceModel, mockClassName));
            mockBuilder.addMethod(generateResetMethod(serviceModel, mockClassName));
            mockBuilder.addMethod(generateCloseMethod());
            
            // Build the complete Java file
            JavaFile javaFile = JavaFile.builder(serviceModel.getJavaPackage(), mockBuilder.build())
                .addFileComment("Generated by protoc-gen-meshjava. DO NOT EDIT.")
                .addFileComment("source: $L", serviceModel.getProtoFileName())
                .build();
            
            // Add manual imports for protobuf classes
            String javaFileString = javaFile.toString();
            StringBuilder imports = new StringBuilder();
            for (String importClass : requiredImports) {
                imports.append("import ").append(importClass).append(";\n");
            }
            
            // Insert imports after package declaration
            String packageLine = "package " + serviceModel.getJavaPackage() + ";";
            javaFileString = javaFileString.replace(packageLine, packageLine + "\n\n" + imports.toString());
            
            return javaFileString;
            
        } catch (Exception e) {
            String errorMsg = String.format("Failed to generate mock for service %s", 
                serviceModel.getServiceName());
            logger.error(errorMsg, e);
            throw new RuntimeException(errorMsg, e);
        }
    }
    
    /**
     * Generates JavaDoc for the mock class.
     */
    private CodeBlock generateMockJavadoc(ServiceModel serviceModel, String mockClassName) {
        return CodeBlock.builder()
            .add("Thread-safe mock implementation of the $L interface.\n", serviceModel.getServiceName())
            .add("\n")
            .add("<p>This mock provides test-friendly functionality including:\n")
            .add("<ul>\n")
            .add("<li>Thread-safe invocation counting for all methods</li>\n")
            .add("<li>Customizable method behavior via function suppliers</li>\n")
            .add("<li>Automatic resource cleanup</li>\n")
            .add("<li>Integration with JUnit and other testing frameworks</li>\n")
            .add("</ul>\n")
            .add("\n")
            .add("<h2>Example Usage</h2>\n")
            .add("<pre>{@code\n")
            .add("$L mock = new $L();\n", mockClassName, mockClassName)
            .add("\n")
            .add("// Set up method behavior\n")
            .add("mock.set$LFunction((request, timeout) -> {\n", 
                serviceModel.getMethods().isEmpty() ? "SomeMethod" : 
                serviceModel.getMethods().get(0).getMethodName())
            .add("    // Custom logic here\n")
            .add("    return $L.newBuilder().build();\n", 
                serviceModel.getMethods().isEmpty() ? "SomeResponse" : 
                serviceModel.getMethods().get(0).getOutputTypeName())
            .add("});\n")
            .add("\n")
            .add("// Use in tests\n")
            .add("$L request = $L.newBuilder().build();\n", 
                serviceModel.getMethods().isEmpty() ? "SomeRequest" : serviceModel.getMethods().get(0).getInputTypeName(),
                serviceModel.getMethods().isEmpty() ? "SomeRequest" : serviceModel.getMethods().get(0).getInputTypeName())
            .add("$L response = mock.$L(request, Optional.empty());\n", 
                serviceModel.getMethods().isEmpty() ? "SomeResponse" : serviceModel.getMethods().get(0).getOutputTypeName(),
                serviceModel.getMethods().isEmpty() ? "someMethod" : serviceModel.getMethods().get(0).getJavaMethodName())
            .add("\n")
            .add("// Verify invocations\n")
            .add("assertEquals(1, mock.getInvocationCount(\"$L\"));\n", 
                serviceModel.getMethods().isEmpty() ? "SomeMethod" : serviceModel.getMethods().get(0).getMethodName())
            .add("}</pre>\n")
            .add("\n")
            .add("@see $L\n", serviceModel.getServiceName())
            .build();
    }
    
    /**
     * Generates the static interface compliance check field.
     */
    private FieldSpec generateInterfaceComplianceField(ClassName serviceInterface, String mockClassName) {
        return FieldSpec.builder(serviceInterface, "_INTERFACE_COMPLIANCE_CHECK", 
                Modifier.PRIVATE, Modifier.STATIC, Modifier.FINAL)
            .initializer("new $L()", mockClassName)
            .addJavadoc("Compile-time check that $L implements the $L interface.", 
                mockClassName, serviceInterface.simpleName())
            .build();
    }
    
    /**
     * Generates a function field for a method.
     */
    private FieldSpec generateMethodFunctionField(MethodModel method) {
        TypeName requestType = ClassName.bestGuess(method.getInputTypeName());
        TypeName responseType = ClassName.bestGuess(method.getOutputTypeName());
        
        // Create BiFunction<RequestType, Optional<Duration>, ResponseType>
        ParameterizedTypeName functionType = ParameterizedTypeName.get(
            BI_FUNCTION,
            requestType,
            responseType
        );
        
        return FieldSpec.builder(functionType, method.getJavaMethodName() + "Function", Modifier.PRIVATE, Modifier.VOLATILE)
            .addJavadoc("Function to execute when $L is called. If null, returns null.", method.getJavaMethodName())
            .build();
    }
    
    /**
     * Generates an invocation counter field for a method.
     */
    private FieldSpec generateInvocationCounterField(MethodModel method) {
        return FieldSpec.builder(int.class, method.getJavaMethodName() + "Invocations", Modifier.PRIVATE, Modifier.VOLATILE)
            .initializer("0")
            .addJavadoc("Number of times $L has been invoked.", method.getJavaMethodName())
            .build();
    }
    
    /**
     * Generates the default constructor.
     */
    private MethodSpec generateConstructor(String mockClassName) {
        return MethodSpec.constructorBuilder()
            .addModifiers(Modifier.PUBLIC)
            .addJavadoc(CodeBlock.builder()
                .add("Creates a new $L with default behavior.\n", mockClassName)
                .add("\n")
                .add("<p>All methods will return null unless custom functions are set.\n")
                .build())
            .build();
    }
    
    /**
     * Generates a mock method implementation.
     */
    private MethodSpec generateMockMethodImplementation(MethodModel method, String mockClassName) {
        TypeName requestType = ClassName.bestGuess(method.getInputTypeName());
        TypeName responseType = ClassName.bestGuess(method.getOutputTypeName());
        
        return MethodSpec.methodBuilder(method.getJavaMethodName())
            .addModifiers(Modifier.PUBLIC)
            .addAnnotation(Override.class)
            .addParameter(requestType, "request")
            .addParameter(ParameterizedTypeName.get(ClassName.get("java.util", "Optional"), 
                ClassName.get("java.time", "Duration")), "timeout")
            .returns(responseType)
            .addStatement("lock.lock()")
            .beginControlFlow("try")
            .addStatement("$L++", method.getJavaMethodName() + "Invocations")
            .nextControlFlow("finally")
            .addStatement("lock.unlock()")
            .endControlFlow()
            .addStatement("$T function = $L", 
                ParameterizedTypeName.get(BI_FUNCTION, requestType, responseType),
                method.getJavaMethodName() + "Function")
            .addStatement("return function != null ? function.apply(request, null) : null")
            .addJavadoc(generateMockMethodJavadoc(method))
            .build();
    }
    
    /**
     * Generates JavaDoc for a mock method implementation.
     */
    private CodeBlock generateMockMethodJavadoc(MethodModel method) {
        return CodeBlock.builder()
            .add("{@inheritDoc}\n")
            .add("\n")
            .add("<p>This mock implementation:\n")
            .add("<ul>\n")
            .add("<li>Increments the invocation counter for $L</li>\n", method.getJavaMethodName())
            .add("<li>Executes the custom function if set, otherwise returns null</li>\n")
            .add("<li>Is thread-safe for concurrent testing</li>\n")
            .add("</ul>\n")
            .build();
    }
    
    /**
     * Generates the getInvocationCount utility method.
     */
    private MethodSpec generateGetInvocationCountMethod(ServiceModel serviceModel, String mockClassName) {
        MethodSpec.Builder methodBuilder = MethodSpec.methodBuilder("getInvocationCount")
            .addModifiers(Modifier.PUBLIC)
            .addParameter(String.class, "methodName")
            .returns(int.class)
            .addStatement("lock.lock()")
            .beginControlFlow("try")
            .beginControlFlow("switch (methodName)");
        
        // Add cases for each method
        for (MethodModel method : serviceModel.getMethods()) {
            if (method.isUnary()) {
                methodBuilder.addStatement("case $S: return $L", 
                    method.getMethodName(), method.getJavaMethodName() + "Invocations");
            }
        }
        
        methodBuilder.addStatement("default: throw new $T($S + methodName)", 
                IllegalArgumentException.class, "Unknown method: ")
            .endControlFlow()
            .nextControlFlow("finally")
            .addStatement("lock.unlock()")
            .endControlFlow()
            .addJavadoc(CodeBlock.builder()
                .add("Returns the number of times a method has been invoked.\n")
                .add("\n")
                .add("@param methodName the name of the method to check\n")
                .add("@return the invocation count\n")
                .add("@throws IllegalArgumentException if the method name is unknown\n")
                .build());
        
        return methodBuilder.build();
    }
    
    /**
     * Generates the reset utility method.
     */
    private MethodSpec generateResetMethod(ServiceModel serviceModel, String mockClassName) {
        MethodSpec.Builder methodBuilder = MethodSpec.methodBuilder("reset")
            .addModifiers(Modifier.PUBLIC)
            .addStatement("lock.lock()")
            .beginControlFlow("try");
        
        // Reset all counters and functions
        for (MethodModel method : serviceModel.getMethods()) {
            if (method.isUnary()) {
                methodBuilder.addStatement("$L = 0", method.getJavaMethodName() + "Invocations");
                methodBuilder.addStatement("$L = null", method.getJavaMethodName() + "Function");
            }
        }
        
        methodBuilder.nextControlFlow("finally")
            .addStatement("lock.unlock()")
            .endControlFlow()
            .addJavadoc(CodeBlock.builder()
                .add("Resets all invocation counters and clears all custom functions.\n")
                .add("\n")
                .add("<p>This method is useful for reusing the same mock instance across multiple tests.\n")
                .build());
        
        return methodBuilder.build();
    }
    
    /**
     * Generates the close method implementation.
     */
    private MethodSpec generateCloseMethod() {
        return MethodSpec.methodBuilder("close")
            .addModifiers(Modifier.PUBLIC)
            .addAnnotation(Override.class)
            .beginControlFlow("try")
            .addStatement("// Mock doesn't need cleanup, but reset for good measure")
            .addStatement("reset()")
            .endControlFlow("catch ($T e)", Exception.class)
            .addStatement("// Ignore cleanup errors in mocks")
            .endControlFlow()
            .addJavadoc(CodeBlock.builder()
                .add("{@inheritDoc}\n")
                .add("\n")
                .add("<p>For mocks, this method resets the state but doesn't perform\n")
                .add("any actual resource cleanup.\n")
                .build())
            .build();
    }
}