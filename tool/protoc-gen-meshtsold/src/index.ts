import { DescFile, DescService, DescMethod } from "@bufbuild/protobuf";
import {
  createEcmaScriptPlugin,
  ImportSymbol,
  runNodeJs,
  type Schema,
} from "@bufbuild/protoplugin";
import * as fs from "fs";
import * as path from "path";

const plugin = createEcmaScriptPlugin({
  name: "protoc-gen-meshts",
  version: "v1",
  generateTs(schema: Schema) {
    // Loop through all Protobuf files in the schema to look for service definitions
    for (const file of schema.files) {
      if (file.services.length > 0) {
        // Generate a TypeScript gRPC-web client for each file with services
        generateGrpcWebClientManually(schema, file);
      }
    }
  },
});

// Reads the schema from stdin, runs the plugin, and writes the generated files to stdout.
runNodeJs(plugin);

function generateGrpcWebClientManually(schema: Schema, file: DescFile) {
  // Build the TypeScript content manually as a string
  let content = "";
  
  // Add file header
  content += `// @generated by protoc-gen-meshts v1\n`;
  content += `// @generated from file ${file.name}.proto (package ${file.proto.package}, syntax proto3)\n`;
  content += `/* eslint-disable */\n`;
  content += `\n`;

  // Generate imports
  content += `import { LoggingInterceptor } from "../../../common/grpc_web";\n`;
  
  // Import the generated gRPC-web service client
  for (const service of file.services) {
    const serviceClientName = `${service.name}PromiseClient`;
    content += `import { ${serviceClientName} } from "./service_grpc_web_pb";\n`;
  }
  
  // Import request/response types
  // Separate types defined in service_pb from those in other files
  const serviceTypes = new Set<string>();
  const externalTypes = new Set<string>();
  
  for (const service of file.services) {
    for (const method of service.methods) {
      // Request types are typically defined in service.proto
      if (method.input.file === file) {
        serviceTypes.add(method.input.name);
      } else {
        externalTypes.add(method.input.name);
      }
      
      // Response types may be defined in different files
      if (method.output.file === file) {
        serviceTypes.add(method.output.name);
      } else {
        externalTypes.add(method.output.name);
      }
    }
  }
  
  // Import types from service_pb (request/response messages defined in the service file)
  if (serviceTypes.size > 0) {
    const sortedServiceTypes = Array.from(serviceTypes).sort();
    content += `import {\n`;
    for (let i = 0; i < sortedServiceTypes.length; i++) {
      content += `  ${sortedServiceTypes[i]}${i < sortedServiceTypes.length - 1 ? ',' : ''}\n`;
    }
    content += `} from "./service_pb";\n`;
  }
  
  // Import types from their respective files (e.g., APIUser from api_user_pb)
  if (externalTypes.size > 0) {
    const sortedExternalTypes = Array.from(externalTypes).sort();
    for (const typeName of sortedExternalTypes) {
      // Generate import based on the file naming pattern
      // Convert "APIUser" -> "api_user_pb"
      const importPath = `./${convertToSnakeCase(typeName)}_pb`;
      content += `import { ${typeName} } from "${importPath}";\n`;
    }
  }
  
  content += `import { UnaryInterceptor } from "grpc-web";\n`;
  content += `import * as grpcWeb from "grpc-web";\n`;
  content += `import { ConfigOpts, getConfigFromOpts } from "../../../common/config";\n`;
  content += `import { GroupHeaderInterceptor } from "../../../common/groupHeaderInterceptor";\n`;
  content += `import { validateRequest } from "../../../common/validation";\n`;
  content += `\n`;
  
  // Generate client class for each service
  for (const service of file.services) {
    content += generateServiceClientString(service, file);
  }

  // Write the content manually using Node.js file system operations
  // Construct the output file path based on the protobuf file structure
  const outputFilePath = getOutputFilePath(file);
  
  // Write the TypeScript content to the file
  writeTypescriptFile(outputFilePath, content);
}

function getOutputFilePath(file: DescFile): string {
  // Convert protobuf file path to TypeScript output path
  // Example: "meshtrade/iam/api_user/v1/service.proto" -> "ts-old/src/meshtrade/iam/api_user/v1/service_grpc_web_client_meshts.ts"
  const protoPath = file.name; // e.g., "meshtrade/iam/api_user/v1/service"
  const outputDir = path.join("ts-old", "src", path.dirname(protoPath));
  const fileName = path.basename(protoPath) + "_grpc_web_client_meshts.ts";
  return path.join(outputDir, fileName);
}

function writeTypescriptFile(filePath: string, content: string): void {
  try {
    // Ensure the directory exists
    const dir = path.dirname(filePath);
    fs.mkdirSync(dir, { recursive: true });
    
    // Write the TypeScript content to the file
    fs.writeFileSync(filePath, content, 'utf8');
    
    console.error(`Generated TypeScript client: ${filePath}`);
  } catch (error) {
    console.error(`Failed to write TypeScript file: ${filePath}`, error);
    throw error;
  }
}

function generateServiceClientString(service: DescService, file: DescFile): string {
  const serviceName = service.name;
  const clientClassName = `${serviceName}GrpcWebClientV1`;
  const serviceClientName = `${serviceName}PromiseClient`;
  
  // Extract resource name from the service (e.g., ApiUser from ApiUserService)
  const resourceName = serviceName.replace(/Service$/, '');
  
  let content = "";
  
  // Generate class JSDoc
  content += "/**\n";
  content += ` * Client for interacting with the ${file.proto.package} ${toReadableResourceName(resourceName)} v1 API resource service.\n`;
  content += " */\n";
  
  // Generate class declaration
  content += `export class ${clientClassName} {\n`;
  content += `  private _service: ${serviceClientName};\n`;
  content += `  private readonly _config: ReturnType<typeof getConfigFromOpts>;\n`;
  content += `  private readonly _interceptors: UnaryInterceptor<any, any>[];\n`;
  content += "\n";
  
  // Generate constructor
  content += "  /**\n";
  content += `   * Constructs an instance of ${clientClassName}.\n`;
  content += "   * @param {ConfigOpts} [config] - Optional configuration for the client.\n";
  content += "   * @param {UnaryInterceptor<any, any>[]} [interceptors] - For internal use by `withGroup`.\n";
  content += "   */\n";
  content += "  constructor(config?: ConfigOpts, interceptors?: UnaryInterceptor<any, any>[]) {\n";
  content += "    this._config = getConfigFromOpts(config);\n";
  content += "    this._interceptors = interceptors || [new LoggingInterceptor()];\n";
  content += "\n";
  content += "    // Construct the underlying gRPC-web service client\n";
  content += `    this._service = new ${serviceClientName}(\n`;
  content += "      this._config.apiServerURL,\n";
  content += "      null,\n";
  content += "      {\n";
  content += "        withCredentials: true,\n";
  content += "        unaryInterceptors: this._interceptors,\n";
  content += "      }\n";
  content += "    );\n";
  content += "  }\n";
  content += "\n";
  
  // Generate withGroup method
  content += "  /**\n";
  content += "   * Returns a new client instance configured to send the specified group\n";
  content += "   * resource name in the request headers for subsequent API calls.\n";
  content += "   * \n";
  content += "   * @param {string} group - The operating group context to inject into the request\n";
  content += "   *                         in the format `groups/{ulid}` where {ulid} is a 26-character ULID.\n";
  content += "   *                         Example: 'groups/01ARZ3NDEKTSV4YWVF8F5BH32'\n";
  content += `   * @returns {${clientClassName}} A new, configured instance of the client.\n`;
  content += "   * @throws {Error} If the group format is invalid (validation occurs in GroupHeaderInterceptor)\n";
  content += "   */\n";
  content += `  withGroup(group: string): ${clientClassName} {\n`;
  content += "    // Check if a GroupHeaderInterceptor already exists.\n";
  content += "    const hasGroupInterceptor = this._interceptors.some(\n";
  content += "      (interceptor) => interceptor instanceof GroupHeaderInterceptor\n";
  content += "    );\n";
  content += "\n";
  content += "    if (hasGroupInterceptor) {\n";
  content += "      throw new Error(\n";
  content += '        "Attempted to set group context twice. A group has already been set for this client instance."\n';
  content += "      );\n";
  content += "    }\n";
  content += "\n";
  content += "    // Create a new interceptor for the group context\n";
  content += "    const groupInterceptor = new GroupHeaderInterceptor(group);\n";
  content += "\n";
  content += "    // Return a new client instance with the existing interceptors plus the new one\n";
  content += `    return new ${clientClassName}(\n`;
  content += "      this._config,\n";
  content += "      [\n";
  content += "        ...this._interceptors,\n";
  content += "        groupInterceptor,\n";
  content += "      ],\n";
  content += "    );\n";
  content += "  }\n";
  content += "\n";
  
  // Generate method wrappers for each service method
  for (const method of service.methods) {
    content += generateServiceMethodString(method, service, resourceName);
  }
  
  content += "}\n";
  
  return content;
}

function generateStreamingMethodString(
  method: DescMethod,
  methodName: string,
  requestType: string,
  responseType: string,
  resourceName: string
): string {
  let content = "";

  // Generate method JSDoc
  content += "  /**\n";
  content += `   * ${getMethodDescription(method.name, resourceName)}\n`;
  content += `   * Server-side streaming method with client-side validation and authentication.\n`;
  content += `   * @param {${requestType}} request - The request object for ${method.name.toLowerCase()}.\n`;
  content += `   * @returns {grpcWeb.ClientReadableStream<${responseType}>} A readable stream of ${responseType} messages.\n`;
  content += `   * @throws {Error} If request validation fails.\n`;
  content += "   * \n";
  content += "   * @example\n";
  content += `   * const stream = client.${methodName}(request);\n`;
  content += "   * stream.on('data', (response) => {\n";
  content += "   *   // Process each response\n";
  content += "   *   console.log(response);\n";
  content += "   * });\n";
  content += "   * stream.on('end', () => {\n";
  content += "   *   console.log('Stream ended');\n";
  content += "   * });\n";
  content += "   * stream.on('error', (err) => {\n";
  content += "   *   console.error('Stream error:', err);\n";
  content += "   * });\n";
  content += "   */\n";

  // Generate method signature and implementation with validation
  content += `  ${methodName}(request: ${requestType}): grpcWeb.ClientReadableStream<${responseType}> {\n`;
  content += "    // Validate request before initiating stream\n";
  content += "    validateRequest(request);\n";
  content += "\n";
  content += "    // Apply metadata from interceptors manually (grpc-web streaming doesn't support interceptors)\n";
  content += "    const metadata: { [key: string]: string } = {};\n";
  content += "    this._interceptors.forEach((interceptor) => {\n";
  content += "      if (interceptor instanceof GroupHeaderInterceptor) {\n";
  content += "        // Extract group header from GroupHeaderInterceptor\n";
  content += "        metadata['x-group'] = (interceptor as any).group;\n";
  content += "      }\n";
  content += "    });\n";
  content += "\n";
  content += `    return this._service.${methodName}(request, metadata);\n`;
  content += "  }\n";
  content += "\n";

  return content;
}

function generateServiceMethodString(method: DescMethod, service: DescService, resourceName: string): string {
  const methodName = camelCase(method.name);
  const requestType = method.input.name;
  const responseType = method.output.name;

  // Detect server-side streaming
  const isServerStreaming = method.methodKind === "server_streaming";

  let content = "";

  if (isServerStreaming) {
    return generateStreamingMethodString(method, methodName, requestType, responseType, resourceName);
  }

  // Generate method JSDoc
  content += "  /**\n";
  content += `   * ${getMethodDescription(method.name, resourceName)}\n`;
  content += `   * @param {${requestType}} request - The request object for ${method.name.toLowerCase()}.\n`;
  content += `   * @returns {Promise<${responseType}>} A promise that resolves with the ${getMethodReturnDescription(method.name, resourceName)}.\n`;
  content += "   */\n";

  // Generate method signature and implementation
  content += `  ${methodName}(request: ${requestType}): Promise<${responseType}> {\n`;
  content += `    return this._service.${methodName}(request);\n`;
  content += "  }\n";
  content += "\n";

  return content;
}

function camelCase(str: string): string {
  return str.charAt(0).toLowerCase() + str.slice(1);
}

function getMethodDescription(methodName: string, resourceName: string): string {
  const method = methodName.toLowerCase();
  const resource = toReadableResourceName(resourceName);
  
  if (method.startsWith('get')) {
    return `Retrieves ${getArticle(resource)} ${resource}.`;
  } else if (method.startsWith('create')) {
    return `Creates a new ${resource}.`;
  } else if (method.startsWith('update')) {
    return `Updates an existing ${resource}.`;
  } else if (method.startsWith('delete')) {
    return `Deletes ${getArticle(resource)} ${resource}.`;
  } else if (method.startsWith('list')) {
    return `Retrieves a list of ${resource}s.`;
  } else if (method.startsWith('search')) {
    return `Searches for ${resource}s.`;
  } else if (method.startsWith('activate')) {
    return `Activates ${getArticle(resource)} ${resource}.`;
  } else if (method.startsWith('deactivate')) {
    return `Deactivates ${getArticle(resource)} ${resource}.`;
  } else {
    return `Performs ${method} operation on ${resource}.`;
  }
}

function getMethodReturnDescription(methodName: string, resourceName: string): string {
  const method = methodName.toLowerCase();
  const resource = toReadableResourceName(resourceName);
  
  if (method.startsWith('list')) {
    return `list of ${resource}s`;
  } else if (method.startsWith('search')) {
    return 'search results';
  } else {
    return resource;
  }
}

function toReadableResourceName(resourceName: string): string {
  // Convert PascalCase to readable format, e.g., "ApiUser" -> "API user"
  return resourceName
    .replace(/([A-Z])([a-z])/g, '$1$2')  // Add space before capital followed by lowercase
    .replace(/([a-z])([A-Z])/g, '$1 $2') // Add space between lowercase and capital
    .toLowerCase();
}

function getArticle(word: string): string {
  // Return appropriate article (a/an) based on first letter
  const firstLetter = word.charAt(0).toLowerCase();
  return ['a', 'e', 'i', 'o', 'u'].includes(firstLetter) ? 'an' : 'a';
}

function convertToSnakeCase(str: string): string {
  // Convert PascalCase to snake_case: "APIUser" -> "api_user"
  return str
    .replace(/([A-Z]+)([A-Z][a-z])/g, '$1_$2')  // Handle sequences like "API" -> "API_"
    .replace(/([a-z\d])([A-Z])/g, '$1_$2')      // Handle transitions like "aB" -> "a_B"
    .toLowerCase();
}
