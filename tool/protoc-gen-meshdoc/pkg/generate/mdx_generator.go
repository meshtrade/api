package generate

import (
	"fmt"
	"path/filepath"
	"sort"
	"strings"

	"google.golang.org/protobuf/compiler/protogen"
)

// GenerateServiceDocs generates all documentation files for a service
func GenerateServiceDocs(plugin *protogen.Plugin, serviceInfo *ServiceInfo) error {
	domain := getServiceDomain(serviceInfo.Package)
	serviceName := getServiceName(serviceInfo.Package)
	version := getServiceVersion(serviceInfo.Package)

	// Generate service overview file (index.mdx)
	if err := generateServiceOverview(plugin, serviceInfo, domain, serviceName, version); err != nil {
		return fmt.Errorf("failed to generate service overview: %w", err)
	}

	// Generate service index file (service/index_meshdoc.mdx)
	if err := generateServiceIndex(plugin, serviceInfo, domain, serviceName, version); err != nil {
		return fmt.Errorf("failed to generate service index: %w", err)
	}

	// Generate method documentation files
	for _, method := range serviceInfo.Methods {
		if err := generateMethodDoc(plugin, serviceInfo, &method, domain, serviceName, version); err != nil {
			return fmt.Errorf("failed to generate method doc for %s: %w", method.Name, err)
		}

		// Generate example files
		if err := generateExampleFiles(plugin, &method, domain, serviceName, version); err != nil {
			return fmt.Errorf("failed to generate example files for %s: %w", method.Name, err)
		}
	}

	return nil
}

// generateServiceOverview creates the service overview index.mdx file
func generateServiceOverview(plugin *protogen.Plugin, serviceInfo *ServiceInfo, domain, serviceName, version string) error {
	filename := filepath.Join(domain, serviceName, version, "index.mdx")
	file := plugin.NewGeneratedFile(filename, "")

	// Format service name for display
	displayName := strings.Title(strings.ReplaceAll(serviceName, "_", " "))
	domainUpper := strings.ToUpper(domain)
	versionUpper := strings.ToUpper(version)

	content := fmt.Sprintf(`---
sidebar_position: 1
---

# %s %s %s Service

#### Skip The Details?
- ðŸ‘‰ Jump to **[Package Types](/docs/api-reference/%s/%s/%s/type/index_meshdoc)**
- ðŸ‘‰ Jump to **[Service Methods](/docs/api-reference/%s/%s/%s/service/index_meshdoc)**

{/*
Generated by protoc-gen-meshdoc the first time.
-> This file can be edited manually to add information about the %s %s Service.

THIS COMMENT AND EVERYTHING ABOVE IT IS AUTOGENERATED
*/}

## Overview

%s

Add your custom documentation for the %s %s %s service here.
This file is generated once and can be manually edited to provide
service-specific information, examples, and usage guidance.

## Quick Start

1. **Configure your client** with the appropriate credentials
2. **Choose your operations** from the available service methods
3. **Review the types** to understand request/response structures

## Common Workflows

Add common workflow documentation here specific to this service.

## Authentication & Authorization

This service requires appropriate role-based permissions. 
See the individual method documentation for specific role requirements.
`, domainUpper, displayName, versionUpper,
		domain, serviceName, version,
		domain, serviceName, version,
		domainUpper, displayName,
		serviceInfo.Description,
		domainUpper, displayName, versionUpper)

	file.Write([]byte(content))
	return nil
}

// generateServiceIndex creates the service/index_meshdoc.mdx file
func generateServiceIndex(plugin *protogen.Plugin, serviceInfo *ServiceInfo, domain, serviceName, version string) error {
	filename := filepath.Join(domain, serviceName, version, "service", "index_meshdoc.mdx")
	file := plugin.NewGeneratedFile(filename, "")

	// Generate method links
	var methodLinks strings.Builder
	for _, method := range serviceInfo.Methods {
		methodPath := kebabCase(method.Name)
		methodLinks.WriteString(fmt.Sprintf("- **[%s](./%s)**\n", method.Name, methodPath))
	}

	content := fmt.Sprintf(`---
sidebar_position: 1
---


# Service Methods

{/*
Generated by protoc-gen-meshdoc. DO NOT EDIT.
source: %s
*/}

import CodeBlock from '@theme/CodeBlock';
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import Proto from '!!raw-loader!../../../../../../../proto/%s';

<Tabs>

<TabItem value="table" label="Table of Methods">
The %s %s Service has the following methods:
%s</TabItem>

<TabItem value="protobuf" label="Protobuf">
<CodeBlock language="protobuf">{Proto}</CodeBlock>
</TabItem>

</Tabs>
`, serviceInfo.ProtoPath, serviceInfo.ProtoPath, strings.ToUpper(domain), strings.Title(strings.ReplaceAll(serviceName, "_", " ")), methodLinks.String())

	file.Write([]byte(content))
	return nil
}

// generateMethodDoc creates the service/{method}/index_meshdoc.mdx file
func generateMethodDoc(plugin *protogen.Plugin, serviceInfo *ServiceInfo, method *MethodInfo, domain, serviceName, version string) error {
	methodPath := kebabCase(method.Name)
	filename := filepath.Join(domain, serviceName, version, "service", methodPath, "index_meshdoc.mdx")
	file := plugin.NewGeneratedFile(filename, "")

	// Format roles
	rolesStr := strings.Join(method.Roles, ", ")
	if rolesStr == "" {
		rolesStr = "auto-generated from proto file"
	}

	// Format parameters
	var parametersStr string
	if len(method.Parameters) > 0 {
		var paramParts []string
		for _, param := range method.Parameters {
			required := ""
			if param.Required {
				required = " (required)"
			}
			paramParts = append(paramParts, fmt.Sprintf("- `%s` (%s)%s: %s", param.Name, param.Type, required, param.Description))
		}
		parametersStr = strings.Join(paramParts, "\n")
	} else {
		parametersStr = "No parameters"
	}

	content := fmt.Sprintf(`# %s
{/*
Generated by protoc-gen-meshdoc. DO NOT EDIT.
source: %s
*/}

import CodeBlock from '@theme/CodeBlock';
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

import GoExample from '!!raw-loader!./example.go';
import PythonExample from '!!raw-loader!./example.py';
import Proto from '!!raw-loader!../../../../../../../../proto/%s';


## Method Details

**Description:** %s

**Required Roles:** %s

**Parameters:** 
%s

**Returns:** %s

**Method Type:** %s

## Code Examples

<Tabs>
<TabItem value="go" label="Go">
<CodeBlock language="go">{GoExample}</CodeBlock>
</TabItem>
<TabItem value="python" label="Python">
<CodeBlock language="python">{PythonExample}</CodeBlock>
</TabItem>
<TabItem value="protobuf" label="Protobuf">
<CodeBlock language="protobuf">{Proto}</CodeBlock>
</TabItem>
</Tabs>

## Advanced Configuration

For advanced client configuration options (custom endpoints, TLS settings, timeouts), see the [SDK Configuration Guide](/docs/architecture/sdk-configuration).

## Other Methods

- **[%s %s %s Method List](/docs/api-reference/%s/%s/%s/service)** - For Other methods
`, method.Name, serviceInfo.ProtoPath, serviceInfo.ProtoPath,
		method.Description, rolesStr, parametersStr, method.Returns, method.MethodType,
		strings.ToUpper(domain), strings.Title(strings.ReplaceAll(serviceName, "_", " ")), strings.ToUpper(version),
		domain, serviceName, version)

	file.Write([]byte(content))
	return nil
}

// generateExampleFiles creates the example.go and example.py files
func generateExampleFiles(plugin *protogen.Plugin, method *MethodInfo, domain, serviceName, version string) error {
	methodPath := kebabCase(method.Name)

	// Generate Go example
	goFilename := filepath.Join(domain, serviceName, version, "service", methodPath, "example.go")
	goFile := plugin.NewGeneratedFile(goFilename, "")
	goContent := fmt.Sprintf(`package main

import (
	"context"
	"log"

	%sv1 "github.com/meshtrade/api/go/%s/%s/%s"
)

func main() {
	// TODO: Add example code for %s
	// Create client and call %s method
	log.Println("Example for %s")
}
`, serviceName, domain, serviceName, version, method.Name, method.Name, method.Name)
	goFile.Write([]byte(goContent))

	// Generate Python example
	pyFilename := filepath.Join(domain, serviceName, version, "service", methodPath, "example.py")
	pyFile := plugin.NewGeneratedFile(pyFilename, "")
	pyContent := fmt.Sprintf(`from meshtrade.%s.%s.%s import (
    %sService,
    ClientOptions,
)


def main():
    # TODO: Add example code for %s
    # Create client and call %s method
    print("Example for %s")


if __name__ == "__main__":
    main()
`, domain, serviceName, version, strings.Title(strings.ReplaceAll(serviceName, "_", "")), method.Name, method.Name, method.Name)
	pyFile.Write([]byte(pyContent))

	return nil
}

// kebabCase converts CamelCase to kebab-case
func kebabCase(s string) string {
	var result strings.Builder
	for i, r := range s {
		if i > 0 && r >= 'A' && r <= 'Z' {
			result.WriteRune('-')
		}
		if r >= 'A' && r <= 'Z' {
			result.WriteRune(r + ('a' - 'A'))
		} else {
			result.WriteRune(r)
		}
	}
	return result.String()
}

// GenerateTypeDocs generates all type documentation files for a package
func GenerateTypeDocs(plugin *protogen.Plugin, packageInfo *PackageTypeInfo) error {
	if len(packageInfo.Types) == 0 {
		// No types to generate
		return nil
	}

	// Generate type index file
	if err := generateTypeIndex(plugin, packageInfo); err != nil {
		return fmt.Errorf("failed to generate type index: %w", err)
	}

	// Generate individual type documentation files
	for _, typeInfo := range packageInfo.Types {
		if err := generateTypeDoc(plugin, packageInfo, &typeInfo); err != nil {
			return fmt.Errorf("failed to generate type doc for %s: %w", typeInfo.Name, err)
		}
	}

	return nil
}

// generateTypeIndex creates the type/index_meshdoc.mdx file
func generateTypeIndex(plugin *protogen.Plugin, packageInfo *PackageTypeInfo) error {
	filename := filepath.Join(packageInfo.Domain, packageInfo.ServiceName, packageInfo.Version, "type", "index_meshdoc.mdx")
	file := plugin.NewGeneratedFile(filename, "")

	// Generate type links
	var typeLinks strings.Builder
	for _, typeInfo := range packageInfo.Types {
		typePath := fmt.Sprintf("./%s_meshdoc", kebabCase(typeInfo.Name))
		typeLinks.WriteString(fmt.Sprintf("- **[%s](%s)**\n", typeInfo.Name, typePath))
	}

	content := fmt.Sprintf(`---
sidebar_position: 1
---

# Package Types

{/*
Generated by protoc-gen-meshdoc. DO NOT EDIT.
source: %s/**
*/}

The %s %s %s package contains the following types:

%s

**Note**: Only domain types are listed here. Request and response message types are documented with their respective service methods.
`, packageInfo.Package, strings.ToUpper(packageInfo.Domain), 
		strings.Title(strings.ReplaceAll(packageInfo.ServiceName, "_", " ")), 
		strings.ToUpper(packageInfo.Version), typeLinks.String())

	file.Write([]byte(content))
	return nil
}

// generateTypeDoc creates the type/{type}_meshdoc.mdx file
func generateTypeDoc(plugin *protogen.Plugin, packageInfo *PackageTypeInfo, typeInfo *TypeInfo) error {
	typePath := fmt.Sprintf("%s_meshdoc", kebabCase(typeInfo.Name))
	filename := filepath.Join(packageInfo.Domain, packageInfo.ServiceName, packageInfo.Version, "type", typePath+".mdx")
	file := plugin.NewGeneratedFile(filename, "")

	var content string
	if typeInfo.IsEnum {
		content = generateEnumDocContent(typeInfo)
	} else {
		content = generateMessageDocContent(typeInfo)
	}

	file.Write([]byte(content))
	return nil
}

// generateMessageDocContent generates content for a message type
func generateMessageDocContent(typeInfo *TypeInfo) string {
	// Generate field table
	var fieldTable strings.Builder
	fieldTable.WriteString("| Field | Type | Description | Required | Validation |\n")
	fieldTable.WriteString("|-------|------|-------------|----------|-----------|\n")

	for _, field := range typeInfo.Fields {
		required := "No"
		if field.Required {
			required = "Yes"
		}
		description := field.Description
		if description == "" {
			description = "No description available"
		}
		fieldTable.WriteString(fmt.Sprintf("| `%s` | %s | %s | %s | %s |\n",
			field.Name, field.Type, description, required, "TODO: validation rules"))
	}

	return fmt.Sprintf(`# %s
{/*
Generated by protoc-gen-meshdoc. DO NOT EDIT.
source: %s
*/}

import CodeBlock from '@theme/CodeBlock';
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import Proto from '!!raw-loader!../../../../../../../proto/%s';

From %s - [View on GitHub](https://github.com/meshtrade/api/blob/main/proto/%s)

<Tabs>

<TabItem value="table" label="Table">
**Description:** %s

%s</TabItem>

<TabItem value="protobuf" label="Protobuf">
<CodeBlock language="protobuf">{Proto}</CodeBlock>
</TabItem>

</Tabs>
`, typeInfo.Name, typeInfo.ProtoPath, typeInfo.ProtoPath, 
		typeInfo.ProtoPath, typeInfo.ProtoPath, 
		typeInfo.Description, fieldTable.String())
}

// generateEnumDocContent generates content for an enum type
func generateEnumDocContent(typeInfo *TypeInfo) string {
	// Generate enum value table
	var valueTable strings.Builder
	valueTable.WriteString("| Value | Description |\n")
	valueTable.WriteString("|-------|-------------|\n")

	for _, value := range typeInfo.EnumValues {
		description := value.Description
		if description == "" {
			description = "No description available"
		}
		valueTable.WriteString(fmt.Sprintf("| `%s` | %s |\n", value.Name, description))
	}

	return fmt.Sprintf(`# %s
{/*
Generated by protoc-gen-meshdoc. DO NOT EDIT.
source: %s
*/}

import CodeBlock from '@theme/CodeBlock';
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import Proto from '!!raw-loader!../../../../../../../proto/%s';

From %s - [View on GitHub](https://github.com/meshtrade/api/blob/main/proto/%s)

<Tabs>

<TabItem value="table" label="Table">
**Description:** %s

%s</TabItem>

<TabItem value="protobuf" label="Protobuf">
<CodeBlock language="protobuf">{Proto}</CodeBlock>
</TabItem>

</Tabs>
`, typeInfo.Name, typeInfo.ProtoPath, typeInfo.ProtoPath, 
		typeInfo.ProtoPath, typeInfo.ProtoPath, 
		typeInfo.Description, valueTable.String())
}

// GenerateNavigation generates the navigation sidebar_meshdoc.ts file
func GenerateNavigation(plugin *protogen.Plugin, serviceInfos []*ServiceInfo, packageInfos map[string]*PackageTypeInfo) error {
	filename := "sidebar_meshdoc.ts"
	file := plugin.NewGeneratedFile(filename, "")

	// Group services by domain
	domainMap := make(map[string]map[string]map[string]*ServiceInfo) // domain -> service -> version -> ServiceInfo

	for _, serviceInfo := range serviceInfos {
		domain := getServiceDomain(serviceInfo.Package)
		serviceName := getServiceName(serviceInfo.Package)
		version := getServiceVersion(serviceInfo.Package)

		if domainMap[domain] == nil {
			domainMap[domain] = make(map[string]map[string]*ServiceInfo)
		}
		if domainMap[domain][serviceName] == nil {
			domainMap[domain][serviceName] = make(map[string]*ServiceInfo)
		}
		domainMap[domain][serviceName][version] = serviceInfo
	}

	// Build navigation structure
	var navigationContent strings.Builder
	navigationContent.WriteString("// Generated by protoc-gen-meshdoc.\n// DO NOT EDIT\n\nexport const api_reference_sidebar = [\n")

	// Convert map to sorted slice for consistent ordering
	var domainNames []string
	for domain := range domainMap {
		domainNames = append(domainNames, domain)
	}
	sort.Strings(domainNames)

	for i, domain := range domainNames {
		services := domainMap[domain]
		domainDisplay := strings.ToUpper(domain)
		navigationContent.WriteString(fmt.Sprintf("  {\n    type: 'category',\n    label: '%s',\n    items: [\n", domainDisplay))

		// Convert service map to sorted slice
		var serviceNames []string
		for serviceName := range services {
			serviceNames = append(serviceNames, serviceName)
		}
		sort.Strings(serviceNames)

		for j, serviceName := range serviceNames {
			versions := services[serviceName]
			serviceDisplay := strings.Title(strings.ReplaceAll(serviceName, "_", " "))
			navigationContent.WriteString(fmt.Sprintf("      {\n        type: 'category',\n        label: '%s',\n        items: [\n", serviceDisplay))

			// Convert version map to sorted slice
			var versionNames []string
			for version := range versions {
				versionNames = append(versionNames, version)
			}
			sort.Strings(versionNames)

			for k, version := range versionNames {
				serviceInfo := versions[version]
				versionDisplay := strings.ToUpper(version)
				navigationContent.WriteString(fmt.Sprintf("          {\n            type: 'category',\n            label: '%s',\n            items: [\n", versionDisplay))

				// Add overview page
				navigationContent.WriteString(fmt.Sprintf("              'api-reference/%s/%s/%s/index', // overview file generated by protoc-gen-meshdoc, filled out by developers with package information\n", domain, serviceName, version))

				// Add Types section
				navigationContent.WriteString("              {\n                type: 'category',\n                label: 'Types',\n                items: [\n")
				navigationContent.WriteString(fmt.Sprintf("                  'api-reference/%s/%s/%s/type/index_meshdoc',\n", domain, serviceName, version))

				// Add individual type files
				packageKey := serviceInfo.Package
				if packageInfo, exists := packageInfos[packageKey]; exists {
					for _, typeInfo := range packageInfo.Types {
						typePath := fmt.Sprintf("%s_meshdoc", kebabCase(typeInfo.Name))
						navigationContent.WriteString(fmt.Sprintf("                  'api-reference/%s/%s/%s/type/%s',\n", domain, serviceName, version, typePath))
					}
				}

				navigationContent.WriteString("                ]\n              },\n")

				// Add Service section
				navigationContent.WriteString("              {\n                type: 'category',\n                label: 'Service',\n                items: [\n")
				navigationContent.WriteString(fmt.Sprintf("                  'api-reference/%s/%s/%s/service/index_meshdoc',\n", domain, serviceName, version))

				// Add individual method files
				for _, method := range serviceInfo.Methods {
					methodPath := kebabCase(method.Name)
					navigationContent.WriteString(fmt.Sprintf("                  'api-reference/%s/%s/%s/service/%s/index_meshdoc',\n", domain, serviceName, version, methodPath))
				}

				navigationContent.WriteString("                ]\n              }\n")
				// Add comma except for last version
				if k < len(versionNames)-1 {
					navigationContent.WriteString("            ]\n          },\n")
				} else {
					navigationContent.WriteString("            ]\n          }\n")
				}
			}

			// Add comma except for last service
			if j < len(serviceNames)-1 {
				navigationContent.WriteString("        ]\n      },\n")
			} else {
				navigationContent.WriteString("        ]\n      }\n")
			}
		}

		// Add comma except for last domain
		if i < len(domainNames)-1 {
			navigationContent.WriteString("    ]\n  },\n")
		} else {
			navigationContent.WriteString("    ]\n  }\n")
		}
	}

	navigationContent.WriteString("];\n")

	file.Write([]byte(navigationContent.String()))
	return nil
}