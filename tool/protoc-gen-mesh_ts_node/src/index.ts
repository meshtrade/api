import { DescFile, DescService, DescMethod } from "@bufbuild/protobuf";
import {
  createEcmaScriptPlugin,
  runNodeJs,
  type Schema,
} from "@bufbuild/protoplugin";
import * as fs from "fs";
import * as path from "path";

const plugin = createEcmaScriptPlugin({
  name: "protoc-gen-meshts",
  version: "v1",
  generateTs(schema: Schema) {
    // Loop through all Protobuf files in the schema to look for service definitions
    for (const file of schema.files) {
      if (file.services.length > 0) {
        // Generate a TypeScript Connect-ES client for each file with services
        generateConnectClientManually(schema, file);
      }
    }
  },
});

// Reads the schema from stdin, runs the plugin, and writes the generated files to stdout.
runNodeJs(plugin);

function generateConnectClientManually(schema: Schema, file: DescFile) {
  // Build the TypeScript content manually as a string
  let content = "";

  // Add file header
  content += `// @generated by protoc-gen-meshts v1\n`;
  content += `// @generated from file ${file.name}.proto (package ${file.proto.package}, syntax proto3)\n`;
  content += `/* eslint-disable */\n`;
  content += `\n`;

  // Generate imports for Connect-ES (Node.js)
  content += `import { createClient, type Client as ConnectClient, Interceptor } from "@connectrpc/connect";\n`;
  content += `import { createGrpcTransport } from "@connectrpc/connect-node";\n`;

  // Import the service schema from generated code
  for (const service of file.services) {
    const serviceName = service.name;
    content += `import { ${serviceName} } from "./service_pb";\n`;
  }

  // Import request/response types
  // Separate types defined in service_pb from those in other files
  const serviceTypes = new Set<string>();
  const externalTypes = new Set<string>();

  for (const service of file.services) {
    for (const method of service.methods) {
      // Request types are typically defined in service.proto
      if (method.input.file === file) {
        serviceTypes.add(method.input.name);
      } else {
        externalTypes.add(method.input.name);
      }

      // Response types may be defined in different files
      if (method.output.file === file) {
        serviceTypes.add(method.output.name);
      } else {
        externalTypes.add(method.output.name);
      }
    }
  }

  // Import types from service_pb (request/response messages defined in the service file)
  if (serviceTypes.size > 0) {
    const sortedServiceTypes = Array.from(serviceTypes).sort();
    content += `import {\n`;
    for (let i = 0; i < sortedServiceTypes.length; i++) {
      content += `  ${sortedServiceTypes[i]}${i < sortedServiceTypes.length - 1 ? ',' : ''}\n`;
    }
    content += `} from "./service_pb";\n`;
  }

  // Import types from their respective files (e.g., APIUser from api_user_pb)
  if (externalTypes.size > 0) {
    const sortedExternalTypes = Array.from(externalTypes).sort();
    for (const typeName of sortedExternalTypes) {
      // Generate import based on the file naming pattern
      // Convert "APIUser" -> "api_user_pb"
      const importPath = `./${convertToSnakeCase(typeName)}_pb`;
      content += `import { ${typeName} } from "${importPath}";\n`;
    }
  }

  // Generate imports for common utilities with dynamic relative paths
  const outputFilePath = getOutputFilePath(file);
  const relativePathToCommon = getRelativePathToCommon(outputFilePath);
  content += `import { ConfigOpts, getConfigFromOpts } from "${relativePathToCommon}/config";\n`;
  content += `import { validateRequest } from "${relativePathToCommon}/validation";\n`;
  content += `import { createGroupInterceptor, createApiKeyInterceptor, createJwtInterceptor } from "${relativePathToCommon}/connectInterceptors";\n`;
  content += `\n`;

  // Generate client class for each service
  for (const service of file.services) {
    content += generateServiceClientString(service, file);
  }

  // Write the TypeScript content to the file
  writeTypescriptFile(outputFilePath, content);
}

function getOutputFilePath(file: DescFile): string {
  // Convert protobuf file path to TypeScript Node output path
  // Example: "meshtrade/iam/api_user/v1/service.proto" -> "ts-node/src/meshtrade/iam/api_user/v1/service_node_meshts.ts"
  const protoPath = file.name; // e.g., "meshtrade/iam/api_user/v1/service"
  const outputDir = path.join("ts-node", "src", path.dirname(protoPath));
  const fileName = path.basename(protoPath) + "_node_meshts.ts";
  return path.join(outputDir, fileName);
}

function getRelativePathToCommon(outputFilePath: string): string {
  // Calculate the relative path from the generated file to the common directory
  // Example: from "ts-node/src/meshtrade/iam/api_user/v1/service_node_meshts.ts"
  //          to "ts-node/src/meshtrade/common/" returns "../../../common"
  const generatedFileDir = path.dirname(outputFilePath);
  const commonDir = path.join("ts-node", "src", "meshtrade", "common");
  return path.relative(generatedFileDir, commonDir);
}

function writeTypescriptFile(filePath: string, content: string): void {
  try {
    // Ensure the directory exists
    const dir = path.dirname(filePath);
    fs.mkdirSync(dir, { recursive: true });

    // Write the TypeScript content to the file
    fs.writeFileSync(filePath, content, 'utf8');

    console.error(`Generated TypeScript Connect client: ${filePath}`);
  } catch (error) {
    console.error(`Failed to write TypeScript file: ${filePath}`, error);
    throw error;
  }
}

function generateServiceClientString(service: DescService, file: DescFile): string {
  const serviceName = service.name;
  const clientClassName = `${serviceName}Node`;

  // Extract resource name from the service (e.g., ApiUser from ApiUserService)
  const resourceName = serviceName.replace(/Service$/, '');

  let content = "";

  // Generate class JSDoc
  content += "/**\n";
  content += ` * Node.js client for interacting with the ${file.proto.package} ${toReadableResourceName(resourceName)} v1 API resource service.\n`;
  content += " * Uses Connect-ES with gRPC transport for Node.js gRPC communication.\n";
  content += " *\n";
  content += " * Supports three authentication modes:\n";
  content += " *\n";
  content += " * 1. **No Authentication** (public APIs):\n";
  content += " *    ```typescript\n";
  content += ` *    const client = new ${clientClassName}({ apiServerURL: \"http://localhost:10000\" });\n`;
  content += " *    ```\n";
  content += " *\n";
  content += " * 2. **API Key Authentication** (backend services):\n";
  content += " *    ```typescript\n";
  content += ` *    const client = new ${clientClassName}({\n`;
  content += " *      apiServerURL: \"https://api.example.com\",\n";
  content += " *      apiKey: \"your-api-key\",\n";
  content += " *      group: \"groups/01ARZ3NDEKTSV4YWVF8F5BH32\"\n";
  content += " *    });\n";
  content += " *    ```\n";
  content += " *\n";
  content += " * 3. **JWT Token Authentication** (Next.js backend with user session):\n";
  content += " *    ```typescript\n";
  content += ` *    const client = new ${clientClassName}({\n`;
  content += " *      apiServerURL: \"https://api.example.com\",\n";
  content += " *      jwtToken: \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...\"\n";
  content += " *    });\n";
  content += " *    ```\n";
  content += " */\n";

  // Generate class declaration
  content += `export class ${clientClassName} {\n`;
  content += `  private _client: ConnectClient<typeof ${serviceName}>;\n`;
  content += `  private readonly _config: ReturnType<typeof getConfigFromOpts>;\n`;
  content += `  private readonly _interceptors: Interceptor[];\n`;
  content += "\n";

  // Generate constructor
  content += "  /**\n";
  content += `   * Constructs an instance of ${clientClassName}.\n`;
  content += "   * @param {ConfigOpts} [config] - Optional configuration for the client.\n";
  content += "   * @param {Interceptor[]} [interceptors] - For internal use by \`withGroup\`.\n";
  content += "   */\n";
  content += "  constructor(config?: ConfigOpts, interceptors?: Interceptor[]) {\n";
  content += "    this._config = getConfigFromOpts(config);\n";
  content += "\n";
  content += "    // If interceptors are provided (from withGroup), use them\n";
  content += "    // Otherwise, create auth interceptors based on config\n";
  content += "    if (interceptors) {\n";
  content += "      this._interceptors = interceptors;\n";
  content += "    } else {\n";
  content += "      this._interceptors = [];\n";
  content += "\n";
  content += "      // Add authentication interceptor based on configuration\n";
  content += "      if (this._config.apiKey && this._config.group) {\n";
  content += "        // API Key authentication mode\n";
  content += "        this._interceptors.push(\n";
  content += "          createApiKeyInterceptor(this._config.apiKey, this._config.group)\n";
  content += "        );\n";
  content += "      } else if (this._config.jwtToken) {\n";
  content += "        // JWT authentication mode\n";
  content += "        this._interceptors.push(\n";
  content += "          createJwtInterceptor(this._config.jwtToken)\n";
  content += "        );\n";
  content += "      }\n";
  content += "      // If neither is configured, no authentication (public API mode)\n";
  content += "    }\n";
  content += "\n";
  content += "    // Create the gRPC transport for Node.js with interceptors\n";
  content += "    // Note: gRPC transport uses HTTP/2 by default\n";
  content += "    const transport = createGrpcTransport({\n";
  content += "      baseUrl: this._config.apiServerURL,\n";
  content += "      interceptors: this._interceptors,\n";
  content += "    });\n";
  content += "\n";
  content += "    // Construct the Connect-ES client\n";
  content += `    this._client = createClient(${serviceName}, transport);\n`;
  content += "  }\n";
  content += "\n";

  // Generate withGroup method
  content += "  /**\n";
  content += "   * Returns a new client instance configured to send the specified group\n";
  content += "   * resource name in the request headers for subsequent API calls.\n";
  content += "   *\n";
  content += "   * **Important**: This method only works with API key authentication.\n";
  content += "   * - For **API key auth**: Creates a new client with updated group context\n";
  content += "   * - For **JWT auth**: Throws error (group comes from JWT token claims)\n";
  content += "   * - For **no auth**: Throws error (group requires authentication)\n";
  content += "   * \n";
  content += "   * @param {string} group - The operating group context to inject into the request\n";
  content += "   *                         in the format \`groups/{ulid}\` where {ulid} is a 26-character ULID.\n";
  content += "   *                         Example: 'groups/01ARZ3NDEKTSV4YWVF8F5BH32'\n";
  content += `   * @returns {${clientClassName}} A new, configured instance of the client.\n`;
  content += "   * @throws {Error} If used with JWT authentication or no authentication\n";
  content += "   * @throws {Error} If the group format is invalid\n";
  content += "   */\n";
  content += `  withGroup(group: string): ${clientClassName} {\n`;
  content += "    // Check authentication mode\n";
  content += "    if (this._config.jwtToken) {\n";
  content += "      throw new Error(\n";
  content += '        "Cannot use withGroup() with JWT authentication. " +\n';
  content += '        "The group context is determined by the JWT token claims."\n';
  content += "      );\n";
  content += "    }\n";
  content += "\n";
  content += "    if (!this._config.apiKey) {\n";
  content += "      throw new Error(\n";
  content += '        "Cannot use withGroup() without authentication. " +\n';
  content += '        "Please configure API key authentication to use group context."\n';
  content += "      );\n";
  content += "    }\n";
  content += "\n";
  content += "    // For API key authentication, create new client with updated group\n";
  content += "    // Replace the existing API key interceptor with one that has the new group\n";
  content += "    const newInterceptors = [\n";
  content += "      createApiKeyInterceptor(this._config.apiKey, group)\n";
  content += "    ];\n";
  content += "\n";
  content += "    // Return a new client instance with updated group context\n";
  content += `    return new ${clientClassName}(\n`;
  content += "      this._config,\n";
  content += "      newInterceptors,\n";
  content += "    );\n";
  content += "  }\n";
  content += "\n";

  // Generate method wrappers for each service method
  for (const method of service.methods) {
    content += generateServiceMethodString(method, service, resourceName);
  }

  content += "}\n";

  return content;
}

function generateStreamingMethodString(
  method: DescMethod,
  methodName: string,
  requestType: string,
  responseType: string,
  resourceName: string
): string {
  let content = "";

  // Generate method JSDoc
  content += "  /**\n";
  content += `   * ${getMethodDescription(method.name, resourceName)}\n`;
  content += `   * Server-side streaming method with client-side validation and authentication.\n`;
  content += `   * @param {${requestType}} request - The request object for ${method.name.toLowerCase()}.\n`;
  content += `   * @returns {AsyncIterable<${responseType}>} An async iterable of ${responseType} messages.\n`;
  content += `   * @throws {Error} If request validation fails.\n`;
  content += "   * \n";
  content += "   * @example\n";
  content += `   * const stream = client.${methodName}(request);\n`;
  content += "   * for await (const response of stream) {\n";
  content += "   *   // Process each response\n";
  content += "   *   console.log(response);\n";
  content += "   * }\n";
  content += "   */\n";

  // Generate method signature and implementation with validation
  content += `  ${methodName}(request: ${requestType}): AsyncIterable<${responseType}> {\n`;
  content += "    // Validate request before initiating stream\n";
  content += "    validateRequest(request);\n";
  content += "\n";
  content += `    return this._client.${methodName}(request);\n`;
  content += "  }\n";
  content += "\n";

  return content;
}

function generateServiceMethodString(method: DescMethod, service: DescService, resourceName: string): string {
  const methodName = camelCase(method.name);
  const requestType = method.input.name;
  const responseType = method.output.name;

  // Detect server-side streaming
  const isServerStreaming = method.methodKind === "server_streaming";

  let content = "";

  if (isServerStreaming) {
    return generateStreamingMethodString(method, methodName, requestType, responseType, resourceName);
  }

  // Generate method JSDoc
  content += "  /**\n";
  content += `   * ${getMethodDescription(method.name, resourceName)}\n`;
  content += `   * @param {${requestType}} request - The request object for ${method.name.toLowerCase()}.\n`;
  content += `   * @returns {Promise<${responseType}>} A promise that resolves with the ${getMethodReturnDescription(method.name, resourceName)}.\n`;
  content += "   */\n";

  // Generate method signature and implementation
  content += `  ${methodName}(request: ${requestType}): Promise<${responseType}> {\n`;
  content += "    // Validate request\n";
  content += "    validateRequest(request);\n";
  content += "\n";
  content += `    return this._client.${methodName}(request);\n`;
  content += "  }\n";
  content += "\n";

  return content;
}

function camelCase(str: string): string {
  return str.charAt(0).toLowerCase() + str.slice(1);
}

function getMethodDescription(methodName: string, resourceName: string): string {
  const method = methodName.toLowerCase();
  const resource = toReadableResourceName(resourceName);

  if (method.startsWith('get')) {
    return `Retrieves ${getArticle(resource)} ${resource}.`;
  } else if (method.startsWith('create')) {
    return `Creates a new ${resource}.`;
  } else if (method.startsWith('update')) {
    return `Updates an existing ${resource}.`;
  } else if (method.startsWith('delete')) {
    return `Deletes ${getArticle(resource)} ${resource}.`;
  } else if (method.startsWith('list')) {
    return `Retrieves a list of ${resource}s.`;
  } else if (method.startsWith('search')) {
    return `Searches for ${resource}s.`;
  } else if (method.startsWith('activate')) {
    return `Activates ${getArticle(resource)} ${resource}.`;
  } else if (method.startsWith('deactivate')) {
    return `Deactivates ${getArticle(resource)} ${resource}.`;
  } else {
    return `Performs ${method} operation on ${resource}.`;
  }
}

function getMethodReturnDescription(methodName: string, resourceName: string): string {
  const method = methodName.toLowerCase();
  const resource = toReadableResourceName(resourceName);

  if (method.startsWith('list')) {
    return `list of ${resource}s`;
  } else if (method.startsWith('search')) {
    return 'search results';
  } else {
    return resource;
  }
}

function toReadableResourceName(resourceName: string): string {
  // Convert PascalCase to readable format, e.g., "ApiUser" -> "API user"
  return resourceName
    .replace(/([A-Z])([a-z])/g, '$1$2')  // Add space before capital followed by lowercase
    .replace(/([a-z])([A-Z])/g, '$1 $2') // Add space between lowercase and capital
    .toLowerCase();
}

function getArticle(word: string): string {
  // Return appropriate article (a/an) based on first letter
  const firstLetter = word.charAt(0).toLowerCase();
  return ['a', 'e', 'i', 'o', 'u'].includes(firstLetter) ? 'an' : 'a';
}

function convertToSnakeCase(str: string): string {
  // Convert PascalCase to snake_case: "APIUser" -> "api_user"
  return str
    .replace(/([A-Z]+)([A-Z][a-z])/g, '$1_$2')  // Handle sequences like "API" -> "API_"
    .replace(/([a-z\d])([A-Z])/g, '$1_$2')      // Handle transitions like "aB" -> "a_B"
    .toLowerCase();
}
