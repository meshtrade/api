import { DescFile, DescService, DescMethod } from "@bufbuild/protobuf";
import {
  createEcmaScriptPlugin,
  runNodeJs,
  type Schema,
} from "@bufbuild/protoplugin";
import * as fs from "fs";
import * as path from "path";

const plugin = createEcmaScriptPlugin({
  name: "protoc-gen-meshts",
  version: "v1",
  generateTs(schema: Schema) {
    // Loop through all Protobuf files in the schema to look for service definitions
    for (const file of schema.files) {
      if (file.services.length > 0) {
        // Generate a TypeScript Connect-ES client for each file with services
        generateConnectClientManually(schema, file);
      }
    }
  },
});

// Reads the schema from stdin, runs the plugin, and writes the generated files to stdout.
runNodeJs(plugin);

function generateConnectClientManually(schema: Schema, file: DescFile) {
  // Build the TypeScript content manually as a string
  let content = "";

  // Add file header
  content += `// @generated by protoc-gen-meshts v1\n`;
  content += `// @generated from file ${file.name}.proto (package ${file.proto.package}, syntax proto3)\n`;
  content += `/* eslint-disable */\n`;
  content += `\n`;

  // Generate imports for Connect-ES
  content += `import { createClient, type Client as ConnectClient, Interceptor } from "@connectrpc/connect";\n`;
  content += `import { createGrpcWebTransport } from "@connectrpc/connect-web";\n`;

  // Import the service schema from generated code
  for (const service of file.services) {
    const serviceName = service.name;
    content += `import { ${serviceName} } from "./service_pb";\n`;
  }

  // Import request/response types
  // Separate types defined in service_pb from those in other files
  const serviceTypes = new Set<string>();
  const externalTypes = new Set<string>();

  for (const service of file.services) {
    for (const method of service.methods) {
      // Request types are typically defined in service.proto
      if (method.input.file === file) {
        serviceTypes.add(method.input.name);
      } else {
        externalTypes.add(method.input.name);
      }

      // Response types may be defined in different files
      if (method.output.file === file) {
        serviceTypes.add(method.output.name);
      } else {
        externalTypes.add(method.output.name);
      }
    }
  }

  // Import types from service_pb (request/response messages defined in the service file)
  if (serviceTypes.size > 0) {
    const sortedServiceTypes = Array.from(serviceTypes).sort();
    content += `import {\n`;
    for (let i = 0; i < sortedServiceTypes.length; i++) {
      content += `  ${sortedServiceTypes[i]}${i < sortedServiceTypes.length - 1 ? ',' : ''}\n`;
    }
    content += `} from "./service_pb";\n`;
  }

  // Import types from their respective files (e.g., APIUser from api_user_pb)
  if (externalTypes.size > 0) {
    const sortedExternalTypes = Array.from(externalTypes).sort();
    for (const typeName of sortedExternalTypes) {
      // Generate import based on the file naming pattern
      // Convert "APIUser" -> "api_user_pb"
      const importPath = `./${convertToSnakeCase(typeName)}_pb`;
      content += `import { ${typeName} } from "${importPath}";\n`;
    }
  }

  // Generate imports for common utilities with dynamic relative paths
  const outputFilePath = getOutputFilePath(file);
  const relativePathToCommon = getRelativePathToCommon(outputFilePath);
  content += `import { ConfigOpts, getConfigFromOpts } from "${relativePathToCommon}/config";\n`;
  content += `import { validateRequest } from "${relativePathToCommon}/validation";\n`;
  content += `import { createGroupInterceptor } from "${relativePathToCommon}/connectInterceptors";\n`;
  content += `\n`;

  // Generate client class for each service
  for (const service of file.services) {
    content += generateServiceClientString(service, file);
  }

  // Write the TypeScript content to the file
  writeTypescriptFile(outputFilePath, content);
}

function getOutputFilePath(file: DescFile): string {
  // Convert protobuf file path to TypeScript output path
  // Example: "meshtrade/iam/api_user/v1/service.proto" -> "ts/src/meshtrade/iam/api_user/v1/service_web_meshts.ts"
  const protoPath = file.name; // e.g., "meshtrade/iam/api_user/v1/service"
  const outputDir = path.join("ts", "src", path.dirname(protoPath));
  const fileName = path.basename(protoPath) + "_web_meshts.ts";
  return path.join(outputDir, fileName);
}

function getRelativePathToCommon(outputFilePath: string): string {
  // Calculate the relative path from the generated file to the common directory
  // Example: from "ts/src/meshtrade/iam/api_user/v1/service_web_meshts.ts"
  //          to "ts/src/meshtrade/common/" returns "../../../common"
  const generatedFileDir = path.dirname(outputFilePath);
  const commonDir = path.join("ts", "src", "meshtrade", "common");
  return path.relative(generatedFileDir, commonDir);
}

function writeTypescriptFile(filePath: string, content: string): void {
  try {
    // Ensure the directory exists
    const dir = path.dirname(filePath);
    fs.mkdirSync(dir, { recursive: true });

    // Write the TypeScript content to the file
    fs.writeFileSync(filePath, content, 'utf8');

    console.error(`Generated TypeScript Connect client: ${filePath}`);
  } catch (error) {
    console.error(`Failed to write TypeScript file: ${filePath}`, error);
    throw error;
  }
}

function generateServiceClientString(service: DescService, file: DescFile): string {
  const serviceName = service.name;
  const clientClassName = `${serviceName}Web`;

  // Extract resource name from the service (e.g., ApiUser from ApiUserService)
  const resourceName = serviceName.replace(/Service$/, '');

  let content = "";

  // Generate class JSDoc
  content += "/**\n";
  content += ` * Web client for interacting with the ${file.proto.package} ${toReadableResourceName(resourceName)} v1 API resource service.\n`;
  content += " * Uses Connect-ES with gRPC-Web transport for browser-compatible gRPC communication.\n";
  content += " */\n";

  // Generate class declaration
  content += `export class ${clientClassName} {\n`;
  content += `  private _client: ConnectClient<typeof ${serviceName}>;\n`;
  content += `  private readonly _config: ReturnType<typeof getConfigFromOpts>;\n`;
  content += `  private readonly _interceptors: Interceptor[];\n`;
  content += "\n";

  // Generate constructor
  content += "  /**\n";
  content += `   * Constructs an instance of ${clientClassName}.\n`;
  content += "   * @param {ConfigOpts} [config] - Optional configuration for the client.\n";
  content += "   * @param {Interceptor[]} [interceptors] - For internal use by \`withGroup\`.\n";
  content += "   */\n";
  content += "  constructor(config?: ConfigOpts, interceptors?: Interceptor[]) {\n";
  content += "    this._config = getConfigFromOpts(config);\n";
  content += "    this._interceptors = interceptors || [];\n";
  content += "\n";
  content += "    // Create the gRPC-Web transport with interceptors\n";
  content += "    const transport = createGrpcWebTransport({\n";
  content += "      baseUrl: this._config.apiServerURL,\n";
  content += "      interceptors: this._interceptors,\n";
  content += "      // Enable credentials (cookies) for cross-origin requests\n";
  content += "      fetch: (input, init) => globalThis.fetch(input, { ...init, credentials: 'include' }),\n";
  content += "    });\n";
  content += "\n";
  content += "    // Construct the Connect-ES client\n";
  content += `    this._client = createClient(${serviceName}, transport);\n`;
  content += "  }\n";
  content += "\n";

  // Generate withGroup method
  content += "  /**\n";
  content += "   * Returns a new client instance configured to send the specified group\n";
  content += "   * resource name in the request headers for subsequent API calls.\n";
  content += "   * \n";
  content += "   * @param {string} group - The operating group context to inject into the request\n";
  content += "   *                         in the format \`groups/{ulid}\` where {ulid} is a 26-character ULID.\n";
  content += "   *                         Example: 'groups/01ARZ3NDEKTSV4YWVF8F5BH32'\n";
  content += `   * @returns {${clientClassName}} A new, configured instance of the client.\n`;
  content += "   * @throws {Error} If the group format is invalid (validation occurs in createGroupInterceptor)\n";
  content += "   */\n";
  content += `  withGroup(group: string): ${clientClassName} {\n`;
  content += "    // Check if a group interceptor already exists.\n";
  content += "    // Group interceptors are identified by having a 'groupContext' property\n";
  content += "    const hasGroupInterceptor = this._interceptors.some(\n";
  content += "      (interceptor: any) => interceptor.groupContext !== undefined\n";
  content += "    );\n";
  content += "\n";
  content += "    if (hasGroupInterceptor) {\n";
  content += "      throw new Error(\n";
  content += '        "Attempted to set group context twice. A group has already been set for this client instance."\n';
  content += "      );\n";
  content += "    }\n";
  content += "\n";
  content += "    // Create a new interceptor for the group context\n";
  content += "    const groupInterceptor = createGroupInterceptor(group);\n";
  content += "\n";
  content += "    // Return a new client instance with the existing interceptors plus the new one\n";
  content += `    return new ${clientClassName}(\n`;
  content += "      this._config,\n";
  content += "      [\n";
  content += "        ...this._interceptors,\n";
  content += "        groupInterceptor,\n";
  content += "      ],\n";
  content += "    );\n";
  content += "  }\n";
  content += "\n";

  // Generate method wrappers for each service method
  for (const method of service.methods) {
    content += generateServiceMethodString(method, service, resourceName);
  }

  content += "}\n";

  return content;
}

function generateStreamingMethodString(
  method: DescMethod,
  methodName: string,
  requestType: string,
  responseType: string,
  resourceName: string
): string {
  let content = "";

  // Generate method JSDoc
  content += "  /**\n";
  content += `   * ${getMethodDescription(method.name, resourceName)}\n`;
  content += `   * Server-side streaming method with client-side validation and authentication.\n`;
  content += `   * @param {${requestType}} request - The request object for ${method.name.toLowerCase()}.\n`;
  content += `   * @returns {AsyncIterable<${responseType}>} An async iterable of ${responseType} messages.\n`;
  content += `   * @throws {Error} If request validation fails.\n`;
  content += "   * \n";
  content += "   * @example\n";
  content += `   * const stream = client.${methodName}(request);\n`;
  content += "   * for await (const response of stream) {\n";
  content += "   *   // Process each response\n";
  content += "   *   console.log(response);\n";
  content += "   * }\n";
  content += "   */\n";

  // Generate method signature and implementation with validation
  content += `  ${methodName}(request: ${requestType}): AsyncIterable<${responseType}> {\n`;
  content += "    // Validate request before initiating stream\n";
  content += "    validateRequest(request);\n";
  content += "\n";
  content += `    return this._client.${methodName}(request);\n`;
  content += "  }\n";
  content += "\n";

  return content;
}

function generateServiceMethodString(method: DescMethod, service: DescService, resourceName: string): string {
  const methodName = camelCase(method.name);
  const requestType = method.input.name;
  const responseType = method.output.name;

  // Detect server-side streaming
  const isServerStreaming = method.methodKind === "server_streaming";

  let content = "";

  if (isServerStreaming) {
    return generateStreamingMethodString(method, methodName, requestType, responseType, resourceName);
  }

  // Generate method JSDoc
  content += "  /**\n";
  content += `   * ${getMethodDescription(method.name, resourceName)}\n`;
  content += `   * @param {${requestType}} request - The request object for ${method.name.toLowerCase()}.\n`;
  content += `   * @returns {Promise<${responseType}>} A promise that resolves with the ${getMethodReturnDescription(method.name, resourceName)}.\n`;
  content += "   */\n";

  // Generate method signature and implementation
  content += `  ${methodName}(request: ${requestType}): Promise<${responseType}> {\n`;
  content += "    // Validate request\n";
  content += "    validateRequest(request);\n";
  content += "\n";
  content += `    return this._client.${methodName}(request);\n`;
  content += "  }\n";
  content += "\n";

  return content;
}

function camelCase(str: string): string {
  return str.charAt(0).toLowerCase() + str.slice(1);
}

function getMethodDescription(methodName: string, resourceName: string): string {
  const method = methodName.toLowerCase();
  const resource = toReadableResourceName(resourceName);

  if (method.startsWith('get')) {
    return `Retrieves ${getArticle(resource)} ${resource}.`;
  } else if (method.startsWith('create')) {
    return `Creates a new ${resource}.`;
  } else if (method.startsWith('update')) {
    return `Updates an existing ${resource}.`;
  } else if (method.startsWith('delete')) {
    return `Deletes ${getArticle(resource)} ${resource}.`;
  } else if (method.startsWith('list')) {
    return `Retrieves a list of ${resource}s.`;
  } else if (method.startsWith('search')) {
    return `Searches for ${resource}s.`;
  } else if (method.startsWith('activate')) {
    return `Activates ${getArticle(resource)} ${resource}.`;
  } else if (method.startsWith('deactivate')) {
    return `Deactivates ${getArticle(resource)} ${resource}.`;
  } else {
    return `Performs ${method} operation on ${resource}.`;
  }
}

function getMethodReturnDescription(methodName: string, resourceName: string): string {
  const method = methodName.toLowerCase();
  const resource = toReadableResourceName(resourceName);

  if (method.startsWith('list')) {
    return `list of ${resource}s`;
  } else if (method.startsWith('search')) {
    return 'search results';
  } else {
    return resource;
  }
}

function toReadableResourceName(resourceName: string): string {
  // Convert PascalCase to readable format, e.g., "ApiUser" -> "API user"
  return resourceName
    .replace(/([A-Z])([a-z])/g, '$1$2')  // Add space before capital followed by lowercase
    .replace(/([a-z])([A-Z])/g, '$1 $2') // Add space between lowercase and capital
    .toLowerCase();
}

function getArticle(word: string): string {
  // Return appropriate article (a/an) based on first letter
  const firstLetter = word.charAt(0).toLowerCase();
  return ['a', 'e', 'i', 'o', 'u'].includes(firstLetter) ? 'an' : 'a';
}

function convertToSnakeCase(str: string): string {
  // Convert PascalCase to snake_case: "APIUser" -> "api_user"
  return str
    .replace(/([A-Z]+)([A-Z][a-z])/g, '$1_$2')  // Handle sequences like "API" -> "API_"
    .replace(/([a-z\d])([A-Z])/g, '$1_$2')      // Handle transitions like "aB" -> "a_B"
    .toLowerCase();
}
