import { DescFile, DescService, DescMethod } from "@bufbuild/protobuf";
import {
  createEcmaScriptPlugin,
  runNodeJs,
  type Schema,
} from "@bufbuild/protoplugin";
import * as fs from "fs";
import * as path from "path";

const plugin = createEcmaScriptPlugin({
  name: "protoc-gen-meshts",
  version: "v1",
  generateTs(schema: Schema) {
    // Loop through all Protobuf files in the schema to look for service definitions
    for (const file of schema.files) {
      if (file.services.length > 0) {
        // Generate a TypeScript Connect-ES client for each file with services
        generateConnectClientManually(schema, file);
      }
    }
  },
});

// Reads the schema from stdin, runs the plugin, and writes the generated files to stdout.
runNodeJs(plugin);

function generateConnectClientManually(schema: Schema, file: DescFile) {
  // Build the TypeScript content manually as a string
  let content = "";

  // Add file header
  content += `// @generated by protoc-gen-meshts v1\n`;
  content += `// @generated from file ${file.name}.proto (package ${file.proto.package}, syntax proto3)\n`;
  content += `/* eslint-disable */\n`;
  content += `\n`;

  // Generate imports for Connect-ES (Web)
  content += `import { createClient, type Client as ConnectClient, Interceptor } from "@connectrpc/connect";\n`;
  content += `import { createGrpcWebTransport } from "@connectrpc/connect-web";\n`;

  // Import the service schema from generated code
  for (const service of file.services) {
    const serviceName = service.name;
    content += `import { ${serviceName} } from "./service_pb";\n`;
  }

  // Import request/response types
  // Collect types defined in service_pb
  const serviceTypes = new Set<string>();
  const requestTypes = new Set<string>(); // Track request types separately for schema imports

  for (const service of file.services) {
    for (const method of service.methods) {
      // Request types defined in this service file
      if (method.input.file === file) {
        serviceTypes.add(method.input.name);
        requestTypes.add(method.input.name); // Track for schema import
      }

      // Response types defined in this service file
      if (method.output.file === file) {
        serviceTypes.add(method.output.name);
        // Note: Response types don't need schemas - we only validate requests
      }
    }
  }

  // Import types from service_pb (request/response messages defined in the service file)
  // Also import the Schema types for request types only (used for validation)
  if (serviceTypes.size > 0) {
    const sortedServiceTypes = Array.from(serviceTypes).sort();
    const importsWithSchemas: string[] = [];
    for (const type of sortedServiceTypes) {
      importsWithSchemas.push(type);
      // Only import Schema for request types, not response types
      if (requestTypes.has(type)) {
        importsWithSchemas.push(`${type}Schema`);
      }
    }
    content += `import {\n`;
    for (let i = 0; i < importsWithSchemas.length; i++) {
      content += `  ${importsWithSchemas[i]}${i < importsWithSchemas.length - 1 ? "," : ""}\n`;
    }
    content += `} from "./service_pb";\n`;
  }

  // Import types from their respective files
  // Group by source file to avoid duplicate imports
  const externalTypesByFile = new Map<string, Set<string>>();

  for (const service of file.services) {
    for (const method of service.methods) {
      // Check input type
      if (method.input.file !== file && !serviceTypes.has(method.input.name)) {
        const fileName = method.input.file.name;
        if (!externalTypesByFile.has(fileName)) {
          externalTypesByFile.set(fileName, new Set());
        }
        externalTypesByFile.get(fileName)!.add(method.input.name);
      }

      // Check output type
      if (
        method.output.file !== file &&
        !serviceTypes.has(method.output.name)
      ) {
        const fileName = method.output.file.name;
        if (!externalTypesByFile.has(fileName)) {
          externalTypesByFile.set(fileName, new Set());
        }
        externalTypesByFile.get(fileName)!.add(method.output.name);
      }
    }
  }

  // Generate imports for external types
  for (const [sourceFileName, types] of externalTypesByFile) {
    const sortedTypes = Array.from(types).sort();
    // Calculate relative path from current file to the external file
    const relativePath = calculateRelativeImportPath(file.name, sourceFileName);
    content += `import { ${sortedTypes.join(", ")} } from "${relativePath}";\n`;
  }

  // Generate imports for utilities with dynamic relative paths
  const outputFilePath = getOutputFilePath(file);
  const relativePathToMeshtrade = getRelativePathToMeshtrade(outputFilePath);
  content += `import { ClientOption, ClientConfig, buildConfigFromOptions, WithAPIKey, WithJWTAccessToken, WithGroup, WithServerUrl } from "${relativePathToMeshtrade}/config";\n`;
  content += `import { createValidator } from "@bufbuild/protovalidate";\n`;
  content += `import { createGroupInterceptor, createApiKeyInterceptor, createJwtInterceptor, createLoggingInterceptor } from "${relativePathToMeshtrade}/interceptors";\n`;
  content += `\n`;

  // Generate client class for each service
  for (const service of file.services) {
    content += generateServiceClientString(service, file);
  }

  // Write the TypeScript content to the file
  writeTypescriptFile(outputFilePath, content);
}

/**
 * Calculate the relative import path from one proto file to another.
 *
 * Example:
 * - From: "meshtrade/iam/api_user/v1/service"
 *   To: "meshtrade/iam/api_user/v1/api_user"
 *   -> Result: "./api_user_pb"
 */
function calculateRelativeImportPath(fromFile: string, toFile: string): string {
  const fromDir = path.dirname(fromFile);
  const toDir = path.dirname(toFile);
  const toBasename = path.basename(toFile);

  // Calculate relative path from fromDir to toDir
  const relativePath = path.relative(fromDir, toDir);

  // Construct the import path with _pb suffix
  const importPath = path.join(relativePath, toBasename + "_pb");

  // Ensure it starts with ./ or ../
  if (!importPath.startsWith(".")) {
    return "./" + importPath;
  }

  return importPath;
}

function getOutputFilePath(file: DescFile): string {
  // Convert protobuf file path to TypeScript Web output path
  // Example: "meshtrade/iam/api_user/v1/service.proto" -> "ts-web/src/meshtrade/iam/api_user/v1/service_web_meshts.ts"
  const protoPath = file.name; // e.g., "meshtrade/iam/api_user/v1/service"
  const outputDir = path.join("ts-web", "src", path.dirname(protoPath));
  const fileName = path.basename(protoPath) + "_web_meshts.ts";
  return path.join(outputDir, fileName);
}

function getRelativePathToMeshtrade(outputFilePath: string): string {
  // Calculate the relative path from the generated file to the ts-web/src/meshtrade root
  // Example: from "ts-web/src/meshtrade/iam/api_user/v1/service_web_meshts.ts"
  //          to "ts-web/src/meshtrade/" returns "../../../"
  const generatedFileDir = path.dirname(outputFilePath);
  const meshtradeDir = path.join("ts-web", "src", "meshtrade");
  return path.relative(generatedFileDir, meshtradeDir);
}

function writeTypescriptFile(filePath: string, content: string): void {
  try {
    // Ensure the directory exists
    const dir = path.dirname(filePath);
    fs.mkdirSync(dir, { recursive: true });

    // Write the TypeScript content to the file
    fs.writeFileSync(filePath, content, "utf8");

    console.error(`Generated TypeScript Connect client: ${filePath}`);
  } catch (error) {
    console.error(`Failed to write TypeScript file: ${filePath}`, error);
    throw error;
  }
}

function generateServiceClientString(
  service: DescService,
  file: DescFile,
): string {
  const serviceName = service.name;
  const clientClassName = `${serviceName}Web`;

  // Extract resource name from the service (e.g., ApiUser from ApiUserService)
  const resourceName = serviceName.replace(/Service$/, "");

  let content = "";

  // Generate class JSDoc
  content += "/**\n";
  content += ` * Web client for interacting with the ${file.proto.package} ${toReadableResourceName(resourceName)} v1 API resource service.\n`;
  content +=
    " * Uses Connect-ES with gRPC-Web transport for browser-based communication.\n";
  content += " *\n";
  content +=
    " * Supports flexible authentication modes using functional options pattern:\n";
  content += " *\n";
  content += " * 1. **No Authentication** (public APIs):\n";
  content += " *    ```typescript\n";
  content += ` *    const client = new ${clientClassName}(\n`;
  content += ' *      WithServerUrl("http://localhost:10000")\n';
  content += " *    );\n";
  content += " *    ```\n";
  content += " *\n";
  content += " * 2. **API Key Authentication** (backend services):\n";
  content += " *    ```typescript\n";
  content += ` *    const client = new ${clientClassName}(\n`;
  content += ' *      WithAPIKey("your-api-key"),\n';
  content += ' *      WithGroup("groups/01ARZ3NDEKTSV4YWVF8F5BH32"),\n';
  content += ' *      WithServerUrl("https://api.example.com")\n';
  content += " *    );\n";
  content += " *    ```\n";
  content += " *\n";
  content +=
    " * 3. **JWT Token Authentication** (Next.js frontend with user session):\n";
  content += " *    ```typescript\n";
  content += ` *    const client = new ${clientClassName}(\n`;
  content +=
    ' *      WithJWTAccessToken("eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."),\n';
  content += ' *      WithServerUrl("https://api.example.com")\n';
  content += " *    );\n";
  content += " *    ```\n";
  content += " *\n";
  content +=
    " * 4. **JWT with Group Context** (user session with specific group):\n";
  content += " *    ```typescript\n";
  content += ` *    const client = new ${clientClassName}(\n`;
  content +=
    ' *      WithJWTAccessToken("eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."),\n';
  content += ' *      WithGroup("groups/01ARZ3NDEKTSV4YWVF8F5BH32"),\n';
  content += ' *      WithServerUrl("https://api.example.com")\n';
  content += " *    );\n";
  content += " *    ```\n";
  content += " *\n";
  content += " * Available options:\n";
  content +=
    " * - `WithAPIKey(key)` - API key authentication (mutually exclusive with JWT)\n";
  content +=
    " * - `WithJWTAccessToken(token)` - JWT authentication (mutually exclusive with API key)\n";
  content +=
    " * - `WithGroup(group)` - Group context (optional, works with both auth modes)\n";
  content +=
    " * - `WithServerUrl(url)` - Custom server URL (optional, defaults to production)\n";
  content += " */\n";

  // Generate class declaration
  content += `export class ${clientClassName} {\n`;
  content += `  private _client: ConnectClient<typeof ${serviceName}>;\n`;
  content += `  private readonly _config: ClientConfig;\n`;
  content += `  private readonly _interceptors: Interceptor[];\n`;
  content += `  private readonly _validator: ReturnType<typeof createValidator>;\n`;
  content += "\n";

  // Generate constructor
  content += "  /**\n";
  content += `   * Constructs an instance of ${clientClassName}.\n`;
  content += "   *\n";
  content +=
    "   * Uses functional options pattern for flexible configuration:\n";
  content += "   * - `WithAPIKey(key)` - API key authentication\n";
  content += "   * - `WithJWTAccessToken(token)` - JWT authentication\n";
  content += "   * - `WithGroup(group)` - Group context (optional)\n";
  content += "   * - `WithServerUrl(url)` - Custom server URL (optional)\n";
  content += "   *\n";
  content +=
    "   * @param {...ClientOption} opts - Variable number of configuration options\n";
  content += "   */\n";
  content += "  constructor(...opts: ClientOption[]) {\n";
  content += "    // Build configuration from options\n";
  content += "    this._config = buildConfigFromOptions(...opts);\n";
  content += "\n";
  content += "    // Initialize validator for request validation\n";
  content += "    this._validator = createValidator();\n";
  content += "\n";
  content += "    this._interceptors = [];\n";
  content += "\n";
  content += "    this._interceptors.push(createLoggingInterceptor());\n";
  content += "\n";
  content += "    if (this._config.apiKey) {\n";
  content +=
    "      this._interceptors.push(createApiKeyInterceptor(this._config.apiKey));\n";
  content += "    }\n";
  content += "\n";
  content += "    if (this._config.jwtToken) {\n";
  content +=
    "      this._interceptors.push(createJwtInterceptor(this._config.jwtToken));\n";
  content += "    }\n";
  content += "\n";
  content += "    if (this._config.group) {\n";
  content +=
    "      this._interceptors.push(createGroupInterceptor(this._config.group));\n";
  content += "    }\n";
  content += "\n";
  content += "    // Create the gRPC-Web transport for browser with interceptors\n";
  content += "    const transport = createGrpcWebTransport({\n";
  content += "      baseUrl: this._config.apiServerURL,\n";
  content += "      interceptors: this._interceptors,\n";
  content += "    });\n";
  content += "\n";
  content += "    // Construct the Connect-ES client\n";
  content += `    this._client = createClient(${serviceName}, transport);\n`;
  content += "  }\n";
  content += "\n";

  // Generate withGroup method
  content += "  /**\n";
  content +=
    "   * Returns a new client instance configured to send the specified group\n";
  content +=
    "   * resource name in the request headers for subsequent API calls.\n";
  content += "   *\n";
  content +=
    "   * This method creates a new client with the same authentication configuration\n";
  content +=
    "   * but with the group context updated to the specified value.\n";
  content += "   *\n";
  content += "   * **Compatibility**: Works with all authentication modes:\n";
  content +=
    "   * - **API key auth**: Creates new client with API key + new group\n";
  content += "   * - **JWT auth**: Creates new client with JWT + new group\n";
  content +=
    "   * - **No auth**: Creates new client with standalone group interceptor\n";
  content += "   * \n";
  content +=
    "   * @param {string} group - The operating group context to inject into the request\n";
  content +=
    "   *                         in the format `groups/{ulid}` where {ulid} is a 26-character ULID.\n";
  content +=
    "   *                         Example: 'groups/01ARZ3NDEKTSV4YWVF8F5BH32'\n";
  content += `   * @returns {${clientClassName}} A new, configured instance of the client.\n`;
  content += "   * @throws {Error} If the group format is invalid\n";
  content += "   */\n";
  content += `  withGroup(group: string): ${clientClassName} {\n`;
  content +=
    "    // Build new options array with existing auth and updated group\n";
  content += "    const newOpts: ClientOption[] = [];\n";
  content += "\n";
  content += "    // Add server URL\n";
  content += "    newOpts.push(WithServerUrl(this._config.apiServerURL));\n";
  content += "\n";
  content += "    // Add authentication (preserve existing mode)\n";
  content += "    if (this._config.apiKey) {\n";
  content += "      newOpts.push(WithAPIKey(this._config.apiKey));\n";
  content += "    } else if (this._config.jwtToken) {\n";
  content += "      newOpts.push(WithJWTAccessToken(this._config.jwtToken));\n";
  content += "    }\n";
  content += "\n";
  content += "    // Add the new group\n";
  content += "    newOpts.push(WithGroup(group));\n";
  content += "\n";
  content += "    // Return a new client instance with updated configuration\n";
  content += `    return new ${clientClassName}(...newOpts);\n`;
  content += "  }\n";
  content += "\n";

  // Generate method wrappers for each service method
  for (const method of service.methods) {
    content += generateServiceMethodString(method, service, resourceName);
  }

  content += "}\n";

  return content;
}

function generateStreamingMethodString(
  method: DescMethod,
  methodName: string,
  requestType: string,
  responseType: string,
  resourceName: string,
): string {
  let content = "";

  // Generate method JSDoc
  content += "  /**\n";
  content += `   * ${getMethodDescription(method.name, resourceName)}\n`;
  content += `   * Server-side streaming method with client-side validation and authentication.\n`;
  content += `   * @param {${requestType}} request - The request object for ${method.name.toLowerCase()}.\n`;
  content += `   * @returns {AsyncIterable<${responseType}>} An async iterable of ${responseType} messages.\n`;
  content += `   * @throws {Error} If request validation fails.\n`;
  content += "   * \n";
  content += "   * @example\n";
  content += `   * const stream = client.${methodName}(request);\n`;
  content += "   * for await (const response of stream) {\n";
  content += "   *   // Process each response\n";
  content += "   *   console.log(response);\n";
  content += "   * }\n";
  content += "   */\n";

  // Generate method signature and implementation with validation
  content += `  ${methodName}(request: ${requestType}): AsyncIterable<${responseType}> {\n`;
  content += "    // Validate request before initiating stream\n";
  content += `    const result = this._validator.validate(${requestType}Schema, request);\n`;
  content += '    if (result.kind === "invalid") {\n';
  content += '      const violations = result.violations.map(v => `${v.field.toString()}: ${v.message}`).join("; ");\n';
  content += '      throw new Error(`Validation failed: ${violations}`);\n';
  content += '    } else if (result.kind === "error") {\n';
  content += "      throw result.error;\n";
  content += "    }\n";
  content += "\n";
  content += `    return this._client.${methodName}(request);\n`;
  content += "  }\n";
  content += "\n";

  return content;
}

function generateServiceMethodString(
  method: DescMethod,
  service: DescService,
  resourceName: string,
): string {
  const methodName = camelCase(method.name);
  const requestType = method.input.name;
  const responseType = method.output.name;

  // Detect server-side streaming
  const isServerStreaming = method.methodKind === "server_streaming";

  let content = "";

  if (isServerStreaming) {
    return generateStreamingMethodString(
      method,
      methodName,
      requestType,
      responseType,
      resourceName,
    );
  }

  // Generate method JSDoc
  content += "  /**\n";
  content += `   * ${getMethodDescription(method.name, resourceName)}\n`;
  content += `   * @param {${requestType}} request - The request object for ${method.name.toLowerCase()}.\n`;
  content += `   * @returns {Promise<${responseType}>} A promise that resolves with the ${getMethodReturnDescription(method.name, resourceName)}.\n`;
  content += "   */\n";

  // Generate method signature and implementation
  content += `  ${methodName}(request: ${requestType}): Promise<${responseType}> {\n`;
  content += "    // Validate request\n";
  content += `    const result = this._validator.validate(${requestType}Schema, request);\n`;
  content += '    if (result.kind === "invalid") {\n';
  content += '      const violations = result.violations.map(v => `${v.field.toString()}: ${v.message}`).join("; ");\n';
  content += '      throw new Error(`Validation failed: ${violations}`);\n';
  content += '    } else if (result.kind === "error") {\n';
  content += "      throw result.error;\n";
  content += "    }\n";
  content += "\n";
  content += `    return this._client.${methodName}(request);\n`;
  content += "  }\n";
  content += "\n";

  return content;
}

function camelCase(str: string): string {
  return str.charAt(0).toLowerCase() + str.slice(1);
}

function getMethodDescription(
  methodName: string,
  resourceName: string,
): string {
  const method = methodName.toLowerCase();
  const resource = toReadableResourceName(resourceName);

  if (method.startsWith("get")) {
    return `Retrieves ${getArticle(resource)} ${resource}.`;
  } else if (method.startsWith("create")) {
    return `Creates a new ${resource}.`;
  } else if (method.startsWith("update")) {
    return `Updates an existing ${resource}.`;
  } else if (method.startsWith("delete")) {
    return `Deletes ${getArticle(resource)} ${resource}.`;
  } else if (method.startsWith("list")) {
    return `Retrieves a list of ${resource}s.`;
  } else if (method.startsWith("search")) {
    return `Searches for ${resource}s.`;
  } else if (method.startsWith("activate")) {
    return `Activates ${getArticle(resource)} ${resource}.`;
  } else if (method.startsWith("deactivate")) {
    return `Deactivates ${getArticle(resource)} ${resource}.`;
  } else {
    return `Performs ${method} operation on ${resource}.`;
  }
}

function getMethodReturnDescription(
  methodName: string,
  resourceName: string,
): string {
  const method = methodName.toLowerCase();
  const resource = toReadableResourceName(resourceName);

  if (method.startsWith("list")) {
    return `list of ${resource}s`;
  } else if (method.startsWith("search")) {
    return "search results";
  } else {
    return resource;
  }
}

function toReadableResourceName(resourceName: string): string {
  // Convert PascalCase to readable format, e.g., "ApiUser" -> "API user"
  return resourceName
    .replace(/([A-Z])([a-z])/g, "$1$2") // Add space before capital followed by lowercase
    .replace(/([a-z])([A-Z])/g, "$1 $2") // Add space between lowercase and capital
    .toLowerCase();
}

function getArticle(word: string): string {
  // Return appropriate article (a/an) based on first letter
  const firstLetter = word.charAt(0).toLowerCase();
  return ["a", "e", "i", "o", "u"].includes(firstLetter) ? "an" : "a";
}
