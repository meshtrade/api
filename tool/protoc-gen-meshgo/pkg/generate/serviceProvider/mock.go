package serviceProvider

import (
	"slices"

	"github.com/meshtrade/api/tool/protoc-gen-meshgo/pkg/generate"
	"google.golang.org/protobuf/compiler/protogen"
)

func Mock(p *protogen.Plugin, f *protogen.File, svc *protogen.Service) error {
	serviceProviderName := svc.GoName
	// generate a new go file for the clean svc interface
	g := p.NewGeneratedFile(
		GenerateFilename(f.Desc.Path(), "Mock"),
		f.GoImportPath,
	)

	// get mock svc provider name
	mockServiceProviderName := "Mock" + serviceProviderName
	clientInterfaceName := serviceProviderName + "ClientInterface"
	streaming := slices.ContainsFunc(svc.Methods, func(method *protogen.Method) bool {
		return isServerSideStreaming(method)
	})

	// add header
	g.P("// Code generated by protoc-gen-meshgo. DO NOT EDIT.")
	g.P("// source: ", f.Desc.Path())
	g.P("package ", f.GoPackageName)

	g.P()

	// Primary compile-time check: mock always implements ClientInterface
	g.P("// Ensure that ", mockServiceProviderName, " implements the ", clientInterfaceName, " interface")
	g.P("var _ ", clientInterfaceName, " = &", mockServiceProviderName, "{}")

	// For non-streaming services, the mock also naturally satisfies Service (identical unary signatures)
	if !streaming {
		g.P()
		g.P("// Ensure that ", mockServiceProviderName, " implements the ", serviceProviderName, " interface")
		g.P("var _ ", serviceProviderName, " = &", mockServiceProviderName, "{}")
	}

	g.P()

	// Start the mock struct
	g.P("// ", mockServiceProviderName, " is a mock implementation of the ", clientInterfaceName, " interface.")
	g.P("type ", mockServiceProviderName, " struct {")

	// add mutex and testing variable
	g.P("mutex ", generate.SyncPkg.Ident("Mutex"))
	g.P("T *", generate.TestingPkg.Ident("T"))

	// GroupValue field for all services
	g.P("GroupValue string")

	// add fields in the mock
	for _, method := range svc.Methods {
		// All methods use client-side signature
		if isServerSideStreaming(method) {
			streamClientType := svc.GoName + "_" + method.GoName + "Client"
			g.P(method.GoName, "Func func(t *", generate.TestingPkg.Ident("T"), ", m *", mockServiceProviderName, ", ctx ", generate.ContextPkg.Ident("Context"), ", request *", method.Input.GoIdent, ") (", streamClientType, ", error)")
		} else {
			g.P(method.GoName, "Func func(t *", generate.TestingPkg.Ident("T"), ", m *", mockServiceProviderName, ", ctx ", generate.ContextPkg.Ident("Context"), ", request *", method.Input.GoIdent, ") (*", method.Output.GoIdent, ", error)")
		}

		// add mock function invocations
		g.P(method.GoName, "FuncInvocations int")
	}

	// end the struct
	g.P("}")

	g.P()

	// Close, Group, and WithGroup methods for all services
	g.P("// Close is a no-op for the mock implementation.")
	g.P("func (m *", mockServiceProviderName, ") Close() error {")
	g.P("return nil")
	g.P("}")
	g.P()

	g.P("// Group returns the mock's configured group value.")
	g.P("func (m *", mockServiceProviderName, ") Group() string {")
	g.P("return m.GroupValue")
	g.P("}")
	g.P()

	g.P("// WithGroup returns a shallow copy of the mock with the given group value.")
	g.P("func (m *", mockServiceProviderName, ") WithGroup(group string) ", clientInterfaceName, " {")
	g.P("return &", mockServiceProviderName, "{")
	g.P("T: m.T,")
	g.P("GroupValue: group,")
	for _, method := range svc.Methods {
		g.P(method.GoName, "Func: m.", method.GoName, "Func,")
	}
	g.P("}")
	g.P("}")
	g.P()

	// write the mock svc provider receivers
	for i, method := range svc.Methods {
		// All methods use client-side signature
		if isServerSideStreaming(method) {
			streamClientType := svc.GoName + "_" + method.GoName + "Client"
			g.P("func (m *", mockServiceProviderName, ") ", method.GoName, "(ctx ", generate.ContextPkg.Ident("Context"), ", request *", method.Input.GoIdent, ") (", streamClientType, ", error) {")
		} else {
			g.P("func (m *", mockServiceProviderName, ") ", method.GoName, "(ctx ", generate.ContextPkg.Ident("Context"), ", request *", method.Input.GoIdent, ") (*", method.Output.GoIdent, ", error) {")
		}
		g.P("m.mutex.Lock()")
		g.P("m.", method.GoName, "FuncInvocations++")
		g.P("m.mutex.Unlock()")
		g.P("if m.", method.GoName, "Func == nil {")
		g.P("return nil, nil")
		g.P("}")
		g.P("return m.", method.GoName, "Func(m.T, m, ctx, request)")
		g.P("}")

		if i != len(svc.Methods)-1 {
			g.P()
		}
	}

	return nil
}
