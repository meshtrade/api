package serviceProvider

import (
	"slices"

	"github.com/meshtrade/api/tool/protoc-gen-meshgo/pkg/generate"
	"google.golang.org/protobuf/compiler/protogen"
)

// hasStreamingMethods returns true if any method in the service uses server-side streaming.
func hasStreamingMethods(svc *protogen.Service) bool {
	return slices.ContainsFunc(svc.Methods, func(method *protogen.Method) bool {
		return isServerSideStreaming(method)
	})
}

func Mock(p *protogen.Plugin, f *protogen.File, svc *protogen.Service) error {
	serviceProviderName := svc.GoName
	// generate a new go file for the clean svc interface
	g := p.NewGeneratedFile(
		GenerateFilename(f.Desc.Path(), "Mock"),
		f.GoImportPath,
	)

	// get mock svc provider name
	mockServiceProviderName := "Mock" + serviceProviderName
	clientInterfaceName := serviceProviderName + "ClientInterface"
	streaming := hasStreamingMethods(svc)

	// add header
	g.P("// Code generated by protoc-gen-meshgo. DO NOT EDIT.")
	g.P("// source: ", f.Desc.Path())
	g.P("package ", f.GoPackageName)

	g.P()

	// add compile time interface implementation check
	g.P("// Ensure that ", mockServiceProviderName, " implements the ", serviceProviderName, " interface")
	g.P("var _ ", serviceProviderName, " = &", mockServiceProviderName, "{}")

	// For non-streaming services, also implement ClientInterface
	if !streaming {
		g.P()
		g.P("// Ensure that ", mockServiceProviderName, " implements the ", clientInterfaceName, " interface")
		g.P("var _ ", clientInterfaceName, " = &", mockServiceProviderName, "{}")
	}

	g.P()

	// Start the mock struct
	g.P("// ", mockServiceProviderName, " is a mock implementation of the ", serviceProviderName, " interface.")
	if !streaming {
		g.P("// It also implements ", clientInterfaceName, " for use in tests that depend on the client interface.")
	}
	g.P("type ", mockServiceProviderName, " struct {")

	// add mutex and testing variable
	g.P("mutex ", generate.SyncPkg.Ident("Mutex"))
	g.P("T *", generate.TestingPkg.Ident("T"))

	// For non-streaming services, add GroupValue field
	if !streaming {
		g.P("GroupValue string")
	}

	// add fields in the mock
	for _, method := range svc.Methods {
		// add mock function pointer - different signature for streaming
		if isServerSideStreaming(method) {
			streamInterfaceName := svc.GoName + "_" + method.GoName + "Stream"
			g.P(method.GoName, "Func func(t *", generate.TestingPkg.Ident("T"), ", m *", mockServiceProviderName, ", ctx ", generate.ContextPkg.Ident("Context"), ", request *", method.Input.GoIdent, ", stream ", streamInterfaceName, ") error")
		} else {
			g.P(method.GoName, "Func func(t *", generate.TestingPkg.Ident("T"), ", m *", mockServiceProviderName, ", ctx ", generate.ContextPkg.Ident("Context"), ", request *", method.Input.GoIdent, ") (*", method.Output.GoIdent, ", error)")
		}

		// add mock function invocations
		g.P(method.GoName, "FuncInvocations int")
	}

	// end the struct
	g.P("}")

	g.P()

	// For non-streaming services, generate Close, Group, and WithGroup methods
	if !streaming {
		g.P("// Close is a no-op for the mock implementation.")
		g.P("func (m *", mockServiceProviderName, ") Close() error {")
		g.P("return nil")
		g.P("}")
		g.P()

		g.P("// Group returns the mock's configured group value.")
		g.P("func (m *", mockServiceProviderName, ") Group() string {")
		g.P("return m.GroupValue")
		g.P("}")
		g.P()

		g.P("// WithGroup returns a shallow copy of the mock with the given group value.")
		g.P("func (m *", mockServiceProviderName, ") WithGroup(group string) ", clientInterfaceName, " {")
		g.P("return &", mockServiceProviderName, "{")
		g.P("T: m.T,")
		g.P("GroupValue: group,")
		for _, method := range svc.Methods {
			g.P(method.GoName, "Func: m.", method.GoName, "Func,")
		}
		g.P("}")
		g.P("}")
		g.P()
	}

	// write the mock svc provider receivers
	for i, method := range svc.Methods {
		// Different signature for streaming vs unary
		if isServerSideStreaming(method) {
			streamInterfaceName := svc.GoName + "_" + method.GoName + "Stream"
			g.P("func (m *", mockServiceProviderName, ") ", method.GoName, "(ctx ", generate.ContextPkg.Ident("Context"), ", request *", method.Input.GoIdent, ", stream ", streamInterfaceName, ") error {")
		} else {
			g.P("func (m *", mockServiceProviderName, ") ", method.GoName, "(ctx ", generate.ContextPkg.Ident("Context"), ", request *", method.Input.GoIdent, ") (*", method.Output.GoIdent, ", error) {")
		}
		g.P("m.mutex.Lock()")
		g.P("m.", method.GoName, "FuncInvocations++")
		g.P("m.mutex.Unlock()")
		g.P("if m.", method.GoName, "Func == nil {")
		// Return appropriate zero values based on method type
		if isServerSideStreaming(method) {
			g.P("return nil") // streaming methods return just error
		} else {
			g.P("return nil, nil") // unary methods return (response, error)
		}
		g.P("}")
		// Pass stream parameter only for streaming methods
		if isServerSideStreaming(method) {
			g.P("return m.", method.GoName, "Func(m.T, m, ctx, request, stream)")
		} else {
			g.P("return m.", method.GoName, "Func(m.T, m, ctx, request)")
		}
		g.P("}")

		if i != len(svc.Methods)-1 {
			g.P()
		}
	}

	return nil
}
