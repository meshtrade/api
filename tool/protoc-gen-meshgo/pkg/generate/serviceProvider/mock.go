package serviceProvider

import (
	"github.com/meshtrade/api/tool/protoc-gen-meshgo/pkg/generate"
	"google.golang.org/protobuf/compiler/protogen"
)

func Mock(p *protogen.Plugin, f *protogen.File, svc *protogen.Service) error {
	serviceProviderName := svc.GoName
	// generate a new go file for the clean svc interface
	g := p.NewGeneratedFile(
		GenerateFilename(f.Desc.Path(), "Mock"),
		f.GoImportPath,
	)

	// get mock svc provider name
	mockServiceProviderName := "Mock" + serviceProviderName

	// add header
	g.P("// Code generated by protoc-gen-meshgo. DO NOT EDIT.")
	g.P("// source: ", f.Desc.Path())
	g.P("package ", f.GoPackageName)

	g.P()

	// add compile time interface implementation check
	g.P("// Ensure that ", mockServiceProviderName, " implements the ", serviceProviderName, " interface")
	g.P("var _ ", serviceProviderName, " = &", mockServiceProviderName, "{}")

	g.P()

	// Start the mock struct
	g.P("// ", mockServiceProviderName, " is a mock implementation of the ", serviceProviderName, " interface.")
	g.P("type ", mockServiceProviderName, " struct {")

	// add mutex and testing variable
	g.P("mutex ", generate.SyncPkg.Ident("Mutex"))
	g.P("T *", generate.TestingPkg.Ident("T"))

	// add fields in the mock
	for _, method := range svc.Methods {
		// add mock function pointer - different signature for streaming
		if isServerSideStreaming(method) {
			streamInterfaceName := svc.GoName + "_" + method.GoName + "Stream"
			g.P(method.GoName, "Func func(t *", generate.TestingPkg.Ident("T"), ", m *", mockServiceProviderName, ", ctx ", generate.ContextPkg.Ident("Context"), ", request *", method.Input.GoIdent, ", stream ", streamInterfaceName, ") error")
		} else {
			g.P(method.GoName, "Func func(t *", generate.TestingPkg.Ident("T"), ", m *", mockServiceProviderName, ", ctx ", generate.ContextPkg.Ident("Context"), ", request *", method.Input.GoIdent, ") (*", method.Output.GoIdent, ", error)")
		}

		// add mock function invocations
		g.P(method.GoName, "FuncInvocations int")
	}

	// end the struct
	g.P("}")

	g.P()

	// write the mock svc provider receivers
	for i, method := range svc.Methods {
		// Different signature for streaming vs unary
		if isServerSideStreaming(method) {
			streamInterfaceName := svc.GoName + "_" + method.GoName + "Stream"
			g.P("func (m *", mockServiceProviderName, ") ", method.GoName, "(ctx ", generate.ContextPkg.Ident("Context"), ", request *", method.Input.GoIdent, ", stream ", streamInterfaceName, ") error {")
		} else {
			g.P("func (m *", mockServiceProviderName, ") ", method.GoName, "(ctx ", generate.ContextPkg.Ident("Context"), ", request *", method.Input.GoIdent, ") (*", method.Output.GoIdent, ", error) {")
		}
		g.P("m.mutex.Lock()")
		g.P("m.", method.GoName, "FuncInvocations++")
		g.P("m.mutex.Unlock()")
		g.P("if m.", method.GoName, "Func == nil {")
		// Return appropriate zero values based on method type
		if isServerSideStreaming(method) {
			g.P("return nil") // streaming methods return just error
		} else {
			g.P("return nil, nil") // unary methods return (response, error)
		}
		g.P("}")
		// Pass stream parameter only for streaming methods
		if isServerSideStreaming(method) {
			g.P("return m.", method.GoName, "Func(m.T, m, ctx, request, stream)")
		} else {
			g.P("return m.", method.GoName, "Func(m.T, m, ctx, request)")
		}
		g.P("}")

		if i != len(svc.Methods)-1 {
			g.P()
		}
	}

	return nil
}
