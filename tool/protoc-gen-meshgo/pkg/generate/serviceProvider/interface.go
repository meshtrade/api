package serviceProvider

import (
	"fmt"
	"strings"

	"github.com/meshtrade/api/tool/protoc-gen-meshgo/pkg/generate"

	"google.golang.org/protobuf/compiler/protogen"
)

// isServerSideStreaming returns true if the method is server-side streaming
func isServerSideStreaming(method *protogen.Method) bool {
	return method.Desc.IsStreamingServer() && !method.Desc.IsStreamingClient()
}

// generateStreamInterfaces generates custom stream interfaces for server-side streaming methods.
// These interfaces provide a transport-agnostic abstraction for sending responses to clients.
func generateStreamInterfaces(g *protogen.GeneratedFile, svc *protogen.Service) {
	for _, method := range svc.Methods {
		if !isServerSideStreaming(method) {
			continue
		}

		streamInterfaceName := svc.GoName + "_" + method.GoName + "Stream"

		// Generate stream interface godoc
		g.P("// ", streamInterfaceName, " is a transport-agnostic interface for server-side streaming.")
		g.P("// The service implementation uses this interface to send multiple responses to the client.")
		g.P("type ", streamInterfaceName, " interface {")

		// Generate Send method
		g.P("	// Send sends a ", method.Output.GoIdent, " to the client.")
		g.P("	// It can be called multiple times to stream responses.")
		g.P("	// Returns an error if the stream is closed or the client has disconnected.")
		g.P("	Send(*", method.Output.GoIdent, ") error")
		g.P()

		// Generate Context method
		g.P("	// Context returns the stream's context.")
		g.P("	// The context is canceled when the client disconnects or the deadline expires.")
		g.P("	Context() ", generate.ContextPkg.Ident("Context"))

		// Close interface
		g.P("}")
		g.P()
	}
}

func Interface(p *protogen.Plugin, f *protogen.File, svc *protogen.Service) error {
	// generate a new go file for the clean service interface
	g := p.NewGeneratedFile(
		GenerateFilename(f.Desc.Path(), "_interface"),
		f.GoImportPath,
	)

	// add header
	g.P("// Code generated by protoc-gen-meshgo. DO NOT EDIT.")
	g.P("// source: ", f.Desc.Path())
	g.P("package ", f.GoPackageName)

	// Generate stream interfaces for server-side streaming methods
	generateStreamInterfaces(g, svc)

	// Add interface comments
	if len(svc.Comments.Leading) > 0 {
		for comment := range strings.SplitSeq(strings.TrimSpace(svc.Comments.Leading.String()), "\n") {
			trimmedComment := strings.TrimSpace(comment)
			g.P(trimmedComment)
		}
	}

	// Start the interface
	g.P("type ", svc.GoName, " interface {")

	// add methods in the interface
	for i, method := range svc.Methods {
		// Add method comments
		if len(method.Comments.Leading) > 0 {
			for _, comment := range strings.Split(strings.TrimSpace(method.Comments.Leading.String()), "\n") {
				trimmedComment := strings.TrimSpace(comment)
				if trimmedComment != "" {
					g.P(trimmedComment)
				}
			}
		}

		// add method - different signature for streaming vs unary
		if isServerSideStreaming(method) {
			streamInterfaceName := svc.GoName + "_" + method.GoName + "Stream"
			g.P(method.GoName, "(ctx ", generate.ContextPkg.Ident("Context"), ", request *", method.Input.GoIdent, ", stream ", streamInterfaceName, ") error")
		} else {
			g.P(method.GoName, "(ctx ", generate.ContextPkg.Ident("Context"), ", request *", method.Input.GoIdent, ") (*", method.Output.GoIdent, ", error)")
		}

		// add spaces between methods
		if i != len(svc.Methods)-1 {
			g.P()
		}
	}

	// end the interface
	g.P("}")

	g.P()

	// process package name to generate tab separated package name path
	if f.Proto.Package == nil {
		return fmt.Errorf("proto package name is not set")
	}
	packageName := strings.ReplaceAll(*f.Proto.Package, ".", "-")

	// Generate the service provider name
	g.P("const ", svc.GoName, "ServiceProviderName = ", fmt.Sprintf("\"%s-%s\"", packageName, svc.GoName))

	g.P()

	return nil
}
