package serviceProvider

import (
	"fmt"
	"strings"

	"github.com/meshtrade/api/tool/protoc-gen-meshgo/pkg/generate"

	"google.golang.org/protobuf/compiler/protogen"
)

func Interface(p *protogen.Plugin, f *protogen.File, svc *protogen.Service) error {
	// generate a new go file for the clean service interface
	g := p.NewGeneratedFile(
		GenerateFilename(f.Desc.Path(), ""),
		f.GoImportPath,
	)

	// add header
	g.P("// Code generated by protoc-gen-meshgo. DO NOT EDIT.")
	g.P("// source: ", f.Desc.Path())
	g.P("package ", f.GoPackageName)

	// Add interface comments
	if len(svc.Comments.Leading) > 0 {
		for comment := range strings.SplitSeq(strings.TrimSpace(svc.Comments.Leading.String()), "\n") {
			trimmedComment := strings.TrimSpace(comment)
			g.P(trimmedComment)
		}
	}

	// Start the interface
	g.P("type ", svc.GoName, " interface {")

	// add methods in the interface
	for i, method := range svc.Methods {
		// Add method comments
		if len(method.Comments.Leading) > 0 {
			for _, comment := range strings.Split(strings.TrimSpace(method.Comments.Leading.String()), "\n") {
				trimmedComment := strings.TrimSpace(comment)
				if trimmedComment != "" {
					g.P(trimmedComment)
				}
			}
		}

		// add method
		g.P(method.GoName, "(ctx ", generate.ContextPkg.Ident("Context"), ", request *", method.Input.GoIdent, ") (*", method.Output.GoIdent, ", error)")

		// add spaces between methods
		if i != len(svc.Methods)-1 {
			g.P()
		}
	}

	// end the interface
	g.P("}")

	g.P()

	// process package name to generate tab separated package name path
	if f.Proto.Package == nil {
		return fmt.Errorf("proto package name is not set")
	}
	packageName := strings.ReplaceAll(*f.Proto.Package, ".", "-")

	// Generate the service provider name
	g.P("const ", svc.GoName, "ServiceProviderName = ", fmt.Sprintf("\"%s-%s\"", packageName, svc.GoName))

	g.P()

	return nil
}
