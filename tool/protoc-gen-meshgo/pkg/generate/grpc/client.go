package grpc

import (
	"strings"

	"github.com/meshtrade/api/tool/protoc-gen-meshgo/pkg/generate/serviceProvider"
	"google.golang.org/protobuf/compiler/protogen"
)

func Client(p *protogen.Plugin, f *protogen.File, svc *protogen.Service) error {
	// Generate options file first
	if err := generateOptionsFile(p, f, svc); err != nil {
		return err
	}

	// Generate main client file
	return generateClientFile(p, f, svc)
}

func generateOptionsFile(p *protogen.Plugin, f *protogen.File, svc *protogen.Service) error {
	optionsG := p.NewGeneratedFile(
		serviceProvider.GenerateFilename(f.Desc.Path(), "_grpc_client_options"),
		f.GoImportPath,
	)

	// Add header
	optionsG.P("// Code generated by protoc-gen-meshgo. DO NOT EDIT.")
	optionsG.P("// source: ", f.Desc.Path())
	optionsG.P("package ", f.GoPackageName)
	optionsG.P()

	// Add imports
	optionsG.P("import (")
	optionsG.P("\t\"time\"")
	optionsG.P()
	optionsG.P("\ttrace \"go.opentelemetry.io/otel/trace\"")
	optionsG.P(")")
	optionsG.P()

	clientStructName := strings.ToLower(string(svc.GoName[0])) + svc.GoName[1:] + "GRPCClient"
	optionTypeName := "ClientOption"

	// Generate ClientOption type
	optionsG.P("// ", optionTypeName, " is a functional option for configuring the ", svc.GoName, " gRPC client.")
	optionsG.P("// This pattern provides a clean, extensible way to configure the client with optional")
	optionsG.P("// parameters while maintaining backward compatibility and readability.")
	optionsG.P("type ", optionTypeName, " func(*", clientStructName, ")")
	optionsG.P()

	// Generate WithTLS option
	optionsG.P("// WithTLS configures whether to use TLS encryption for the gRPC connection.")
	optionsG.P("// When enabled (true), the client will establish a secure connection using TLS.")
	optionsG.P("// When disabled (false), the client will use an insecure connection.")
	optionsG.P("//")
	optionsG.P("// Default: true (secure connection)")
	optionsG.P("//")
	optionsG.P("// Example:")
	optionsG.P("//")
	optionsG.P("//\tclient, err := New", svc.GoName, "GRPCClient(")
	optionsG.P("//\t    WithTLS(true), // Enable TLS encryption")
	optionsG.P("//\t)")
	optionsG.P("func WithTLS(enabled bool) ", optionTypeName, " {")
	optionsG.P("\treturn func(c *", clientStructName, ") {")
	optionsG.P("\t\tc.tls = enabled")
	optionsG.P("\t}")
	optionsG.P("}")
	optionsG.P()

	// Generate WithAddress option
	optionsG.P("// WithAddress configures the server address (URL and port) for the gRPC connection.")
	optionsG.P("// This allows you to connect to different environments or custom deployments.")
	optionsG.P("//")
	optionsG.P("// Parameters:")
	optionsG.P("//   - url: The server hostname or IP address (e.g., \"api.example.com\", \"localhost\")")
	optionsG.P("//   - port: The server port number (e.g., 443 for HTTPS, 8080 for development)")
	optionsG.P("//")
	optionsG.P("// Default: Uses common.DefaultGRPCURL and common.DefaultGRPCPort")
	optionsG.P("//")
	optionsG.P("// Example:")
	optionsG.P("//")
	optionsG.P("//\tclient, err := New", svc.GoName, "GRPCClient(")
	optionsG.P("//\t    WithAddress(\"staging-api.example.com\", 443), // Connect to staging")
	optionsG.P("//\t)")
	optionsG.P("func WithAddress(url string, port int) ", optionTypeName, " {")
	optionsG.P("\treturn func(c *", clientStructName, ") {")
	optionsG.P("\t\tc.url = url")
	optionsG.P("\t\tc.port = port")
	optionsG.P("\t}")
	optionsG.P("}")
	optionsG.P()

	// Generate WithURL option
	optionsG.P("// WithURL configures only the server URL/hostname for the gRPC connection.")
	optionsG.P("// The port will remain unchanged (uses existing port or default).")
	optionsG.P("// Use WithAddress() if you need to set both URL and port together.")
	optionsG.P("//")
	optionsG.P("// Parameter:")
	optionsG.P("//   - url: The server hostname or IP address")
	optionsG.P("//")
	optionsG.P("// Example:")
	optionsG.P("//")
	optionsG.P("//\tclient, err := New", svc.GoName, "GRPCClient(")
	optionsG.P("//\t    WithURL(\"production-api.mesh.trade\"), // Use production server")
	optionsG.P("//\t)")
	optionsG.P("func WithURL(url string) ", optionTypeName, " {")
	optionsG.P("\treturn func(c *", clientStructName, ") {")
	optionsG.P("\t\tc.url = url")
	optionsG.P("\t}")
	optionsG.P("}")
	optionsG.P()

	// Generate WithPort option
	optionsG.P("// WithPort configures only the server port for the gRPC connection.")
	optionsG.P("// The URL will remain unchanged (uses existing URL or default).")
	optionsG.P("// Use WithAddress() if you need to set both URL and port together.")
	optionsG.P("//")
	optionsG.P("// Parameter:")
	optionsG.P("//   - port: The server port number")
	optionsG.P("//")
	optionsG.P("// Example:")
	optionsG.P("//")
	optionsG.P("//\tclient, err := New", svc.GoName, "GRPCClient(")
	optionsG.P("//\t    WithPort(9090), // Connect to port 9090")
	optionsG.P("//\t)")
	optionsG.P("func WithPort(port int) ", optionTypeName, " {")
	optionsG.P("\treturn func(c *", clientStructName, ") {")
	optionsG.P("\t\tc.port = port")
	optionsG.P("\t}")
	optionsG.P("}")
	optionsG.P()

	// Generate WithAPIKey option
	optionsG.P("// WithAPIKey configures API key authentication for the gRPC client.")
	optionsG.P("// The API key will be sent as a Bearer token in the Authorization header.")
	optionsG.P("// This is the primary authentication method for service-to-service communication.")
	optionsG.P("//")
	optionsG.P("// The API key takes precedence over access token cookies if both are configured.")
	optionsG.P("//")
	optionsG.P("// Parameter:")
	optionsG.P("//   - apiKey: The API key string (without \"Bearer \" prefix)")
	optionsG.P("//")
	optionsG.P("// Example:")
	optionsG.P("//")
	optionsG.P("//\tclient, err := New", svc.GoName, "GRPCClient(")
	optionsG.P("//\t    WithAPIKey(\"your-api-key-here\"),")
	optionsG.P("//\t)")
	optionsG.P("//")
	optionsG.P("// Note: Alternatively, you can set the MESH_API_KEY environment variable")
	optionsG.P("func WithAPIKey(apiKey string) ", optionTypeName, " {")
	optionsG.P("\treturn func(c *", clientStructName, ") {")
	optionsG.P("\t\tc.apiKey = apiKey")
	optionsG.P("\t}")
	optionsG.P("}")
	optionsG.P()

	// Generate WithAccessTokenCookie option
	optionsG.P("// WithAccessTokenCookie configures cookie-based authentication for the gRPC client.")
	optionsG.P("// The access token will be sent as a cookie in the Cookie header as \"AccessToken=value\".")
	optionsG.P("// This authentication method is typically used for user-facing applications.")
	optionsG.P("//")
	optionsG.P("// If both API key and access token cookie are configured, the API key takes precedence.")
	optionsG.P("//")
	optionsG.P("// Parameter:")
	optionsG.P("//   - accessToken: The access token string (without \"AccessToken=\" prefix)")
	optionsG.P("//")
	optionsG.P("// Example:")
	optionsG.P("//")
	optionsG.P("//\tclient, err := New", svc.GoName, "GRPCClient(")
	optionsG.P("//\t    WithAccessTokenCookie(\"your-access-token-here\"),")
	optionsG.P("//\t)")
	optionsG.P("func WithAccessTokenCookie(accessToken string) ", optionTypeName, " {")
	optionsG.P("\treturn func(c *", clientStructName, ") {")
	optionsG.P("\t\tc.accessTokenCookie = accessToken")
	optionsG.P("\t}")
	optionsG.P("}")
	optionsG.P()

	// Generate WithTracer option
	optionsG.P("// WithTracer configures OpenTelemetry distributed tracing for the gRPC client.")
	optionsG.P("// This enables observability and monitoring of API calls across service boundaries.")
	optionsG.P("// Each gRPC method call will create a trace span for tracking request flow.")
	optionsG.P("//")
	optionsG.P("// Parameter:")
	optionsG.P("//   - tracer: An OpenTelemetry tracer instance")
	optionsG.P("//")
	optionsG.P("// Default: Uses a no-op tracer (tracing disabled)")
	optionsG.P("//")
	optionsG.P("// Example:")
	optionsG.P("//")
	optionsG.P("//\ttracer := otel.Tracer(\"", strings.ToLower(svc.GoName), "-client\")")
	optionsG.P("//\tclient, err := New", svc.GoName, "GRPCClient(")
	optionsG.P("//\t    WithTracer(tracer),")
	optionsG.P("//\t)")
	optionsG.P("func WithTracer(tracer trace.Tracer) ", optionTypeName, " {")
	optionsG.P("\treturn func(c *", clientStructName, ") {")
	optionsG.P("\t\tc.tracer = tracer")
	optionsG.P("\t}")
	optionsG.P("}")
	optionsG.P()

	// Generate WithTimeout option
	optionsG.P("// WithTimeout configures the default timeout for all gRPC method calls.")
	optionsG.P("// This timeout applies to individual method calls and helps prevent hanging requests.")
	optionsG.P("// If a request takes longer than the specified timeout, it will be cancelled.")
	optionsG.P("//")
	optionsG.P("// The timeout is implemented using context.WithTimeout() for each method call.")
	optionsG.P("//")
	optionsG.P("// Parameter:")
	optionsG.P("//   - timeout: The maximum duration to wait for a method call to complete")
	optionsG.P("//")
	optionsG.P("// Default: 30 seconds")
	optionsG.P("//")
	optionsG.P("// Example:")
	optionsG.P("//")
	optionsG.P("//\tclient, err := New", svc.GoName, "GRPCClient(")
	optionsG.P("//\t    WithTimeout(10 * time.Second), // Set 10 second timeout")
	optionsG.P("//\t)")
	optionsG.P("//")
	optionsG.P("// Note: Individual method calls can still override this timeout by providing")
	optionsG.P("// a context with a shorter deadline.")
	optionsG.P("func WithTimeout(timeout time.Duration) ", optionTypeName, " {")
	optionsG.P("\treturn func(c *", clientStructName, ") {")
	optionsG.P("\t\tc.timeout = timeout")
	optionsG.P("\t}")
	optionsG.P("}")

	return nil
}

func generateClientFile(p *protogen.Plugin, f *protogen.File, svc *protogen.Service) error {
	// Generate main client file
	g := p.NewGeneratedFile(
		serviceProvider.GenerateFilename(f.Desc.Path(), "_grpc_client"),
		f.GoImportPath,
	)

	// Add header
	g.P("// Code generated by protoc-gen-meshgo. DO NOT EDIT.")
	g.P("// source: ", f.Desc.Path())
	g.P("package ", f.GoPackageName)
	g.P()

	// Add imports
	g.P("import (")
	g.P("\t\"context\"")
	g.P("\t\"errors\"")
	g.P("\tfmt \"fmt\"")
	g.P("\t\"time\"")
	g.P()
	g.P("\t\"github.com/meshtrade/api/go/common\"")
	g.P("\ttrace \"go.opentelemetry.io/otel/trace\"")
	g.P("\t\"go.opentelemetry.io/otel/trace/noop\"")
	g.P("\tgrpc \"google.golang.org/grpc\"")
	g.P("\t\"google.golang.org/grpc/credentials\"")
	g.P("\t\"google.golang.org/grpc/credentials/insecure\"")
	g.P("\t\"google.golang.org/grpc/metadata\"")
	g.P(")")
	g.P()

	clientInterfaceName := svc.GoName + "GRPCClient"
	clientStructName := strings.ToLower(string(svc.GoName[0])) + svc.GoName[1:] + "GRPCClient"

	// Generate combined interface
	g.P("// ", clientInterfaceName, " is a production-ready gRPC client for the ", svc.GoName, " service.")
	g.P("// It combines the service interface with resource management capabilities, providing")
	g.P("// enterprise-grade features including authentication, timeouts, tracing, and connection pooling.")
	g.P("//")
	g.P("// Features:")
	g.P("//   - Automatic authentication via API key or access token cookies")
	g.P("//   - Configurable request timeouts with smart deadline handling")
	g.P("//   - OpenTelemetry distributed tracing support")
	g.P("//   - TLS/mTLS support with configurable transport credentials")
	g.P("//   - Proper resource cleanup with Close() method")
	g.P("//   - Production-ready connection management")
	g.P("//")
	g.P("// Thread Safety:")
	g.P("//   This client is safe for concurrent use by multiple goroutines.")
	g.P("//")
	g.P("// Example usage:")
	g.P("//")
	g.P("//\tclient, err := New", svc.GoName, "GRPCClient(")
	g.P("//\t\tWithAPIKey(\"your-api-key\"),")
	g.P("//\t\tWithTimeout(30 * time.Second),")
	g.P("//\t)")
	g.P("//\tif err != nil {")
	g.P("//\t\tlog.Fatal(err)")
	g.P("//\t}")
	g.P("//\tdefer client.Close()")
	g.P("//")
	g.P("//\tresponse, err := client.SomeMethod(context.Background(), &request)")
	g.P("type ", clientInterfaceName, " interface {")
	g.P("\t", svc.GoName)
	g.P("\tcommon.GRPCClient")
	g.P("}")
	g.P()

	// Add interface implementation check
	g.P("// ensure ", clientStructName, " implements the ", clientInterfaceName, " interface")
	g.P("var _ ", clientInterfaceName, " = &", clientStructName, "{}")
	g.P()

	// Generate client struct
	g.P("// ", clientStructName, " is the internal implementation of the ", clientInterfaceName, " interface.")
	g.P("// This struct maintains the gRPC connection state, authentication credentials,")
	g.P("// and configuration options for the client.")
	g.P("type ", clientStructName, " struct {")
	g.P("\turl                     string")
	g.P("\tport                    int")
	g.P("\ttls                     bool")
	g.P("\tconn                    *grpc.ClientConn")
	g.P("\tgrpcClient              ", svc.GoName, "Client")
	g.P("\ttracer                  trace.Tracer")
	g.P("\tapiKey                  string")
	g.P("\taccessTokenCookie       string")
	g.P("\ttimeout                 time.Duration")
	g.P("\tunaryClientInterceptors []grpc.UnaryClientInterceptor")
	g.P("}")
	g.P()

	// Generate constructor
	g.P("// New", svc.GoName, "GRPCClient creates a new production-ready gRPC client for the ", svc.GoName, " service.")
	g.P("// The client is configured using functional options and automatically handles connection")
	g.P("// management, authentication, timeouts, and distributed tracing.")
	g.P("//")
	g.P("// Default Configuration:")
	g.P("//   - Server: Uses common.DefaultGRPCURL and common.DefaultGRPCPort")
	g.P("//   - TLS: Enabled by default (common.DefaultTLS)")
	g.P("//   - Timeout: 30 seconds for all method calls")
	g.P("//   - Authentication: Attempts to load API key from MESH_API_KEY environment variable")
	g.P("//   - Tracing: Disabled by default (no-op tracer)")
	g.P("//")
	g.P("// Parameters:")
	g.P("//   - opts: Functional options to configure the client (WithAPIKey, WithTimeout, etc.)")
	g.P("//")
	g.P("// Returns:")
	g.P("//   - ", clientInterfaceName, ": Configured client instance")
	g.P("//   - error: Configuration or connection error")
	g.P("//")
	g.P("// Example:")
	g.P("//")
	g.P("//\tclient, err := New", svc.GoName, "GRPCClient(")
	g.P("//\t\tWithAPIKey(\"your-api-key-here\"),")
	g.P("//\t\tWithAddress(\"api.example.com\", 443),")
	g.P("//\t\tWithTimeout(10 * time.Second),")
	g.P("//\t)")
	g.P("//\tif err != nil {")
	g.P("//\t\treturn fmt.Errorf(\"failed to create client: %w\", err)")
	g.P("//\t}")
	g.P("//\tdefer client.Close()")
	g.P("//")
	g.P("// Thread Safety:")
	g.P("//   The returned client is safe for concurrent use by multiple goroutines.")
	g.P("func New", svc.GoName, "GRPCClient(opts ...ClientOption) (", clientInterfaceName, ", error) {")
	g.P("\t// prepare client with default configuration")
	g.P("\tclient := &", clientStructName, "{")
	g.P("\t\turl:     common.DefaultGRPCURL,")
	g.P("\t\tport:    common.DefaultGRPCPort,")
	g.P("\t\ttls:     common.DefaultTLS,")
	g.P("\t\ttracer:  noop.NewTracerProvider().Tracer(\"\"),")
	g.P("\t\tapiKey:  common.APIKEYFromEnvironment(),")
	g.P("\t\ttimeout: 30 * time.Second, // default 30 second timeout")
	g.P()
	g.P("\t\t// set once options are applied and connection opened")
	g.P("\t\tgrpcClient:              nil,")
	g.P("\t\tunaryClientInterceptors: nil,")
	g.P("\t}")
	g.P()
	g.P("\t// apply options to the client")
	g.P("\tfor _, opt := range opts {")
	g.P("\t\topt(client)")
	g.P("\t}")
	g.P()
	g.P("\t// validate authentication credentials")
	g.P("\tif err := client.validateAuth(); err != nil {")
	g.P("\t\treturn nil, err")
	g.P("\t}")
	g.P()
	g.P("\t// prepare authentication interceptor")
	g.P("\tclient.unaryClientInterceptors = []grpc.UnaryClientInterceptor{")
	g.P("\t\tclient.authInterceptor(),")
	g.P("\t}")
	g.P()
	g.P("\t// prepare dial options")
	g.P("\tdialOpts := make([]grpc.DialOption, 0)")
	g.P()
	g.P("\t// set transport credentials")
	g.P("\tif client.tls {")
	g.P("\t\tdialOpts = append(dialOpts, grpc.WithTransportCredentials(credentials.NewClientTLSFromCert(nil, \"\")))")
	g.P("\t} else {")
	g.P("\t\tdialOpts = append(dialOpts, grpc.WithTransportCredentials(insecure.NewCredentials()))")
	g.P("\t}")
	g.P()
	g.P("\tdialOpts = append(dialOpts, grpc.WithChainUnaryInterceptor(client.unaryClientInterceptors...))")
	g.P()
	g.P("\t// construct gRPC client connection")
	g.P("\tconn, err := grpc.NewClient(")
	g.P("\t\tfmt.Sprintf(\"%s:%d\", client.url, client.port),")
	g.P("\t\tdialOpts...,")
	g.P("\t)")
	g.P("\tif err != nil {")
	g.P("\t\treturn nil, fmt.Errorf(\"error constructing grpc client connection: %w\", err)")
	g.P("\t}")
	g.P()
	g.P("\t// set client connection and gRPC client")
	g.P("\tclient.conn = conn")
	g.P("\tclient.grpcClient = New", svc.GoName, "Client(conn)")
	g.P()
	g.P("\t// return constructed client")
	g.P("\treturn client, nil")
	g.P("}")
	g.P()

	// Generate method implementations
	for i, method := range svc.Methods {
		// Generate comprehensive method documentation
		g.P("// ", method.GoName, " executes the ", method.GoName, " RPC method on the ", svc.GoName, " service.")
		g.P("// This method automatically handles authentication, timeouts, distributed tracing, and error propagation.")
		g.P("//")
		g.P("// Timeout Behavior:")
		g.P("//   - If the context already has a deadline, it will be respected")
		g.P("//   - If no deadline is set, the client's configured timeout will be applied")
		g.P("//   - The method will be cancelled if the timeout is exceeded")
		g.P("//")
		g.P("// Authentication:")
		g.P("//   - Automatically includes API key or access token in request headers")
		g.P("//   - Authentication is configured during client creation")
		g.P("//")
		g.P("// Distributed Tracing:")
		g.P("//   - Creates a new span for this method call")
		g.P("//   - Span is automatically finished when the method returns")
		g.P("//   - Errors are recorded in the span")
		g.P("//")
		g.P("// Parameters:")
		g.P("//   - ctx: Context for the request (can include custom timeout, tracing, etc.)")
		g.P("//   - request: The ", method.Input.GoIdent, " containing the method parameters")
		g.P("//")
		g.P("// Returns:")
		g.P("//   - *", method.Output.GoIdent, ": The successful response from the service")
		g.P("//   - error: Any error that occurred during the request")
		g.P("//")
		g.P("// Example:")
		g.P("//")
		g.P("//\tresp, err := client.", method.GoName, "(ctx, &", method.Input.GoIdent, "{")
		g.P("//\t\t// populate request fields")
		g.P("//\t})")
		g.P("//\tif err != nil {")
		g.P("//\t\treturn fmt.Errorf(\"", strings.ToLower(method.GoName), " failed: %w\", err)")
		g.P("//\t}")
		g.P("func (s *", clientStructName, ") ", method.GoName, "(ctx context.Context, request *", method.Input.GoIdent, ") (*", method.Output.GoIdent, ", error) {")
		
		// Add timeout handling
		g.P("\t// apply timeout if no deadline is already set")
		g.P("\tif _, hasDeadline := ctx.Deadline(); !hasDeadline {")
		g.P("\t\tvar cancel context.CancelFunc")
		g.P("\t\tctx, cancel = context.WithTimeout(ctx, s.timeout)")
		g.P("\t\tdefer cancel()")
		g.P("\t}")
		g.P()
		
		// Add tracing
		g.P("\tctx, span := s.tracer.Start(")
		g.P("\t\tctx,")
		g.P("\t\t", svc.GoName, "ServiceProviderName+\"", method.GoName, "\",")
		g.P("\t)")
		g.P("\tdefer span.End()")
		g.P()
		
		// Make gRPC call
		g.P("\t// call given implementation of the adapted service provider interface")
		g.P("\t", strings.ToLower(string(method.GoName[0]))+method.GoName[1:]+"Response, err := s.grpcClient.", method.GoName, "(ctx, request)")
		g.P("\tif err != nil {")
		g.P("\t\treturn nil, err")
		g.P("\t}")
		g.P()
		g.P("\treturn ", strings.ToLower(string(method.GoName[0]))+method.GoName[1:]+"Response, nil")
		g.P("}")

		if i != len(svc.Methods)-1 {
			g.P()
		}
	}

	g.P()

	// Generate Close method
	g.P("// Close gracefully shuts down the gRPC client connection and releases all associated resources.")
	g.P("// This method should be called when the client is no longer needed to prevent resource leaks.")
	g.P("// It's safe to call Close() multiple times - subsequent calls will be no-ops.")
	g.P("//")
	g.P("// Best Practices:")
	g.P("//   - Always call Close() when done with the client")
	g.P("//   - Use defer client.Close() immediately after successful client creation")
	g.P("//   - Do not use the client after calling Close()")
	g.P("//")
	g.P("// Example:")
	g.P("//")
	g.P("//\tclient, err := New", svc.GoName, "GRPCClient(...)")
	g.P("//\tif err != nil {")
	g.P("//\t\treturn err")
	g.P("//\t}")
	g.P("//\tdefer client.Close() // Ensure cleanup")
	g.P("//")
	g.P("// Returns:")
	g.P("//   - error: Any error that occurred while closing the connection")
	g.P("func (s *", clientStructName, ") Close() error {")
	g.P("\tif s.conn != nil {")
	g.P("\t\treturn s.conn.Close()")
	g.P("\t}")
	g.P("\treturn nil")
	g.P("}")
	g.P()

	// Generate validateAuth helper
	g.P("// validateAuth ensures that at least one authentication method is properly configured.")
	g.P("// This method is called during client initialization to prevent runtime authentication failures.")
	g.P("//")
	g.P("// Supported Authentication Methods:")
	g.P("//   - API Key: Set via WithAPIKey() option or MESH_API_KEY environment variable")
	g.P("//   - Access Token Cookie: Set via WithAccessTokenCookie() option")
	g.P("//")
	g.P("// Returns:")
	g.P("//   - nil: If authentication is properly configured")
	g.P("//   - error: If no authentication method is available")
	g.P("func (c *", clientStructName, ") validateAuth() error {")
	g.P("\tif c.apiKey == \"\" && c.accessTokenCookie == \"\" {")
	g.P("\t\treturn errors.New(\"neither api key nor access token cookie set. set api key via WithAPIKey option or as MESH_API_KEY environment variable. set access token cookie via WithAccessTokenCookie option\")")
	g.P("\t}")
	g.P("\treturn nil")
	g.P("}")
	g.P()

	// Generate authInterceptor helper
	g.P("// authInterceptor creates and returns the appropriate gRPC unary interceptor for authentication.")
	g.P("// This interceptor automatically adds authentication headers to all outgoing requests based")
	g.P("// on the configured authentication method (API key takes precedence over access token cookie).")
	g.P("//")
	g.P("// Authentication Methods:")
	g.P("//   - API Key: Added as \"Authorization: Bearer <api-key>\" header")
	g.P("//   - Access Token Cookie: Added as \"Cookie: AccessToken=<token>\" header")
	g.P("//")
	g.P("// The interceptor is automatically applied to all method calls and handles the")
	g.P("// authentication transparently without requiring manual header management.")
	g.P("//")
	g.P("// Returns:")
	g.P("//   - grpc.UnaryClientInterceptor: Configured authentication interceptor")
	g.P("func (c *", clientStructName, ") authInterceptor() grpc.UnaryClientInterceptor {")
	g.P("\tif c.apiKey != \"\" {")
	g.P("\t\treturn func(ctx context.Context, method string, req, reply any, cc *grpc.ClientConn, invoker grpc.UnaryInvoker, opts ...grpc.CallOption) error {")
	g.P("\t\t\tctx = metadata.AppendToOutgoingContext(")
	g.P("\t\t\t\tctx,")
	g.P("\t\t\t\tcommon.AuthorizationHeaderKey,")
	g.P("\t\t\t\tcommon.BearerPrefix+c.apiKey,")
	g.P("\t\t\t)")
	g.P("\t\t\treturn invoker(ctx, method, req, reply, cc, opts...)")
	g.P("\t\t}")
	g.P("\t}")
	g.P()
	g.P("\treturn func(ctx context.Context, method string, req, reply any, cc *grpc.ClientConn, invoker grpc.UnaryInvoker, opts ...grpc.CallOption) error {")
	g.P("\t\tctx = metadata.AppendToOutgoingContext(")
	g.P("\t\t\tctx,")
	g.P("\t\t\tcommon.CookieHeaderKey,")
	g.P("\t\t\tcommon.AccessTokenPrefix+c.accessTokenCookie,")
	g.P("\t\t)")
	g.P("\t\treturn invoker(ctx, method, req, reply, cc, opts...)")
	g.P("\t}")
	g.P("}")

	return nil
}