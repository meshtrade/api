package grpc

import (
	"strings"

	"github.com/meshtrade/api/tool/protoc-gen-meshgo/pkg/generate"
	"github.com/meshtrade/api/tool/protoc-gen-meshgo/pkg/generate/serviceProvider"
	"google.golang.org/protobuf/compiler/protogen"
)

// generateDocURL creates a dynamic documentation URL from the proto file path
// e.g., "meshtrade/iam/api_user/v1/service.proto" -> "iam/api_user/v1"
func generateDocURL(protoPath string) string {
	// Remove "meshtrade/" prefix and "/service.proto" suffix
	path := strings.TrimPrefix(protoPath, "meshtrade/")
	if idx := strings.LastIndex(path, "/"); idx != -1 {
		path = path[:idx] // Remove filename
	}
	return path
}

func Client(p *protogen.Plugin, f *protogen.File, svc *protogen.Service) error {
	// Generate only the main service file - no more options file needed
	return generateClientFile(p, f, svc)
}

// isServerSideStreaming returns true if the method is server-side streaming
// (single request, stream of responses)
func isServerSideStreaming(method *protogen.Method) bool {
	return method.Desc.IsStreamingServer() && !method.Desc.IsStreamingClient()
}

func generateClientFile(p *protogen.Plugin, f *protogen.File, svc *protogen.Service) error {
	// Generate minimal service file using BaseGRPCClient
	g := p.NewGeneratedFile(
		serviceProvider.GenerateFilename(f.Desc.Path(), ""),
		f.GoImportPath,
	)

	// Add header
	g.P("// Code generated by protoc-gen-meshgo. DO NOT EDIT.")
	g.P("// source: ", f.Desc.Path())
	g.P("package ", f.GoPackageName)
	g.P()

	clientInterfaceName := svc.GoName + "ClientInterface"
	clientStructName := strings.ToLower(string(svc.GoName[0])) + svc.GoName[1:]

	// Generate documentation URL
	docURL := generateDocURL(f.Desc.Path())

	// Generate combined interface with comprehensive documentation
	g.P("// ", clientInterfaceName, " is a gRPC service for the ", svc.GoName, " service.")
	g.P("// It combines the service interface with resource management capabilities using")
	g.P("// the common BaseGRPCClient for consistent authentication, timeouts, and tracing.")
	g.P("//")
	g.P("// Full Service documentation: https://meshtrade.github.io/api/docs/api-reference/", docURL)
	g.P("//")
	g.P("// Basic service usage with default SDK Configuration:")
	g.P("//")
	g.P("//\tservice, err := New", svc.GoName, "()")
	g.P("//\tif err != nil {")
	g.P("//\t\tlog.Fatal(err)")
	g.P("//\t}")
	g.P("//\tdefer service.Close() // ensures proper cleanup of underlying connection")
	g.P("//")
	g.P("// With default configuration API credentials are searched for using the standard discovery hierarchy:")
	g.P("//")
	g.P("// 1. MESH_API_CREDENTIALS environment variable")
	g.P("//")
	g.P("// 2. Default credential file location:")
	g.P("//")
	g.P("//    - Linux:   $XDG_CONFIG_HOME/mesh/credentials.json or fallback to $HOME/.config/mesh/credentials.json")
	g.P("//    - macOS:   $HOME/Library/Application Support/mesh/credentials.json")
	g.P("//    - Windows: C:\\Users\\<user>\\AppData\\Roaming\\mesh\\credentials.json")
	g.P("//")
	g.P("// For more information on authentication: https://meshtrade.github.io/api/docs/architecture/authentication")
	g.P("//")
	g.P("// The service may also be configured with custom options:")
	g.P("//")
	g.P("//\tservice, err := New", svc.GoName, "(")
	g.P("//\t\t", generate.GRPCConfigPkg.Ident("WithURL"), "(\"api.staging.example.com:443\"),")
	g.P("//\t\t", generate.GRPCConfigPkg.Ident("WithAPIKey"), "(\"your-api-key\"),")
	g.P("//\t\t", generate.GRPCConfigPkg.Ident("WithGroup"), "(\"groups/your-group-id\"),")
	g.P("//\t\t", generate.GRPCConfigPkg.Ident("WithTimeout"), "(30 * time.Second),")
	g.P("//\t)")
	g.P("//\tif err != nil {")
	g.P("//\t\tlog.Fatal(err)")
	g.P("//\t}")
	g.P("//\tdefer service.Close() // ensures proper cleanup of underlying connection")
	g.P("//")
	g.P("// For more information on service configuration: https://meshtrade.github.io/api/docs/architecture/sdk-configuration")
	g.P("type ", clientInterfaceName, " interface {")
	g.P("\t", generate.GRPCClientPkg.Ident("GRPCClient"))
	g.P("\t")

	// Generate method signatures explicitly for client interface
	// Streaming methods return streams (client usage), not accept them (server usage)
	for _, method := range svc.Methods {
		// Add method comments with proper formatting
		// Comments.String() returns lines with "//" prefix but may not have space after it
		if len(method.Comments.Leading) > 0 {
			for _, comment := range strings.Split(strings.TrimSpace(method.Comments.Leading.String()), "\n") {
				// Remove the "//" prefix, trim whitespace, then re-add "// " with proper spacing
				commentText := strings.TrimSpace(strings.TrimPrefix(strings.TrimSpace(comment), "//"))
				if commentText != "" {
					g.P("\t// ", commentText)
				}
			}
		}

		if isServerSideStreaming(method) {
			// Client streaming method: returns stream for receiving responses
			streamClientType := svc.GoName + "_" + method.GoName + "Client"
			g.P("\t", method.GoName, "(ctx ", generate.ContextPkg.Ident("Context"), ", request *", method.Input.GoIdent, ") (", streamClientType, ", error)")
		} else {
			// Unary method: same signature as service interface
			g.P("\t", method.GoName, "(ctx ", generate.ContextPkg.Ident("Context"), ", request *", method.Input.GoIdent, ") (*", method.Output.GoIdent, ", error)")
		}
	}

	g.P("\t")
	g.P("\t// WithGroup returns a new client instance with a different group context")
	g.P("\tWithGroup(group string) ", clientInterfaceName)
	g.P("}")
	g.P()

	// Generate minimal client struct that embeds BaseGRPCClient
	g.P("// ", clientStructName, " is the internal implementation of the ", clientInterfaceName, " interface.")
	g.P("// It embeds BaseGRPCClient to provide all common gRPC functionality including validation.")
	g.P("type ", clientStructName, " struct {")
	g.P("\t*", generate.GRPCClientPkg.Ident("BaseGRPCClient"), "[", svc.GoName, "Client]")
	g.P("}")
	g.P()

	// Add interface implementation check
	g.P("// ensure ", clientStructName, " implements the ", clientInterfaceName, " interface")
	g.P("var _ ", clientInterfaceName, " = &", clientStructName, "{}")
	g.P()

	// Generate comprehensive constructor documentation
	g.P("// New", svc.GoName, " creates and initializes the ", svc.GoName, " service.")
	g.P("// The service uses the common BaseGRPCClient for all functionality including")
	g.P("// connection management, authentication, timeouts, and distributed tracing.")
	g.P("//")
	g.P("// Full Service documentation: https://meshtrade.github.io/api/docs/api-reference/", docURL)
	g.P("//")
	g.P("// With default configuration API credentials are searched for using the standard discovery hierarchy:")
	g.P("//")
	g.P("// 1. MESH_API_CREDENTIALS environment variable")
	g.P("//")
	g.P("// 2. Default credential file location:")
	g.P("//")
	g.P("//    - Linux:   $XDG_CONFIG_HOME/mesh/credentials.json or fallback to $HOME/.config/mesh/credentials.json")
	g.P("//    - macOS:   $HOME/Library/Application Support/mesh/credentials.json")
	g.P("//    - Windows: C:\\Users\\<user>\\AppData\\Roaming\\mesh\\credentials.json")
	g.P("//")
	g.P("// For more information on authentication: https://meshtrade.github.io/api/docs/architecture/authentication")
	g.P("//")
	g.P("// For more information on service configuration: https://meshtrade.github.io/api/docs/architecture/sdk-configuration")
	g.P("//")
	g.P("// Examples:")
	g.P("//")
	g.P("//\t// Create with default configuration")
	g.P("//\tservice, err := New", svc.GoName, "()")
	g.P("//\tif err != nil {")
	g.P("//\t\tlog.Fatal(err)")
	g.P("//\t}")
	g.P("//\tdefer service.Close()")
	g.P("//")
	g.P("//\t// Create with custom configuration")
	g.P("//\tservice, err := New", svc.GoName, "(")
	g.P("//\t\t", generate.GRPCConfigPkg.Ident("WithURL"), "(\"api.example.com:443\"),")
	g.P("//\t\t", generate.GRPCConfigPkg.Ident("WithAPIKey"), "(\"your-api-key\"),")
	g.P("//\t\t", generate.GRPCConfigPkg.Ident("WithGroup"), "(\"groups/your-group-id\"),")
	g.P("//\t)")
	g.P("//\tif err != nil {")
	g.P("//\t\tlog.Fatal(err)")
	g.P("//\t}")
	g.P("//\tdefer service.Close()")
	g.P("//")
	g.P("// Parameters:")
	g.P("//   - opts: Functional options to configure the client")
	g.P("//")
	g.P("// Returns:")
	g.P("//   - ", clientInterfaceName, ": Configured service instance")
	g.P("//   - error: Configuration or connection error")
	g.P("func New", svc.GoName, "(opts ...", generate.GRPCConfigPkg.Ident("ServiceOption"), ") (", clientInterfaceName, ", error) {")
	g.P("\tbase, err := ", generate.GRPCClientPkg.Ident("NewBaseGRPCClient"), "(")
	g.P("\t\t", svc.GoName, "ServiceProviderName,")
	g.P("\t\tNew", svc.GoName, "Client,")
	g.P("\t\topts...,")
	g.P("\t)")
	g.P("\tif err != nil {")
	g.P("\t\treturn nil, err")
	g.P("\t}")
	g.P("\t")
	g.P("\treturn &", clientStructName, "{BaseGRPCClient: base}, nil")
	g.P("}")
	g.P()

	// Generate WithGroup method for context switching
	g.P("// WithGroup returns a new client instance configured with a different group context.")
	g.P("// This enables convenient group context switching without reconstructing the entire client.")
	g.P("// All other configuration (URL, port, timeout, tracer, API key, etc.) is preserved.")
	g.P("//")
	g.P("// The group parameter must be in the format 'groups/{group_id}' where group_id is a valid")
	g.P("// group identifier (typically a ULID). The new client instance shares no state with the")
	g.P("// original client, allowing safe concurrent usage across different goroutines.")
	g.P("//")
	g.P("// Example:")
	g.P("//")
	g.P("//\t// Create initial client with default group from credentials")
	g.P("//\tservice, err := New", svc.GoName, "()")
	g.P("//\tif err != nil {")
	g.P("//\t\tlog.Fatal(err)")
	g.P("//\t}")
	g.P("//\tdefer service.Close()")
	g.P("//")
	g.P("//\t// Switch to a different group context")
	g.P("//\taltService := service.WithGroup(\"groups/01ARZ3NDEKTSV4RRFFQ69G5FAV\")")
	g.P("//\tdefer altService.Close()")
	g.P("//")
	g.P("//\t// Both clients can be used independently")
	g.P("//\tresp1, _ := service.SomeMethod(ctx, req)      // Uses original group")
	g.P("//\tresp2, _ := altService.SomeMethod(ctx, req)   // Uses alternative group")
	g.P("//")
	g.P("// Parameters:")
	g.P("//   - group: The group resource name in format 'groups/{group_id}'")
	g.P("//")
	g.P("// Returns:")
	g.P("//   - ", clientInterfaceName, ": New client instance with updated group context")
	g.P("func (s *", clientStructName, ") WithGroup(group string) ", clientInterfaceName, " {")
	g.P("\t// Create new base client with copied configuration but new group")
	g.P("\tnewBase := s.BaseGRPCClient.WithGroup(group)")
	g.P("\t")
	g.P("\t// Return new service instance wrapping the new base client")
	g.P("\treturn &", clientStructName, "{BaseGRPCClient: newBase}")
	g.P("}")
	g.P()

	// Generate ultra-clean method implementations with validation handled in base Execute function
	for i, method := range svc.Methods {
		if isServerSideStreaming(method) {
			generateStreamingMethod(g, method, clientStructName, svc.GoName)
		} else {
			// Unary method (existing logic)
			g.P("// ", method.GoName, " executes the ", method.GoName, " RPC method with automatic")
			g.P("// client-side validation, timeout handling, distributed tracing, and authentication.")
			g.P("func (s *", clientStructName, ") ", method.GoName, "(ctx ", generate.ContextPkg.Ident("Context"), ", request *", method.Input.GoIdent, ") (*", method.Output.GoIdent, ", error) {")
			g.P("\treturn ", generate.GRPCClientPkg.Ident("Execute"), "(s.Executor(), ctx, \"", method.GoName, "\", request, func(ctx ", generate.ContextPkg.Ident("Context"), ") (*", method.Output.GoIdent, ", error) {")
			g.P("\t\treturn s.GrpcClient().", method.GoName, "(ctx, request)")
			g.P("\t})")
			g.P("}")
		}

		if i != len(svc.Methods)-1 {
			g.P()
		}
	}

	return nil
}

// generateStreamingMethod generates a server-side streaming method wrapper
func generateStreamingMethod(g *protogen.GeneratedFile, method *protogen.Method, clientStructName string, serviceName string) {
	// Generate streaming method documentation
	g.P("// ", method.GoName, " executes the ", method.GoName, " server-side streaming RPC method")
	g.P("// with automatic client-side validation, timeout handling, distributed tracing, and authentication.")
	g.P("// Returns a stream client that yields multiple ", method.Output.GoIdent, " messages.")
	g.P("//")
	g.P("// The returned stream must be fully consumed or explicitly closed to avoid resource leaks.")
	g.P("// Example usage:")
	g.P("//")
	g.P("//\tstream, err := client.", method.GoName, "(ctx, request)")
	g.P("//\tif err != nil {")
	g.P("//\t\treturn err")
	g.P("//\t}")
	g.P("//\tfor {")
	g.P("//\t\tresp, err := stream.Recv()")
	g.P("//\t\tif err == io.EOF {")
	g.P("//\t\t\tbreak")
	g.P("//\t\t}")
	g.P("//\t\tif err != nil {")
	g.P("//\t\t\treturn err")
	g.P("//\t\t}")
	g.P("//\t\t// Process resp...")
	g.P("//\t}")

	// Generate method signature - return the gRPC streaming client directly
	streamClientType := serviceName + "_" + method.GoName + "Client"
	g.P("func (s *", clientStructName, ") ", method.GoName, "(ctx ", generate.ContextPkg.Ident("Context"), ", request *", method.Input.GoIdent, ") (", streamClientType, ", error) {")
	g.P("\treturn ", generate.GRPCClientPkg.Ident("ExecuteStream"), "(s.Executor(), ctx, \"", method.GoName, "\", request, func(ctx ", generate.ContextPkg.Ident("Context"), ") (", streamClientType, ", error) {")
	g.P("\t\treturn s.GrpcClient().", method.GoName, "(ctx, request)")
	g.P("\t})")
	g.P("}")
}
