package grpc

import (
	"strings"

	"github.com/meshtrade/api/tool/protoc-gen-meshgo/pkg/generate"
	"github.com/meshtrade/api/tool/protoc-gen-meshgo/pkg/generate/serviceProvider"
	"google.golang.org/protobuf/compiler/protogen"
)

func Client(p *protogen.Plugin, f *protogen.File, svc *protogen.Service) error {
	// Generate options file first
	if err := generateOptionsFile(p, f, svc); err != nil {
		return err
	}

	// Generate main client file
	return generateClientFile(p, f, svc)
}

func generateOptionsFile(p *protogen.Plugin, f *protogen.File, svc *protogen.Service) error {
	optionsG := p.NewGeneratedFile(
		serviceProvider.GenerateFilename(f.Desc.Path(), "_grpc_client_options"),
		f.GoImportPath,
	)

	// Add header
	optionsG.P("// Code generated by protoc-gen-meshgo. DO NOT EDIT.")
	optionsG.P("// source: ", f.Desc.Path())
	optionsG.P("package ", f.GoPackageName)
	optionsG.P()

	// Imports are managed automatically by protogen
	optionsG.P()

	clientStructName := strings.ToLower(string(svc.GoName[0])) + svc.GoName[1:] + "GRPCClient"
	optionTypeName := "ClientOption"

	// Generate ClientOption type
	optionsG.P("// ", optionTypeName, " is a functional option for configuring the ", svc.GoName, " gRPC client.")
	optionsG.P("// This pattern provides a clean, extensible way to configure the client with optional")
	optionsG.P("// parameters while maintaining backward compatibility and readability.")
	optionsG.P("type ", optionTypeName, " func(*", clientStructName, ")")
	optionsG.P()

	// Generate WithTLS option
	optionsG.P("// WithTLS configures whether to use TLS encryption for the gRPC connection.")
	optionsG.P("// When enabled (true), the client will establish a secure connection using TLS.")
	optionsG.P("// When disabled (false), the client will use an insecure connection.")
	optionsG.P("//")
	optionsG.P("// Default: true (secure connection)")
	optionsG.P("//")
	optionsG.P("// Example:")
	optionsG.P("//")
	optionsG.P("//\tclient, err := New", svc.GoName, "GRPCClient(")
	optionsG.P("//\t    WithTLS(true), // Enable TLS encryption")
	optionsG.P("//\t)")
	optionsG.P("func WithTLS(enabled bool) ", optionTypeName, " {")
	optionsG.P("\treturn func(c *", clientStructName, ") {")
	optionsG.P("\t\tc.tls = enabled")
	optionsG.P("\t}")
	optionsG.P("}")
	optionsG.P()

	// Generate WithAddress option
	optionsG.P("// WithAddress configures the server address (URL and port) for the gRPC connection.")
	optionsG.P("// This allows you to connect to different environments or custom deployments.")
	optionsG.P("//")
	optionsG.P("// Parameters:")
	optionsG.P("//   - url: The server hostname or IP address (e.g., \"api.example.com\", \"localhost\")")
	optionsG.P("//   - port: The server port number (e.g., 443 for HTTPS, 8080 for development)")
	optionsG.P("//")
	optionsG.P("// Default: Uses common.DefaultGRPCURL and common.DefaultGRPCPort")
	optionsG.P("//")
	optionsG.P("// Example:")
	optionsG.P("//")
	optionsG.P("//\tclient, err := New", svc.GoName, "GRPCClient(")
	optionsG.P("//\t    WithAddress(\"staging-api.example.com\", 443), // Connect to staging")
	optionsG.P("//\t)")
	optionsG.P("func WithAddress(url string, port int) ", optionTypeName, " {")
	optionsG.P("\treturn func(c *", clientStructName, ") {")
	optionsG.P("\t\tc.url = url")
	optionsG.P("\t\tc.port = port")
	optionsG.P("\t}")
	optionsG.P("}")
	optionsG.P()

	// Generate WithURL option
	optionsG.P("// WithURL configures only the server URL/hostname for the gRPC connection.")
	optionsG.P("// The port will remain unchanged (uses existing port or default).")
	optionsG.P("// Use WithAddress() if you need to set both URL and port together.")
	optionsG.P("//")
	optionsG.P("// Parameter:")
	optionsG.P("//   - url: The server hostname or IP address")
	optionsG.P("//")
	optionsG.P("// Example:")
	optionsG.P("//")
	optionsG.P("//\tclient, err := New", svc.GoName, "GRPCClient(")
	optionsG.P("//\t    WithURL(\"production-api.mesh.trade\"), // Use production server")
	optionsG.P("//\t)")
	optionsG.P("func WithURL(url string) ", optionTypeName, " {")
	optionsG.P("\treturn func(c *", clientStructName, ") {")
	optionsG.P("\t\tc.url = url")
	optionsG.P("\t}")
	optionsG.P("}")
	optionsG.P()

	// Generate WithPort option
	optionsG.P("// WithPort configures only the server port for the gRPC connection.")
	optionsG.P("// The URL will remain unchanged (uses existing URL or default).")
	optionsG.P("// Use WithAddress() if you need to set both URL and port together.")
	optionsG.P("//")
	optionsG.P("// Parameter:")
	optionsG.P("//   - port: The server port number")
	optionsG.P("//")
	optionsG.P("// Example:")
	optionsG.P("//")
	optionsG.P("//\tclient, err := New", svc.GoName, "GRPCClient(")
	optionsG.P("//\t    WithPort(9090), // Connect to port 9090")
	optionsG.P("//\t)")
	optionsG.P("func WithPort(port int) ", optionTypeName, " {")
	optionsG.P("\treturn func(c *", clientStructName, ") {")
	optionsG.P("\t\tc.port = port")
	optionsG.P("\t}")
	optionsG.P("}")
	optionsG.P()

	// Generate WithAPIKey option
	optionsG.P("// WithAPIKey configures API key authentication for the gRPC client.")
	optionsG.P("// The API key will be sent as a Bearer token in the Authorization header.")
	optionsG.P("// This is the primary authentication method for service-to-service communication.")
	optionsG.P("//")
	optionsG.P("// IMPORTANT: When using API key authentication, you must also specify a group")
	optionsG.P("// using WithGroup() or load from credentials file via MESH_API_CREDENTIALS.")
	optionsG.P("//")
	optionsG.P("//")
	optionsG.P("// Parameter:")
	optionsG.P("//   - apiKey: The API key string (without \"Bearer \" prefix)")
	optionsG.P("//")
	optionsG.P("// Example:")
	optionsG.P("//")
	optionsG.P("//\tclient, err := New", svc.GoName, "GRPCClient(")
	optionsG.P("//\t    WithAPIKey(\"your-api-key-here\"),")
	optionsG.P("//\t    WithGroup(\"groups/your-group-id\"),")
	optionsG.P("//\t)")
	optionsG.P("func WithAPIKey(apiKey string) ", optionTypeName, " {")
	optionsG.P("\treturn func(c *", clientStructName, ") {")
	optionsG.P("\t\tc.apiKey = apiKey")
	optionsG.P("\t}")
	optionsG.P("}")
	optionsG.P()

	// Generate WithGroup option
	optionsG.P("// WithGroup configures the group resource name for all API requests made by this client.")
	optionsG.P("// The group is required for public API calls and determines the authorization context")
	optionsG.P("// for operations. It will be sent as an \"x-group-id\" header with every request.")
	optionsG.P("//")
	optionsG.P("// This option is required when using manual authentication configuration.")
	optionsG.P("// When loading from credentials file via MESH_API_CREDENTIALS, the group")
	optionsG.P("// is automatically loaded and this option is optional (but will override the file value).")
	optionsG.P("//")
	optionsG.P("// Parameter:")
	optionsG.P("//   - group: The group resource name in format groups/{group_id}")
	optionsG.P("//")
	optionsG.P("// Example:")
	optionsG.P("//")
	optionsG.P("//\tclient, err := New", svc.GoName, "GRPCClient(")
	optionsG.P("//\t    WithAPIKey(\"your-api-key\"),")
	optionsG.P("//\t    WithGroup(\"groups/01ABCDEF123456789\"),")
	optionsG.P("//\t)")
	optionsG.P("func WithGroup(group string) ", optionTypeName, " {")
	optionsG.P("\treturn func(c *", clientStructName, ") {")
	optionsG.P("\t\tc.group = group")
	optionsG.P("\t}")
	optionsG.P("}")
	optionsG.P()

	// Generate WithTracer option
	optionsG.P("// WithTracer configures OpenTelemetry distributed tracing for the gRPC client.")
	optionsG.P("// This enables observability and monitoring of API calls across service boundaries.")
	optionsG.P("// Each gRPC method call will create a trace span for tracking request flow.")
	optionsG.P("//")
	optionsG.P("// Parameter:")
	optionsG.P("//   - tracer: An OpenTelemetry tracer instance")
	optionsG.P("//")
	optionsG.P("// Default: Uses a no-op tracer (tracing disabled)")
	optionsG.P("//")
	optionsG.P("// Example:")
	optionsG.P("//")
	optionsG.P("//\ttracer := otel.Tracer(\"", strings.ToLower(svc.GoName), "-client\")")
	optionsG.P("//\tclient, err := New", svc.GoName, "GRPCClient(")
	optionsG.P("//\t    WithTracer(tracer),")
	optionsG.P("//\t)")
	optionsG.P("func WithTracer(tracer ", generate.TracingPkg.Ident("Tracer"), ") ", optionTypeName, " {")
	optionsG.P("\treturn func(c *", clientStructName, ") {")
	optionsG.P("\t\tc.tracer = tracer")
	optionsG.P("\t}")
	optionsG.P("}")
	optionsG.P()

	// Generate WithTimeout option
	optionsG.P("// WithTimeout configures the default timeout for all gRPC method calls.")
	optionsG.P("// This timeout applies to individual method calls and helps prevent hanging requests.")
	optionsG.P("// If a request takes longer than the specified timeout, it will be cancelled.")
	optionsG.P("//")
	optionsG.P("// The timeout is implemented using context.WithTimeout() for each method call.")
	optionsG.P("//")
	optionsG.P("// Parameter:")
	optionsG.P("//   - timeout: The maximum duration to wait for a method call to complete")
	optionsG.P("//")
	optionsG.P("// Default: 30 seconds")
	optionsG.P("//")
	optionsG.P("// Example:")
	optionsG.P("//")
	optionsG.P("//\tclient, err := New", svc.GoName, "GRPCClient(")
	optionsG.P("//\t    WithTimeout(10 * time.Second), // Set 10 second timeout")
	optionsG.P("//\t)")
	optionsG.P("//")
	optionsG.P("// Note: Individual method calls can still override this timeout by providing")
	optionsG.P("// a context with a shorter deadline.")
	optionsG.P("func WithTimeout(timeout ", generate.TimePackage.Ident("Duration"), ") ", optionTypeName, " {")
	optionsG.P("\treturn func(c *", clientStructName, ") {")
	optionsG.P("\t\tc.timeout = timeout")
	optionsG.P("\t}")
	optionsG.P("}")

	return nil
}

func generateClientFile(p *protogen.Plugin, f *protogen.File, svc *protogen.Service) error {
	// Generate main client file
	g := p.NewGeneratedFile(
		serviceProvider.GenerateFilename(f.Desc.Path(), "_grpc_client"),
		f.GoImportPath,
	)

	// Add header
	g.P("// Code generated by protoc-gen-meshgo. DO NOT EDIT.")
	g.P("// source: ", f.Desc.Path())
	g.P("package ", f.GoPackageName)
	g.P()

	// Imports are managed automatically by protogen
	g.P()

	clientInterfaceName := svc.GoName + "GRPCClient"
	clientStructName := strings.ToLower(string(svc.GoName[0])) + svc.GoName[1:] + "GRPCClient"

	// Generate combined interface
	g.P("// ", clientInterfaceName, " is a gRPC client for the ", svc.GoName, " service.")
	g.P("// It combines the service interface with resource management capabilities, providing")
	g.P("// authentication, timeouts, and tracing.")
	g.P("//")
	g.P("// Features:")
	g.P("//   - Automatic authentication via API key with group ID support")
	g.P("//   - Credentials file loading from MESH_API_CREDENTIALS environment variable")
	g.P("//   - Configurable request timeouts with deadline handling")
	g.P("//   - OpenTelemetry distributed tracing support")
	g.P("//   - TLS support with configurable transport credentials")
	g.P("//   - Proper resource cleanup with Close() method")
	g.P("//   - Proper connection management")
	g.P("//")
	g.P("// Thread Safety:")
	g.P("//   This client uses gRPC's thread-safe underlying connections.")
	g.P("//")
	g.P("// Example usage:")
	g.P("//")
	g.P("//\tclient, err := New", svc.GoName, "GRPCClient(")
	g.P("//\t\tWithAPIKey(\"your-api-key\"),")
	g.P("//\t\tWithGroup(\"groups/your-group-id\"),")
	g.P("//\t\tWithTimeout(30 * time.Second),")
	g.P("//\t)")
	g.P("//\tif err != nil {")
	g.P("//\t\tlog.Fatal(err)")
	g.P("//\t}")
	g.P("//\tdefer client.Close()")
	g.P("//")
	g.P("//\t// Use client methods as defined in the service interface")
	g.P("type ", clientInterfaceName, " interface {")
	g.P("\t", svc.GoName)
	g.P("\t", generate.CommonPkg.Ident("GRPCClient"))
	g.P("}")
	g.P()

	// Add interface implementation check
	g.P("// ensure ", clientStructName, " implements the ", clientInterfaceName, " interface")
	g.P("var _ ", clientInterfaceName, " = &", clientStructName, "{}")
	g.P()

	// Generate client struct
	g.P("// ", clientStructName, " is the internal implementation of the ", clientInterfaceName, " interface.")
	g.P("// This struct maintains the gRPC connection state, authentication credentials,")
	g.P("// and configuration options for the client.")
	g.P("type ", clientStructName, " struct {")
	g.P("\turl                     string")
	g.P("\tport                    int")
	g.P("\ttls                     bool")
	g.P("\tconn                    *", generate.GRPCPkg.Ident("ClientConn"))
	g.P("\tgrpcClient              ", svc.GoName, "Client")
	g.P("\ttracer                  ", generate.TracingPkg.Ident("Tracer"))
	g.P("\tapiKey                  string")
	g.P("\tgroup                   string")
	g.P("\ttimeout                 ", generate.TimePackage.Ident("Duration"))
	g.P("\tunaryClientInterceptors []", generate.GRPCPkg.Ident("UnaryClientInterceptor"))
	g.P("}")
	g.P()

	// Generate constructor
	g.P("// New", svc.GoName, "GRPCClient creates a new gRPC client for the ", svc.GoName, " service.")
	g.P("// The client is configured using functional options and automatically handles connection")
	g.P("// management, authentication, timeouts, and distributed tracing.")
	g.P("//")
	g.P("// Default Configuration:")
	g.P("//   - Server: Uses common.DefaultGRPCURL and common.DefaultGRPCPort")
	g.P("//   - TLS: Enabled by default (common.DefaultTLS)")
	g.P("//   - Timeout: 30 seconds for all method calls")
	g.P("//   - Authentication: Attempts to load credentials from MESH_API_CREDENTIALS file")
	g.P("//   - Tracing: Disabled by default (no-op tracer)")
	g.P("//")
	g.P("// Parameters:")
	g.P("//   - opts: Functional options to configure the client (WithAPIKey, WithTimeout, etc.)")
	g.P("//")
	g.P("// Returns:")
	g.P("//   - ", clientInterfaceName, ": Configured client instance")
	g.P("//   - error: Configuration or connection error")
	g.P("//")
	g.P("// Example:")
	g.P("//")
	g.P("//\tclient, err := New", svc.GoName, "GRPCClient(")
	g.P("//\t\tWithAPIKey(\"your-api-key-here\"),")
	g.P("//\t\tWithGroup(\"groups/your-group-id\"),")
	g.P("//\t\tWithAddress(\"api.example.com\", 443),")
	g.P("//\t\tWithTimeout(10 * time.Second),")
	g.P("//\t)")
	g.P("//\tif err != nil {")
	g.P("//\t\treturn fmt.Errorf(\"failed to create client: %w\", err)")
	g.P("//\t}")
	g.P("//\tdefer client.Close()")
	g.P("//")
	g.P("// Thread Safety:")
	g.P("//   The returned client uses gRPC's thread-safe underlying connections.")
	g.P("func New", svc.GoName, "GRPCClient(opts ...ClientOption) (", clientInterfaceName, ", error) {")
	g.P("\t// prepare client with default configuration")
	g.P("\tclient := &", clientStructName, "{")
	g.P("\t\turl:     ", generate.CommonPkg.Ident("DefaultGRPCURL"), ",")
	g.P("\t\tport:    ", generate.CommonPkg.Ident("DefaultGRPCPort"), ",")
	g.P("\t\ttls:     ", generate.CommonPkg.Ident("DefaultTLS"), ",")
	g.P("\t\ttracer:  ", generate.TracingNoopPkg.Ident("NewTracerProvider"), "().Tracer(\"\"),")
	g.P("\t\ttimeout: 30 * ", generate.TimePackage.Ident("Second"), ", // default 30 second timeout")
	g.P()
	g.P("\t\t// set once options are applied and connection opened")
	g.P("\t\tgrpcClient:              nil,")
	g.P("\t\tunaryClientInterceptors: nil,")
	g.P("\t}")
	g.P()
	g.P("\t// attempt to load credentials from environment file")
	g.P("\tif creds, err := ", generate.APICredentialsPkg.Ident("CredentialsFromEnvironment"), "(); err == nil {")
	g.P("\t\tclient.apiKey = creds.APIKey")
	g.P("\t\tclient.group = creds.Group")
	g.P("\t}")
	g.P()
	g.P("\t// apply options to the client (these can override credentials from file)")
	g.P("\tfor _, opt := range opts {")
	g.P("\t\topt(client)")
	g.P("\t}")
	g.P()
	g.P("\t// validate authentication credentials")
	g.P("\tif err := client.validateAuth(); err != nil {")
	g.P("\t\treturn nil, err")
	g.P("\t}")
	g.P()
	g.P("\t// prepare authentication interceptor")
	g.P("\tclient.unaryClientInterceptors = []", generate.GRPCPkg.Ident("UnaryClientInterceptor"), "{")
	g.P("\t\tclient.authInterceptor(),")
	g.P("\t}")
	g.P()
	g.P("\t// prepare dial options")
	g.P("\tdialOpts := make([]", generate.GRPCPkg.Ident("DialOption"), ", 0)")
	g.P()
	g.P("\t// set transport credentials")
	g.P("\tif client.tls {")
	g.P("\t\tdialOpts = append(dialOpts, ", generate.GRPCPkg.Ident("WithTransportCredentials"), "(", generate.GRPCCredentialsPkg.Ident("NewClientTLSFromCert"), "(nil, \"\")))")
	g.P("\t} else {")
	g.P("\t\tdialOpts = append(dialOpts, ", generate.GRPCPkg.Ident("WithTransportCredentials"), "(", generate.GRPCInsecurePkg.Ident("NewCredentials"), "()))")
	g.P("\t}")
	g.P()
	g.P("\tdialOpts = append(dialOpts, ", generate.GRPCPkg.Ident("WithChainUnaryInterceptor"), "(client.unaryClientInterceptors...))")
	g.P()
	g.P("\t// construct gRPC client connection")
	g.P("\tconn, err := ", generate.GRPCPkg.Ident("NewClient"), "(")
	g.P("\t\t", generate.FmtPackage.Ident("Sprintf"), "(\"%s:%d\", client.url, client.port),")
	g.P("\t\tdialOpts...,")
	g.P("\t)")
	g.P("\tif err != nil {")
	g.P("\t\treturn nil, ", generate.FmtPackage.Ident("Errorf"), "(\"error constructing grpc client connection: %w\", err)")
	g.P("\t}")
	g.P()
	g.P("\t// set client connection and gRPC client")
	g.P("\tclient.conn = conn")
	g.P("\tclient.grpcClient = New", svc.GoName, "Client(conn)")
	g.P()
	g.P("\t// return constructed client")
	g.P("\treturn client, nil")
	g.P("}")
	g.P()

	// Generate method implementations
	for i, method := range svc.Methods {
		// Generate method documentation
		g.P("// ", method.GoName, " executes the ", method.GoName, " RPC method on the ", svc.GoName, " service.")
		g.P("// This method automatically handles authentication, timeouts, and distributed tracing.")
		g.P("//")
		g.P("// Timeout Behavior:")
		g.P("//   - If the context already has a deadline, it will be respected")
		g.P("//   - If no deadline is set, the client's configured timeout will be applied")
		g.P("//   - The method will be cancelled if the timeout is exceeded")
		g.P("//")
		g.P("// Authentication:")
		g.P("//   - Automatically includes API key in request headers")
		g.P("//   - Authentication is configured during client creation")
		g.P("//")
		g.P("// Distributed Tracing:")
		g.P("//   - Creates a new span for this method call")
		g.P("//   - Span is automatically finished when the method returns")
		g.P("//")
		g.P("// Parameters:")
		g.P("//   - ctx: Context for the request (can include custom timeout, tracing, etc.)")
		g.P("//   - request: The ", method.Input.GoIdent, " containing the method parameters")
		g.P("//")
		g.P("// Returns:")
		g.P("//   - *", method.Output.GoIdent, ": The successful response from the service")
		g.P("//   - error: Any error that occurred during the request")
		g.P("//")
		g.P("// Example:")
		g.P("//")
		g.P("//\tresp, err := client.", method.GoName, "(ctx, &", method.Input.GoIdent, "{")
		g.P("//\t\t// populate request fields")
		g.P("//\t})")
		g.P("//\tif err != nil {")
		g.P("//\t\treturn fmt.Errorf(\"", strings.ToLower(method.GoName), " failed: %w\", err)")
		g.P("//\t}")
		g.P("func (s *", clientStructName, ") ", method.GoName, "(ctx context.Context, request *", method.Input.GoIdent, ") (*", method.Output.GoIdent, ", error) {")

		// Add timeout handling
		g.P("\t// apply timeout if no deadline is already set")
		g.P("\tif _, hasDeadline := ctx.Deadline(); !hasDeadline {")
		g.P("\t\tvar cancel context.CancelFunc")
		g.P("\t\tctx, cancel = context.WithTimeout(ctx, s.timeout)")
		g.P("\t\tdefer cancel()")
		g.P("\t}")
		g.P()

		// Add tracing
		g.P("\tctx, span := s.tracer.Start(")
		g.P("\t\tctx,")
		g.P("\t\t", svc.GoName, "ServiceProviderName+\"", method.GoName, "\",")
		g.P("\t)")
		g.P("\tdefer span.End()")
		g.P()

		// Make gRPC call
		g.P("\t// call the underlying gRPC client method")
		g.P("\t", strings.ToLower(string(method.GoName[0]))+method.GoName[1:]+"Response, err := s.grpcClient.", method.GoName, "(ctx, request)")
		g.P("\tif err != nil {")
		g.P("\t\treturn nil, err")
		g.P("\t}")
		g.P()
		g.P("\treturn ", strings.ToLower(string(method.GoName[0]))+method.GoName[1:]+"Response, nil")
		g.P("}")

		if i != len(svc.Methods)-1 {
			g.P()
		}
	}

	g.P()

	// Generate Close method
	g.P("// Close gracefully shuts down the gRPC client connection and releases all associated resources.")
	g.P("// This method should be called when the client is no longer needed to prevent resource leaks.")
	g.P("// It's safe to call Close() multiple times - subsequent calls will be no-ops.")
	g.P("//")
	g.P("// Best Practices:")
	g.P("//   - Always call Close() when done with the client")
	g.P("//   - Use defer client.Close() immediately after successful client creation")
	g.P("//   - Do not use the client after calling Close()")
	g.P("//")
	g.P("// Example:")
	g.P("//")
	g.P("//\tclient, err := New", svc.GoName, "GRPCClient(...)")
	g.P("//\tif err != nil {")
	g.P("//\t\treturn err")
	g.P("//\t}")
	g.P("//\tdefer client.Close() // Ensure cleanup")
	g.P("//")
	g.P("// Returns:")
	g.P("//   - error: Any error that occurred while closing the connection")
	g.P("func (s *", clientStructName, ") Close() error {")
	g.P("\tif s.conn != nil {")
	g.P("\t\treturn s.conn.Close()")
	g.P("\t}")
	g.P("\treturn nil")
	g.P("}")
	g.P()

	// Generate Group method
	g.P("// Group returns the group resource name configured for this client.")
	g.P("// The group determines the authorization context for all API requests")
	g.P("// and is sent as an \"x-group-id\" header with every request.")
	g.P("//")
	g.P("// Returns:")
	g.P("//   - string: The configured group resource name in format groups/{group_id}")
	g.P("func (s *", clientStructName, ") Group() string {")
	g.P("\treturn s.group")
	g.P("}")
	g.P()

	// Generate validateAuth helper
	g.P("// validateAuth ensures that authentication credentials and group ID are properly configured.")
	g.P("// This method is called during client initialization to prevent runtime authentication failures.")
	g.P("//")
	g.P("// Requirements:")
	g.P("//   - At least one authentication method must be configured")
	g.P("//   - Group must be set for all public API calls")
	g.P("//")
	g.P("// Supported Authentication Methods:")
	g.P("//   - API Key: Set via WithAPIKey() option or MESH_API_CREDENTIALS file")
	g.P("//")
	g.P("// Returns:")
	g.P("//   - nil: If authentication and group are properly configured")
	g.P("//   - error: If authentication method or group is missing")
	g.P("func (c *", clientStructName, ") validateAuth() error {")
	g.P("\tif c.apiKey == \"\" {")
	g.P("\t\treturn ", generate.ErrorsPackage.Ident("New"), "(\"api key not set. set credentials via MESH_API_CREDENTIALS file, or use WithAPIKey option\")")
	g.P("\t}")
	g.P("\tif c.group == \"\" {")
	g.P("\t\treturn ", generate.ErrorsPackage.Ident("New"), "(\"group not set. set via MESH_API_CREDENTIALS file or WithGroup option\")")
	g.P("\t}")
	g.P("\treturn nil")
	g.P("}")
	g.P()

	// Generate authInterceptor helper
	g.P("// authInterceptor creates and returns the gRPC unary interceptor for authentication.")
	g.P("// This interceptor automatically adds authentication and group ID headers to all outgoing requests.")
	g.P("//")
	g.P("// Headers Added:")
	g.P("//   - API Key: \"Authorization: Bearer <api-key>\" header")
	g.P("//   - Group ID: \"x-group-id: <group>\" header")
	g.P("//")
	g.P("// The interceptor is automatically applied to all method calls and handles the")
	g.P("// authentication and authorization context transparently without requiring manual header management.")
	g.P("//")
	g.P("// Returns:")
	g.P("//   - grpc.UnaryClientInterceptor: Configured authentication and group context interceptor")
	g.P("func (c *", clientStructName, ") authInterceptor() ", generate.GRPCPkg.Ident("UnaryClientInterceptor"), " {")
	g.P("\treturn func(ctx ", generate.ContextPkg.Ident("Context"), ", method string, req, reply any, cc *", generate.GRPCPkg.Ident("ClientConn"), ", invoker ", generate.GRPCPkg.Ident("UnaryInvoker"), ", opts ...", generate.GRPCPkg.Ident("CallOption"), ") error {")
	g.P("\t\tctx = ", generate.GRPCMetadataPkg.Ident("AppendToOutgoingContext"), "(")
	g.P("\t\t\tctx,")
	g.P("\t\t\t", generate.CommonPkg.Ident("AuthorizationHeaderKey"), ",")
	g.P("\t\t\t", generate.CommonPkg.Ident("BearerPrefix"), "+c.apiKey,")
	g.P("\t\t\t", generate.CommonPkg.Ident("GroupHeaderKey"), ",")
	g.P("\t\t\tc.group,")
	g.P("\t\t)")
	g.P("\t\treturn invoker(ctx, method, req, reply, cc, opts...)")
	g.P("\t}")
	g.P("}")

	return nil
}
