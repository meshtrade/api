// Code generated by protoc-gen-meshgo. DO NOT EDIT.
// source: api/proto/instrument/feeprofile/lifecycleEventCalculationConfig.proto
package feeprofile

import (
	errors "errors"
	fmt "fmt"
	bson "go.mongodb.org/mongo-driver/bson"
	bsontype "go.mongodb.org/mongo-driver/bson/bsontype"
	reflect "reflect"
)

// Ensure that LifecycleEventCalculationConfig implements the bson.Marshaler interface
var _ bson.Marshaler = &LifecycleEventCalculationConfig{}

// MarshalBSONValue is called to marshal LifecycleEventCalculationConfig when it is embedded as a field in another struct.
// This behaviour is overridden to get desired nil behaviour.
func (l *LifecycleEventCalculationConfig) MarshalBSONValue() (bsontype.Type, []byte, error) {
	// if this LifecycleEventCalculationConfig is nil then return the bson null type and no data
	if l == nil {
		return bson.TypeNull, nil, nil
	}

	// otherwise call the MarshalBSON method to get data and a possible error
	bsonData, err := l.MarshalBSON()

	// then return the bson embedded document type along with the associated data and error
	return bson.TypeEmbeddedDocument, bsonData, err
}

// MarshalBSON controls the marshalling of a LifecycleEventCalculationConfig to BSON for persistence to mongo db
func (l *LifecycleEventCalculationConfig) MarshalBSON() ([]byte, error) {
	// confirm that the interface field is set
	if l.LifecycleEventCalculationConfig == nil {
		return nil, errors.New("interface field is not set on LifecycleEventCalculationConfig")
	}

	// strip off interface wrapper and marshal (thereby calling the MarshalBSON method of the implementation)
	switch typed := l.LifecycleEventCalculationConfig.(type) {
	case *LifecycleEventCalculationConfig_AmountLifecycleEventCalculationConfig:
		return bson.Marshal(typed.AmountLifecycleEventCalculationConfig)

	case *LifecycleEventCalculationConfig_RateLifecycleEventCalculationConfig:
		return bson.Marshal(typed.RateLifecycleEventCalculationConfig)

	default:
		return nil, fmt.Errorf("unexpected implementation of LifecycleEventCalculationConfig: '%s'", reflect.TypeOf(typed))
	}
}

// Ensure that LifecycleEventCalculationConfig implements the bson.Unmarshaler interface
var _ bson.Unmarshaler = &LifecycleEventCalculationConfig{}

// MarshalBSON controls the unmarshalling of a LifecycleEventCalculationConfig from BSON
func (l *LifecycleEventCalculationConfig) UnmarshalBSON(data []byte) error {
	// perform an unmarshal to get the @type
	typeHolder := new(struct {
		AtType string `bson:"@type"`
	})
	if err := bson.Unmarshal(data, &typeHolder); err != nil {
		return fmt.Errorf("error unmarshalling to get @type for implementation of LifecycleEventCalculationConfig: %w", err)
	}

	// based on the value of the @type tag unmarshal into specific type
	switch typeHolder.AtType {
	case amountLifecycleEventCalculationConfigBSONAtTypeName:
		unmarshalledImplementation := new(AmountLifecycleEventCalculationConfig)
		if err := bson.Unmarshal(data, unmarshalledImplementation); err != nil {
			return fmt.Errorf("error unmarshalling implementation of LifecycleEventCalculationConfig 'AmountLifecycleEventCalculationConfig': %w", err)
		}
		l.LifecycleEventCalculationConfig = &LifecycleEventCalculationConfig_AmountLifecycleEventCalculationConfig{
			AmountLifecycleEventCalculationConfig: unmarshalledImplementation,
		}

	case rateLifecycleEventCalculationConfigBSONAtTypeName:
		unmarshalledImplementation := new(RateLifecycleEventCalculationConfig)
		if err := bson.Unmarshal(data, unmarshalledImplementation); err != nil {
			return fmt.Errorf("error unmarshalling implementation of LifecycleEventCalculationConfig 'RateLifecycleEventCalculationConfig': %w", err)
		}
		l.LifecycleEventCalculationConfig = &LifecycleEventCalculationConfig_RateLifecycleEventCalculationConfig{
			RateLifecycleEventCalculationConfig: unmarshalledImplementation,
		}

	default:
		return fmt.Errorf("unexpected or unsupported @type '%s'", typeHolder.AtType)
	}

	return nil
}
