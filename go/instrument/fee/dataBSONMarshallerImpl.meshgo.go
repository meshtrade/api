// Code generated by protoc-gen-meshgo. DO NOT EDIT.
// source: api/proto/instrument/fee/data.proto
package fee

import (
	errors "errors"
	fmt "fmt"
	bson "go.mongodb.org/mongo-driver/bson"
	bsontype "go.mongodb.org/mongo-driver/bson/bsontype"
	reflect "reflect"
)

// Ensure that Data implements the bson.Marshaler interface
var _ bson.Marshaler = &Data{}

// MarshalBSONValue is called to marshal Data when it is embedded as a field in another struct.
// This behaviour is overridden to get desired nil behaviour.
func (d *Data) MarshalBSONValue() (bsontype.Type, []byte, error) {
	// if this Data is nil then return the bson null type and no data
	if d == nil {
		return bson.TypeNull, nil, nil
	}

	// otherwise call the MarshalBSON method to get data and a possible error
	bsonData, err := d.MarshalBSON()

	// then return the bson embedded document type along with the associated data and error
	return bson.TypeEmbeddedDocument, bsonData, err
}

// MarshalBSON controls the marshalling of a Data to BSON for persistence to mongo db
func (d *Data) MarshalBSON() ([]byte, error) {
	// confirm that the interface field is set
	if d.Data == nil {
		return nil, errors.New("interface field is not set on Data")
	}

	// strip off interface wrapper and marshal (thereby calling the MarshalBSON method of the implementation)
	switch typed := d.Data.(type) {
	case *Data_AmountData:
		return bson.Marshal(typed.AmountData)

	case *Data_RateData:
		return bson.Marshal(typed.RateData)

	case *Data_PerUnitData:
		return bson.Marshal(typed.PerUnitData)

	default:
		return nil, fmt.Errorf("unexpected implementation of Data: '%s'", reflect.TypeOf(typed))
	}
}

// Ensure that Data implements the bson.Unmarshaler interface
var _ bson.Unmarshaler = &Data{}

// MarshalBSON controls the unmarshalling of a Data from BSON
func (d *Data) UnmarshalBSON(data []byte) error {
	// perform an unmarshal to get the @type
	typeHolder := new(struct {
		AtType string `bson:"@type"`
	})
	if err := bson.Unmarshal(data, &typeHolder); err != nil {
		return fmt.Errorf("error unmarshalling to get @type for implementation of Data: %w", err)
	}

	// based on the value of the @type tag unmarshal into specific type
	switch typeHolder.AtType {
	case amountDataBSONAtTypeName:
		unmarshalledImplementation := new(AmountData)
		if err := bson.Unmarshal(data, unmarshalledImplementation); err != nil {
			return fmt.Errorf("error unmarshalling implementation of Data 'AmountData': %w", err)
		}
		d.Data = &Data_AmountData{
			AmountData: unmarshalledImplementation,
		}

	case rateDataBSONAtTypeName:
		unmarshalledImplementation := new(RateData)
		if err := bson.Unmarshal(data, unmarshalledImplementation); err != nil {
			return fmt.Errorf("error unmarshalling implementation of Data 'RateData': %w", err)
		}
		d.Data = &Data_RateData{
			RateData: unmarshalledImplementation,
		}

	case perUnitDataBSONAtTypeName:
		unmarshalledImplementation := new(PerUnitData)
		if err := bson.Unmarshal(data, unmarshalledImplementation); err != nil {
			return fmt.Errorf("error unmarshalling implementation of Data 'PerUnitData': %w", err)
		}
		d.Data = &Data_PerUnitData{
			PerUnitData: unmarshalledImplementation,
		}

	default:
		return fmt.Errorf("unexpected or unsupported @type '%s'", typeHolder.AtType)
	}

	return nil
}
