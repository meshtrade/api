// Code generated by protoc-gen-meshgo. DO NOT EDIT.
// source: meshtrade/iam/api_user/v1/service.proto
package api_user_v1

import (
	context "context"
	grpc "github.com/meshtrade/api/go/grpc"
	config "github.com/meshtrade/api/go/grpc/config"
)

// APIUserServiceClientInterface is a gRPC service for the APIUserService service.
// It combines the service interface with resource management capabilities using
// the common BaseGRPCClient for consistent authentication, timeouts, and tracing.
//
// Full Service documentation: https://meshtrade.github.io/api/docs/api-reference/iam/api_user/v1
//
// Basic service usage with default SDK Configuration:
//
//	service, err := NewAPIUserService()
//	if err != nil {
//		log.Fatal(err)
//	}
//	defer service.Close() // ensures proper cleanup of underlying connection
//
// With default configuration API credentials are searched for using the standard discovery hierarchy:
//
// 1. MESH_API_CREDENTIALS environment variable
//
// 2. Default credential file location:
//
//   - Linux:   $XDG_CONFIG_HOME/mesh/credentials.json or fallback to $HOME/.config/mesh/credentials.json
//   - macOS:   $HOME/Library/Application Support/mesh/credentials.json
//   - Windows: C:\Users\<user>\AppData\Roaming\mesh\credentials.json
//
// For more information on authentication: https://meshtrade.github.io/api/docs/architecture/authentication
//
// The service may also be configured with custom options:
//
//	service, err := NewAPIUserService(
//		config.WithURL("api.staging.example.com:443"),
//		config.WithAPIKey("your-api-key"),
//		config.WithGroup("groups/your-group-id"),
//		config.WithTimeout(30 * time.Second),
//	)
//	if err != nil {
//		log.Fatal(err)
//	}
//	defer service.Close() // ensures proper cleanup of underlying connection
//
// For more information on service configuration: https://meshtrade.github.io/api/docs/architecture/sdk-configuration
type APIUserServiceClientInterface interface {
	grpc.GRPCClient

	// Retrieves a single API user by its unique identifier.
	GetAPIUser(ctx context.Context, request *GetAPIUserRequest) (*APIUser, error)
	// Creates a new API user with the specified configuration.
	// The API user will be created in the authenticated group context
	// and assigned the provided roles. The system generates a unique
	// identifier and API key for authentication.
	CreateAPIUser(ctx context.Context, request *CreateAPIUserRequest) (*APIUser, error)
	// Assign roles to an existing api user within the authenticated group context.
	// The role assignment enables the api user to perform operations according
	// to the permissions associated with that role within the group hierarchy.
	AssignRolesToAPIUser(ctx context.Context, request *AssignRolesToAPIUserRequest) (*APIUser, error)
	// Revoke roles from an existing API user within the authenticated group context.
	// The role revocation removes the permissions associated with that role from
	// the API user within the group hierarchy. The API user will no longer be able
	// to perform operations that require the revoked role.
	RevokeRolesFromAPIUser(ctx context.Context, request *RevokeRolesFromAPIUserRequest) (*APIUser, error)
	// Lists all API users in the authenticated group context.
	// Returns all API users that belong to the current group,
	// regardless of their active/inactive state.
	ListAPIUsers(ctx context.Context, request *ListAPIUsersRequest) (*ListAPIUsersResponse, error)
	// Searches API users using display name filtering.
	// Performs substring matching on API user display names
	// within the authenticated group context.
	SearchAPIUsers(ctx context.Context, request *SearchAPIUsersRequest) (*SearchAPIUsersResponse, error)
	// Activates an API user, enabling API key authentication.
	// Changes the API user state to active, allowing the associated
	// API key to be used for authentication and authorization.
	ActivateAPIUser(ctx context.Context, request *ActivateAPIUserRequest) (*APIUser, error)
	// Deactivates an API user, disabling API key authentication.
	// Changes the API user state to inactive, preventing the associated
	// API key from being used for authentication.
	DeactivateAPIUser(ctx context.Context, request *DeactivateAPIUserRequest) (*APIUser, error)
	// Retrieves an API user using its API key hash.
	// This method is used for authentication flows to lookup
	// an API user based on the hash of their API key.
	GetAPIUserByKeyHash(ctx context.Context, request *GetAPIUserByKeyHashRequest) (*APIUser, error)

	// WithGroup returns a new client instance with a different group context
	WithGroup(group string) APIUserServiceClientInterface
}

// aPIUserService is the internal implementation of the APIUserServiceClientInterface interface.
// It embeds BaseGRPCClient to provide all common gRPC functionality including validation.
type aPIUserService struct {
	*grpc.BaseGRPCClient[APIUserServiceClient]
}

// ensure aPIUserService implements the APIUserServiceClientInterface interface
var _ APIUserServiceClientInterface = &aPIUserService{}

// NewAPIUserService creates and initializes the APIUserService service.
// The service uses the common BaseGRPCClient for all functionality including
// connection management, authentication, timeouts, and distributed tracing.
//
// Full Service documentation: https://meshtrade.github.io/api/docs/api-reference/iam/api_user/v1
//
// With default configuration API credentials are searched for using the standard discovery hierarchy:
//
// 1. MESH_API_CREDENTIALS environment variable
//
// 2. Default credential file location:
//
//   - Linux:   $XDG_CONFIG_HOME/mesh/credentials.json or fallback to $HOME/.config/mesh/credentials.json
//   - macOS:   $HOME/Library/Application Support/mesh/credentials.json
//   - Windows: C:\Users\<user>\AppData\Roaming\mesh\credentials.json
//
// For more information on authentication: https://meshtrade.github.io/api/docs/architecture/authentication
//
// For more information on service configuration: https://meshtrade.github.io/api/docs/architecture/sdk-configuration
//
// Examples:
//
//	// Create with default configuration
//	service, err := NewAPIUserService()
//	if err != nil {
//		log.Fatal(err)
//	}
//	defer service.Close()
//
//	// Create with custom configuration
//	service, err := NewAPIUserService(
//		config.WithURL("api.example.com:443"),
//		config.WithAPIKey("your-api-key"),
//		config.WithGroup("groups/your-group-id"),
//	)
//	if err != nil {
//		log.Fatal(err)
//	}
//	defer service.Close()
//
// Parameters:
//   - opts: Functional options to configure the client
//
// Returns:
//   - APIUserServiceClientInterface: Configured service instance
//   - error: Configuration or connection error
func NewAPIUserService(opts ...config.ServiceOption) (APIUserServiceClientInterface, error) {
	base, err := grpc.NewBaseGRPCClient(
		APIUserServiceServiceProviderName,
		NewAPIUserServiceClient,
		opts...,
	)
	if err != nil {
		return nil, err
	}

	return &aPIUserService{BaseGRPCClient: base}, nil
}

// WithGroup returns a new client instance configured with a different group context.
// This enables convenient group context switching without reconstructing the entire client.
// All other configuration (URL, port, timeout, tracer, API key, etc.) is preserved.
//
// The group parameter must be in the format 'groups/{group_id}' where group_id is a valid
// group identifier (typically a ULID). The new client instance shares no state with the
// original client, allowing safe concurrent usage across different goroutines.
//
// Example:
//
//	// Create initial client with default group from credentials
//	service, err := NewAPIUserService()
//	if err != nil {
//		log.Fatal(err)
//	}
//	defer service.Close()
//
//	// Switch to a different group context
//	altService := service.WithGroup("groups/01ARZ3NDEKTSV4RRFFQ69G5FAV")
//	defer altService.Close()
//
//	// Both clients can be used independently
//	resp1, _ := service.SomeMethod(ctx, req)      // Uses original group
//	resp2, _ := altService.SomeMethod(ctx, req)   // Uses alternative group
//
// Parameters:
//   - group: The group resource name in format 'groups/{group_id}'
//
// Returns:
//   - APIUserServiceClientInterface: New client instance with updated group context
func (s *aPIUserService) WithGroup(group string) APIUserServiceClientInterface {
	// Create new base client with copied configuration but new group
	newBase := s.BaseGRPCClient.WithGroup(group)

	// Return new service instance wrapping the new base client
	return &aPIUserService{BaseGRPCClient: newBase}
}

// GetAPIUser executes the GetAPIUser RPC method with automatic
// client-side validation, timeout handling, distributed tracing, and authentication.
func (s *aPIUserService) GetAPIUser(ctx context.Context, request *GetAPIUserRequest) (*APIUser, error) {
	return grpc.Execute(s.Executor(), ctx, "GetAPIUser", request, func(ctx context.Context) (*APIUser, error) {
		return s.GrpcClient().GetAPIUser(ctx, request)
	})
}

// CreateAPIUser executes the CreateAPIUser RPC method with automatic
// client-side validation, timeout handling, distributed tracing, and authentication.
func (s *aPIUserService) CreateAPIUser(ctx context.Context, request *CreateAPIUserRequest) (*APIUser, error) {
	return grpc.Execute(s.Executor(), ctx, "CreateAPIUser", request, func(ctx context.Context) (*APIUser, error) {
		return s.GrpcClient().CreateAPIUser(ctx, request)
	})
}

// AssignRolesToAPIUser executes the AssignRolesToAPIUser RPC method with automatic
// client-side validation, timeout handling, distributed tracing, and authentication.
func (s *aPIUserService) AssignRolesToAPIUser(ctx context.Context, request *AssignRolesToAPIUserRequest) (*APIUser, error) {
	return grpc.Execute(s.Executor(), ctx, "AssignRolesToAPIUser", request, func(ctx context.Context) (*APIUser, error) {
		return s.GrpcClient().AssignRolesToAPIUser(ctx, request)
	})
}

// RevokeRolesFromAPIUser executes the RevokeRolesFromAPIUser RPC method with automatic
// client-side validation, timeout handling, distributed tracing, and authentication.
func (s *aPIUserService) RevokeRolesFromAPIUser(ctx context.Context, request *RevokeRolesFromAPIUserRequest) (*APIUser, error) {
	return grpc.Execute(s.Executor(), ctx, "RevokeRolesFromAPIUser", request, func(ctx context.Context) (*APIUser, error) {
		return s.GrpcClient().RevokeRolesFromAPIUser(ctx, request)
	})
}

// ListAPIUsers executes the ListAPIUsers RPC method with automatic
// client-side validation, timeout handling, distributed tracing, and authentication.
func (s *aPIUserService) ListAPIUsers(ctx context.Context, request *ListAPIUsersRequest) (*ListAPIUsersResponse, error) {
	return grpc.Execute(s.Executor(), ctx, "ListAPIUsers", request, func(ctx context.Context) (*ListAPIUsersResponse, error) {
		return s.GrpcClient().ListAPIUsers(ctx, request)
	})
}

// SearchAPIUsers executes the SearchAPIUsers RPC method with automatic
// client-side validation, timeout handling, distributed tracing, and authentication.
func (s *aPIUserService) SearchAPIUsers(ctx context.Context, request *SearchAPIUsersRequest) (*SearchAPIUsersResponse, error) {
	return grpc.Execute(s.Executor(), ctx, "SearchAPIUsers", request, func(ctx context.Context) (*SearchAPIUsersResponse, error) {
		return s.GrpcClient().SearchAPIUsers(ctx, request)
	})
}

// ActivateAPIUser executes the ActivateAPIUser RPC method with automatic
// client-side validation, timeout handling, distributed tracing, and authentication.
func (s *aPIUserService) ActivateAPIUser(ctx context.Context, request *ActivateAPIUserRequest) (*APIUser, error) {
	return grpc.Execute(s.Executor(), ctx, "ActivateAPIUser", request, func(ctx context.Context) (*APIUser, error) {
		return s.GrpcClient().ActivateAPIUser(ctx, request)
	})
}

// DeactivateAPIUser executes the DeactivateAPIUser RPC method with automatic
// client-side validation, timeout handling, distributed tracing, and authentication.
func (s *aPIUserService) DeactivateAPIUser(ctx context.Context, request *DeactivateAPIUserRequest) (*APIUser, error) {
	return grpc.Execute(s.Executor(), ctx, "DeactivateAPIUser", request, func(ctx context.Context) (*APIUser, error) {
		return s.GrpcClient().DeactivateAPIUser(ctx, request)
	})
}

// GetAPIUserByKeyHash executes the GetAPIUserByKeyHash RPC method with automatic
// client-side validation, timeout handling, distributed tracing, and authentication.
func (s *aPIUserService) GetAPIUserByKeyHash(ctx context.Context, request *GetAPIUserByKeyHashRequest) (*APIUser, error) {
	return grpc.Execute(s.Executor(), ctx, "GetAPIUserByKeyHash", request, func(ctx context.Context) (*APIUser, error) {
		return s.GrpcClient().GetAPIUserByKeyHash(ctx, request)
	})
}
