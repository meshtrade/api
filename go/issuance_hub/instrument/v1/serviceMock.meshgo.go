// Code generated by protoc-gen-meshgo. DO NOT EDIT.
// source: meshtrade/issuance_hub/instrument/v1/service.proto
package instrumentv1

import (
	context "context"
	sync "sync"
	testing "testing"
)

// Ensure that MockInstrumentService implements the InstrumentService interface
var _ InstrumentService = &MockInstrumentService{}

// MockInstrumentService is a mock implementation of the InstrumentService interface.
type MockInstrumentService struct {
	mutex                         sync.Mutex
	T                             *testing.T
	GetInstrumentFunc             func(t *testing.T, m *MockInstrumentService, ctx context.Context, request *GetInstrumentRequest) (*Instrument, error)
	GetInstrumentFuncInvocations  int
	MintInstrumentFunc            func(t *testing.T, m *MockInstrumentService, ctx context.Context, request *MintInstrumentRequest) (*MintInstrumentResponse, error)
	MintInstrumentFuncInvocations int
	BurnInstrumentFunc            func(t *testing.T, m *MockInstrumentService, ctx context.Context, request *BurnInstrumentRequest) (*BurnInstrumentResponse, error)
	BurnInstrumentFuncInvocations int
}

func (m *MockInstrumentService) GetInstrument(ctx context.Context, request *GetInstrumentRequest) (*Instrument, error) {
	m.mutex.Lock()
	m.GetInstrumentFuncInvocations++
	m.mutex.Unlock()
	if m.GetInstrumentFunc == nil {
		return nil, nil
	}
	return m.GetInstrumentFunc(m.T, m, ctx, request)
}

func (m *MockInstrumentService) MintInstrument(ctx context.Context, request *MintInstrumentRequest) (*MintInstrumentResponse, error) {
	m.mutex.Lock()
	m.MintInstrumentFuncInvocations++
	m.mutex.Unlock()
	if m.MintInstrumentFunc == nil {
		return nil, nil
	}
	return m.MintInstrumentFunc(m.T, m, ctx, request)
}

func (m *MockInstrumentService) BurnInstrument(ctx context.Context, request *BurnInstrumentRequest) (*BurnInstrumentResponse, error) {
	m.mutex.Lock()
	m.BurnInstrumentFuncInvocations++
	m.mutex.Unlock()
	if m.BurnInstrumentFunc == nil {
		return nil, nil
	}
	return m.BurnInstrumentFunc(m.T, m, ctx, request)
}
