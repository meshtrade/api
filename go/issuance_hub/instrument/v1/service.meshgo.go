// Code generated by protoc-gen-meshgo. DO NOT EDIT.
// source: meshtrade/issuance_hub/instrument/v1/service.proto
package instrumentv1

import (
	context "context"
	fmt "fmt"
	grpc "github.com/meshtrade/api/go/grpc"
	config "github.com/meshtrade/api/go/grpc/config"
)

// InstrumentServiceClientInterface is a gRPC service for the InstrumentService service.
// It combines the service interface with resource management capabilities using
// the common BaseGRPCClient for consistent authentication, timeouts, and tracing.
//
// Full Service documentation: https://meshtrade.github.io/api/docs/api-reference/issuance_hub/instrument/v1
//
// Basic service usage with default SDK Configuration:
//
//	service, err := NewInstrumentService()
//	if err != nil {
//		log.Fatal(err)
//	}
//	defer service.Close() // ensures proper cleanup of underlying connection
//
// With default configuration API credentials are searched for using the standard discovery hierarchy:
//
// 1. MESH_API_CREDENTIALS environment variable
//
// 2. Default credential file location:
//
//   - Linux:   $XDG_CONFIG_HOME/mesh/credentials.json or fallback to $HOME/.config/mesh/credentials.json
//   - macOS:   $HOME/Library/Application Support/mesh/credentials.json
//   - Windows: C:\Users\<user>\AppData\Roaming\mesh\credentials.json
//
// For more information on authentication: https://meshtrade.github.io/api/docs/architecture/authentication
//
// The service may also be configured with custom options:
//
//	service, err := NewInstrumentService(
//		config.WithURL("api.staging.example.com:443"),
//		config.WithAPIKey("your-api-key"),
//		config.WithGroup("groups/your-group-id"),
//		config.WithTimeout(30 * time.Second),
//	)
//	if err != nil {
//		log.Fatal(err)
//	}
//	defer service.Close() // ensures proper cleanup of underlying connection
//
// For more information on service configuration: https://meshtrade.github.io/api/docs/architecture/sdk-configuration
type InstrumentServiceClientInterface interface {
	InstrumentService
	grpc.GRPCClient
}

// instrumentService is the internal implementation of the InstrumentServiceClientInterface interface.
// It embeds BaseGRPCClient to provide all common gRPC functionality including validation.
type instrumentService struct {
	*grpc.BaseGRPCClient[InstrumentServiceClient]
}

// ensure instrumentService implements the InstrumentServiceClientInterface interface
var _ InstrumentServiceClientInterface = &instrumentService{}

// NewInstrumentService creates and initializes the InstrumentService service.
// The service uses the common BaseGRPCClient for all functionality including
// connection management, authentication, timeouts, and distributed tracing.
//
// Full Service documentation: https://meshtrade.github.io/api/docs/api-reference/issuance_hub/instrument/v1
//
// With default configuration API credentials are searched for using the standard discovery hierarchy:
//
// 1. MESH_API_CREDENTIALS environment variable
//
// 2. Default credential file location:
//
//   - Linux:   $XDG_CONFIG_HOME/mesh/credentials.json or fallback to $HOME/.config/mesh/credentials.json
//   - macOS:   $HOME/Library/Application Support/mesh/credentials.json
//   - Windows: C:\Users\<user>\AppData\Roaming\mesh\credentials.json
//
// For more information on authentication: https://meshtrade.github.io/api/docs/architecture/authentication
//
// For more information on service configuration: https://meshtrade.github.io/api/docs/architecture/sdk-configuration
//
// Examples:
//
//	// Create with default configuration
//	service, err := NewInstrumentService()
//	if err != nil {
//		log.Fatal(err)
//	}
//	defer service.Close()
//
//	// Create with custom configuration
//	service, err := NewInstrumentService(
//		config.WithURL("api.example.com:443"),
//		config.WithAPIKey("your-api-key"),
//		config.WithGroup("groups/your-group-id"),
//	)
//	if err != nil {
//		log.Fatal(err)
//	}
//	defer service.Close()
//
// Parameters:
//   - opts: Functional options to configure the client
//
// Returns:
//   - InstrumentServiceClientInterface: Configured service instance
//   - error: Configuration or connection error
func NewInstrumentService(opts ...config.ServiceOption) (InstrumentServiceClientInterface, error) {
	base, err := grpc.NewBaseGRPCClient(
		InstrumentServiceServiceProviderName,
		NewInstrumentServiceClient,
		opts...,
	)
	if err != nil {
		return nil, err
	}

	return &instrumentService{BaseGRPCClient: base}, nil
}

// GetInstrument executes the GetInstrument RPC method with automatic
// client-side validation, timeout handling, distributed tracing, and authentication.
func (s *instrumentService) GetInstrument(ctx context.Context, request *GetInstrumentRequest) (*Instrument, error) {
	// Validate request using protovalidate
	if err := s.Validator().Validate(request); err != nil {
		return nil, fmt.Errorf("request validation failed: %w", err)
	}

	return grpc.Execute(s.Executor(), ctx, "GetInstrument", func(ctx context.Context) (*Instrument, error) {
		return s.GrpcClient().GetInstrument(ctx, request)
	})
}

// MintInstrument executes the MintInstrument RPC method with automatic
// client-side validation, timeout handling, distributed tracing, and authentication.
func (s *instrumentService) MintInstrument(ctx context.Context, request *MintInstrumentRequest) (*MintInstrumentResponse, error) {
	// Validate request using protovalidate
	if err := s.Validator().Validate(request); err != nil {
		return nil, fmt.Errorf("request validation failed: %w", err)
	}

	return grpc.Execute(s.Executor(), ctx, "MintInstrument", func(ctx context.Context) (*MintInstrumentResponse, error) {
		return s.GrpcClient().MintInstrument(ctx, request)
	})
}

// BurnInstrument executes the BurnInstrument RPC method with automatic
// client-side validation, timeout handling, distributed tracing, and authentication.
func (s *instrumentService) BurnInstrument(ctx context.Context, request *BurnInstrumentRequest) (*BurnInstrumentResponse, error) {
	// Validate request using protovalidate
	if err := s.Validator().Validate(request); err != nil {
		return nil, fmt.Errorf("request validation failed: %w", err)
	}

	return grpc.Execute(s.Executor(), ctx, "BurnInstrument", func(ctx context.Context) (*BurnInstrumentResponse, error) {
		return s.GrpcClient().BurnInstrument(ctx, request)
	})
}
