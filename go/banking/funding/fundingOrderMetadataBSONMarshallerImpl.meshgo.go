// Code generated by protoc-gen-meshgo. DO NOT EDIT.
// source: api/proto/banking/funding/fundingOrderMetadata.proto
package funding

import (
	errors "errors"
	fmt "fmt"
	bson "go.mongodb.org/mongo-driver/bson"
	bsontype "go.mongodb.org/mongo-driver/bson/bsontype"
	reflect "reflect"
)

// Ensure that MetaData implements the bson.Marshaler interface
var _ bson.Marshaler = &MetaData{}

// MarshalBSONValue is called to marshal MetaData when it is embedded as a field in another struct.
// This behaviour is overridden to get desired nil behaviour.
func (m *MetaData) MarshalBSONValue() (bsontype.Type, []byte, error) {
	// if this MetaData is nil then return the bson null type and no data
	if m == nil {
		return bson.TypeNull, nil, nil
	}

	// otherwise call the MarshalBSON method to get data and a possible error
	bsonData, err := m.MarshalBSON()

	// then return the bson embedded document type along with the associated data and error
	return bson.TypeEmbeddedDocument, bsonData, err
}

// MarshalBSON controls the marshalling of a MetaData to BSON for persistence to mongo db
func (m *MetaData) MarshalBSON() ([]byte, error) {
	// confirm that the interface field is set
	if m.MetaData == nil {
		return nil, errors.New("interface field is not set on MetaData")
	}

	// strip off interface wrapper and marshal (thereby calling the MarshalBSON method of the implementation)
	switch typed := m.MetaData.(type) {
	case *MetaData_PeachPaymentMetaData:
		return bson.Marshal(typed.PeachPaymentMetaData)

	case *MetaData_PeachSettlementMetaData:
		return bson.Marshal(typed.PeachSettlementMetaData)

	case *MetaData_DirectEFTMetaData:
		return bson.Marshal(typed.DirectEFTMetaData)

	default:
		return nil, fmt.Errorf("unexpected implementation of MetaData: '%s'", reflect.TypeOf(typed))
	}
}

// Ensure that MetaData implements the bson.Unmarshaler interface
var _ bson.Unmarshaler = &MetaData{}

// MarshalBSON controls the unmarshalling of a MetaData from BSON
func (m *MetaData) UnmarshalBSON(data []byte) error {
	// perform an unmarshal to get the @type
	typeHolder := new(struct {
		AtType string `bson:"@type"`
	})
	if err := bson.Unmarshal(data, &typeHolder); err != nil {
		return fmt.Errorf("error unmarshalling to get @type for implementation of MetaData: %w", err)
	}

	// based on the value of the @type tag unmarshal into specific type
	switch typeHolder.AtType {
	case peachPaymentMetaDataBSONAtTypeName:
		unmarshalledImplementation := new(PeachPaymentMetaData)
		if err := bson.Unmarshal(data, unmarshalledImplementation); err != nil {
			return fmt.Errorf("error unmarshalling implementation of MetaData 'PeachPaymentMetaData': %w", err)
		}
		m.MetaData = &MetaData_PeachPaymentMetaData{
			PeachPaymentMetaData: unmarshalledImplementation,
		}

	case peachSettlementMetaDataBSONAtTypeName:
		unmarshalledImplementation := new(PeachSettlementMetaData)
		if err := bson.Unmarshal(data, unmarshalledImplementation); err != nil {
			return fmt.Errorf("error unmarshalling implementation of MetaData 'PeachSettlementMetaData': %w", err)
		}
		m.MetaData = &MetaData_PeachSettlementMetaData{
			PeachSettlementMetaData: unmarshalledImplementation,
		}

	case directEFTMetaDataBSONAtTypeName:
		unmarshalledImplementation := new(DirectEFTMetaData)
		if err := bson.Unmarshal(data, unmarshalledImplementation); err != nil {
			return fmt.Errorf("error unmarshalling implementation of MetaData 'DirectEFTMetaData': %w", err)
		}
		m.MetaData = &MetaData_DirectEFTMetaData{
			DirectEFTMetaData: unmarshalledImplementation,
		}

	default:
		return fmt.Errorf("unexpected or unsupported @type '%s'", typeHolder.AtType)
	}

	return nil
}
