// Code generated by protoc-gen-meshgo. DO NOT EDIT.
// source: api/proto/banking/funding/service.proto
package funding

import (
	context "context"
	sync "sync"
	testing "testing"
)

// Ensure that MockService implements the Service interface
var _ Service = &MockService{}

// MockService is a mock implementation of the Service interface.
type MockService struct {
	mutex                       sync.Mutex
	T                           *testing.T
	CreateFunc                  func(t *testing.T, m *MockService, ctx context.Context, request *CreateRequest) (*CreateResponse, error)
	CreateFuncInvocations       int
	UpdateFunc                  func(t *testing.T, m *MockService, ctx context.Context, request *UpdateRequest) (*UpdateResponse, error)
	UpdateFuncInvocations       int
	ListFunc                    func(t *testing.T, m *MockService, ctx context.Context, request *ListRequest) (*ListResponse, error)
	ListFuncInvocations         int
	GetFunc                     func(t *testing.T, m *MockService, ctx context.Context, request *GetRequest) (*GetResponse, error)
	GetFuncInvocations          int
	SettleFunc                  func(t *testing.T, m *MockService, ctx context.Context, request *SettleRequest) (*SettleResponse, error)
	SettleFuncInvocations       int
	CancelFunc                  func(t *testing.T, m *MockService, ctx context.Context, request *CancelRequest) (*CancelResponse, error)
	CancelFuncInvocations       int
	ResolveStateFunc            func(t *testing.T, m *MockService, ctx context.Context, request *ResolveStateRequest) (*ResolveStateResponse, error)
	ResolveStateFuncInvocations int
}

func (m *MockService) Create(ctx context.Context, request *CreateRequest) (*CreateResponse, error) {
	m.mutex.Lock()
	m.CreateFuncInvocations++
	m.mutex.Unlock()
	if m.CreateFunc == nil {
		return nil, nil
	}
	return m.CreateFunc(m.T, m, ctx, request)
}

func (m *MockService) Update(ctx context.Context, request *UpdateRequest) (*UpdateResponse, error) {
	m.mutex.Lock()
	m.UpdateFuncInvocations++
	m.mutex.Unlock()
	if m.UpdateFunc == nil {
		return nil, nil
	}
	return m.UpdateFunc(m.T, m, ctx, request)
}

func (m *MockService) List(ctx context.Context, request *ListRequest) (*ListResponse, error) {
	m.mutex.Lock()
	m.ListFuncInvocations++
	m.mutex.Unlock()
	if m.ListFunc == nil {
		return nil, nil
	}
	return m.ListFunc(m.T, m, ctx, request)
}

func (m *MockService) Get(ctx context.Context, request *GetRequest) (*GetResponse, error) {
	m.mutex.Lock()
	m.GetFuncInvocations++
	m.mutex.Unlock()
	if m.GetFunc == nil {
		return nil, nil
	}
	return m.GetFunc(m.T, m, ctx, request)
}

func (m *MockService) Settle(ctx context.Context, request *SettleRequest) (*SettleResponse, error) {
	m.mutex.Lock()
	m.SettleFuncInvocations++
	m.mutex.Unlock()
	if m.SettleFunc == nil {
		return nil, nil
	}
	return m.SettleFunc(m.T, m, ctx, request)
}

func (m *MockService) Cancel(ctx context.Context, request *CancelRequest) (*CancelResponse, error) {
	m.mutex.Lock()
	m.CancelFuncInvocations++
	m.mutex.Unlock()
	if m.CancelFunc == nil {
		return nil, nil
	}
	return m.CancelFunc(m.T, m, ctx, request)
}

func (m *MockService) ResolveState(ctx context.Context, request *ResolveStateRequest) (*ResolveStateResponse, error) {
	m.mutex.Lock()
	m.ResolveStateFuncInvocations++
	m.mutex.Unlock()
	if m.ResolveStateFunc == nil {
		return nil, nil
	}
	return m.ResolveStateFunc(m.T, m, ctx, request)
}
