// Code generated by protoc-gen-meshgo. DO NOT EDIT.
// source: meshtrade/trading/limit_order/v1/service.proto
package limit_order_v1

import (
	context "context"
	grpc "github.com/meshtrade/api/go/grpc"
	config "github.com/meshtrade/api/go/grpc/config"
)

// LimitOrderServiceClientInterface is a gRPC service for the LimitOrderService service.
// It combines the service interface with resource management capabilities using
// the common BaseGRPCClient for consistent authentication, timeouts, and tracing.
//
// Full Service documentation: https://meshtrade.github.io/api/docs/api-reference/trading/limit_order/v1
//
// Basic service usage with default SDK Configuration:
//
//	service, err := NewLimitOrderService()
//	if err != nil {
//		log.Fatal(err)
//	}
//	defer service.Close() // ensures proper cleanup of underlying connection
//
// With default configuration API credentials are searched for using the standard discovery hierarchy:
//
// 1. MESH_API_CREDENTIALS environment variable
//
// 2. Default credential file location:
//
//   - Linux:   $XDG_CONFIG_HOME/mesh/credentials.json or fallback to $HOME/.config/mesh/credentials.json
//   - macOS:   $HOME/Library/Application Support/mesh/credentials.json
//   - Windows: C:\Users\<user>\AppData\Roaming\mesh\credentials.json
//
// For more information on authentication: https://meshtrade.github.io/api/docs/architecture/authentication
//
// The service may also be configured with custom options:
//
//	service, err := NewLimitOrderService(
//		config.WithURL("api.staging.example.com:443"),
//		config.WithAPIKey("your-api-key"),
//		config.WithGroup("groups/your-group-id"),
//		config.WithTimeout(30 * time.Second),
//	)
//	if err != nil {
//		log.Fatal(err)
//	}
//	defer service.Close() // ensures proper cleanup of underlying connection
//
// For more information on service configuration: https://meshtrade.github.io/api/docs/architecture/sdk-configuration
type LimitOrderServiceClientInterface interface {
	grpc.GRPCClient

	// Creates a new limit order.
	// Submits a limit order to the trading system. The order is validated and
	// submitted to the appropriate ledger for execution.
	CreateLimitOrder(ctx context.Context, request *CreateLimitOrderRequest) (*LimitOrder, error)
	// Cancels an existing limit order.
	// Initiates cancellation of a limit order on the ledger.
	CancelLimitOrder(ctx context.Context, request *CancelLimitOrderRequest) (*LimitOrder, error)
	// Retrieves a specific limit order by its resource name.
	// Provides access to limit order metadata and optionally fetches live
	// ledger data when populate_ledger_data is true.
	GetLimitOrder(ctx context.Context, request *GetLimitOrderRequest) (*LimitOrder, error)
	// Retrieves a limit order by its external reference.
	// Convenient lookup using client-provided external reference identifier.
	GetLimitOrderByExternalReference(ctx context.Context, request *GetLimitOrderByExternalReferenceRequest) (*LimitOrder, error)
	// Lists all limit orders within the authenticated group's scope.
	// Returns the complete set of limit orders accessible to the executing context.
	ListLimitOrders(ctx context.Context, request *ListLimitOrdersRequest) (*ListLimitOrdersResponse, error)
	// Searches limit orders using flexible filtering criteria.
	// Supports filtering by token, account, and populating live ledger data.
	SearchLimitOrders(ctx context.Context, request *SearchLimitOrdersRequest) (*SearchLimitOrdersResponse, error)
	// Monitors a limit order for real-time updates.
	// Supports lookup by either resource name or external reference using
	// the identifier oneof field in the request. Returns a stream of limit
	// order states as they change.
	MonitorLimitOrder(ctx context.Context, request *MonitorLimitOrderRequest) (LimitOrderService_MonitorLimitOrderClient, error)

	// WithGroup returns a new client instance with a different group context
	WithGroup(group string) LimitOrderServiceClientInterface
}

// limitOrderService is the internal implementation of the LimitOrderServiceClientInterface interface.
// It embeds BaseGRPCClient to provide all common gRPC functionality including validation.
type limitOrderService struct {
	*grpc.BaseGRPCClient[LimitOrderServiceClient]
}

// ensure limitOrderService implements the LimitOrderServiceClientInterface interface
var _ LimitOrderServiceClientInterface = &limitOrderService{}

// NewLimitOrderService creates and initializes the LimitOrderService service.
// The service uses the common BaseGRPCClient for all functionality including
// connection management, authentication, timeouts, and distributed tracing.
//
// Full Service documentation: https://meshtrade.github.io/api/docs/api-reference/trading/limit_order/v1
//
// With default configuration API credentials are searched for using the standard discovery hierarchy:
//
// 1. MESH_API_CREDENTIALS environment variable
//
// 2. Default credential file location:
//
//   - Linux:   $XDG_CONFIG_HOME/mesh/credentials.json or fallback to $HOME/.config/mesh/credentials.json
//   - macOS:   $HOME/Library/Application Support/mesh/credentials.json
//   - Windows: C:\Users\<user>\AppData\Roaming\mesh\credentials.json
//
// For more information on authentication: https://meshtrade.github.io/api/docs/architecture/authentication
//
// For more information on service configuration: https://meshtrade.github.io/api/docs/architecture/sdk-configuration
//
// Examples:
//
//	// Create with default configuration
//	service, err := NewLimitOrderService()
//	if err != nil {
//		log.Fatal(err)
//	}
//	defer service.Close()
//
//	// Create with custom configuration
//	service, err := NewLimitOrderService(
//		config.WithURL("api.example.com:443"),
//		config.WithAPIKey("your-api-key"),
//		config.WithGroup("groups/your-group-id"),
//	)
//	if err != nil {
//		log.Fatal(err)
//	}
//	defer service.Close()
//
// Parameters:
//   - opts: Functional options to configure the client
//
// Returns:
//   - LimitOrderServiceClientInterface: Configured service instance
//   - error: Configuration or connection error
func NewLimitOrderService(opts ...config.ServiceOption) (LimitOrderServiceClientInterface, error) {
	base, err := grpc.NewBaseGRPCClient(
		LimitOrderServiceServiceProviderName,
		NewLimitOrderServiceClient,
		opts...,
	)
	if err != nil {
		return nil, err
	}

	return &limitOrderService{BaseGRPCClient: base}, nil
}

// WithGroup returns a new client instance configured with a different group context.
// This enables convenient group context switching without reconstructing the entire client.
// All other configuration (URL, port, timeout, tracer, API key, etc.) is preserved.
//
// The group parameter must be in the format 'groups/{group_id}' where group_id is a valid
// group identifier (typically a ULID). The new client instance shares no state with the
// original client, allowing safe concurrent usage across different goroutines.
//
// Example:
//
//	// Create initial client with default group from credentials
//	service, err := NewLimitOrderService()
//	if err != nil {
//		log.Fatal(err)
//	}
//	defer service.Close()
//
//	// Switch to a different group context
//	altService := service.WithGroup("groups/01ARZ3NDEKTSV4RRFFQ69G5FAV")
//	defer altService.Close()
//
//	// Both clients can be used independently
//	resp1, _ := service.SomeMethod(ctx, req)      // Uses original group
//	resp2, _ := altService.SomeMethod(ctx, req)   // Uses alternative group
//
// Parameters:
//   - group: The group resource name in format 'groups/{group_id}'
//
// Returns:
//   - LimitOrderServiceClientInterface: New client instance with updated group context
func (s *limitOrderService) WithGroup(group string) LimitOrderServiceClientInterface {
	// Create new base client with copied configuration but new group
	newBase := s.BaseGRPCClient.WithGroup(group)

	// Return new service instance wrapping the new base client
	return &limitOrderService{BaseGRPCClient: newBase}
}

// CreateLimitOrder executes the CreateLimitOrder RPC method with automatic
// client-side validation, timeout handling, distributed tracing, and authentication.
func (s *limitOrderService) CreateLimitOrder(ctx context.Context, request *CreateLimitOrderRequest) (*LimitOrder, error) {
	return grpc.Execute(s.Executor(), ctx, "CreateLimitOrder", request, func(ctx context.Context) (*LimitOrder, error) {
		return s.GrpcClient().CreateLimitOrder(ctx, request)
	})
}

// CancelLimitOrder executes the CancelLimitOrder RPC method with automatic
// client-side validation, timeout handling, distributed tracing, and authentication.
func (s *limitOrderService) CancelLimitOrder(ctx context.Context, request *CancelLimitOrderRequest) (*LimitOrder, error) {
	return grpc.Execute(s.Executor(), ctx, "CancelLimitOrder", request, func(ctx context.Context) (*LimitOrder, error) {
		return s.GrpcClient().CancelLimitOrder(ctx, request)
	})
}

// GetLimitOrder executes the GetLimitOrder RPC method with automatic
// client-side validation, timeout handling, distributed tracing, and authentication.
func (s *limitOrderService) GetLimitOrder(ctx context.Context, request *GetLimitOrderRequest) (*LimitOrder, error) {
	return grpc.Execute(s.Executor(), ctx, "GetLimitOrder", request, func(ctx context.Context) (*LimitOrder, error) {
		return s.GrpcClient().GetLimitOrder(ctx, request)
	})
}

// GetLimitOrderByExternalReference executes the GetLimitOrderByExternalReference RPC method with automatic
// client-side validation, timeout handling, distributed tracing, and authentication.
func (s *limitOrderService) GetLimitOrderByExternalReference(ctx context.Context, request *GetLimitOrderByExternalReferenceRequest) (*LimitOrder, error) {
	return grpc.Execute(s.Executor(), ctx, "GetLimitOrderByExternalReference", request, func(ctx context.Context) (*LimitOrder, error) {
		return s.GrpcClient().GetLimitOrderByExternalReference(ctx, request)
	})
}

// ListLimitOrders executes the ListLimitOrders RPC method with automatic
// client-side validation, timeout handling, distributed tracing, and authentication.
func (s *limitOrderService) ListLimitOrders(ctx context.Context, request *ListLimitOrdersRequest) (*ListLimitOrdersResponse, error) {
	return grpc.Execute(s.Executor(), ctx, "ListLimitOrders", request, func(ctx context.Context) (*ListLimitOrdersResponse, error) {
		return s.GrpcClient().ListLimitOrders(ctx, request)
	})
}

// SearchLimitOrders executes the SearchLimitOrders RPC method with automatic
// client-side validation, timeout handling, distributed tracing, and authentication.
func (s *limitOrderService) SearchLimitOrders(ctx context.Context, request *SearchLimitOrdersRequest) (*SearchLimitOrdersResponse, error) {
	return grpc.Execute(s.Executor(), ctx, "SearchLimitOrders", request, func(ctx context.Context) (*SearchLimitOrdersResponse, error) {
		return s.GrpcClient().SearchLimitOrders(ctx, request)
	})
}

// MonitorLimitOrder executes the MonitorLimitOrder server-side streaming RPC method
// with automatic client-side validation, timeout handling, distributed tracing, and authentication.
// Returns a stream client that yields multiple LimitOrder messages.
//
// The returned stream must be fully consumed or explicitly closed to avoid resource leaks.
// Example usage:
//
//	stream, err := client.MonitorLimitOrder(ctx, request)
//	if err != nil {
//		return err
//	}
//	for {
//		resp, err := stream.Recv()
//		if err == io.EOF {
//			break
//		}
//		if err != nil {
//			return err
//		}
//		// Process resp...
//	}
func (s *limitOrderService) MonitorLimitOrder(ctx context.Context, request *MonitorLimitOrderRequest) (LimitOrderService_MonitorLimitOrderClient, error) {
	return grpc.ExecuteStream(s.Executor(), ctx, "MonitorLimitOrder", request, func(ctx context.Context) (LimitOrderService_MonitorLimitOrderClient, error) {
		return s.GrpcClient().MonitorLimitOrder(ctx, request)
	})
}
